<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>計算機程式教材</title> <link rel="stylesheet" type="text/css" href="./../static/cmsimply.css">

<script type="text/javascript" src="./../static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCSharp.js"></script>
<link type="text/css" rel="stylesheet" href="./../static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- for LaTeX equations 暫時不用
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>
-->
<!-- 暫時不用
<script src="./../static/fengari-web.js"></script>
<script type="text/javascript" src="./../static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->

<script src="./../static/jquery.js"></script>
<script type="text/javascript">
$(function(){
    $("ul.topmenu> li:has(ul) > a").append('<div class="arrow-right"></div>');
    $("ul.topmenu > li ul li:has(ul) > a").append('<div class="arrow-right"></div>');
});
</script>

</head><header><h1>2018 計算機程式教材</h1> <confmenu>
<ul>
<li><a href="index.html">Home</a></li>
<li><a href="sitemap.html">Site Map</a></li>
<li><a href="./../reveal/index.html">reveal</a></li>
<li><a href="./../blog/index.html">blog</a></li>

</ul>
</confmenu></header>
<div class='container'><nav><ul id='css3menu1' class='topmenu'><li><a href='簡介.html'>簡介</a><ul><li><a href='課程規劃.html'>課程規劃</a><li><a href='機械設計.html'>機械設計</a><li><a href='ANSI C.html'>ANSI C</a><li><a href='指標教材.html'>指標教材</a><ul><li><a href='ch1何謂指標.html'>ch1何謂指標</a><li><a href='ch2指標型別與陣列.html'>ch2指標型別與陣列</a><li><a href='ch3指標與字串.html'>ch3指標與字串</a><li><a href='ch4更多關於字串的用法.html'>ch4更多關於字串的用法</a><li><a href='ch5指標與結構.html'>ch5指標與結構</a><li><a href='ch6字串與字串陣列.html'>ch6字串與字串陣列</a><li><a href='ch7多維陣列.html'>ch7多維陣列</a><li><a href='ch8指向陣列的指標.html'>ch8指向陣列的指標</a><li><a href='ch9指標與動態記憶體配置.html'>ch9指標與動態記憶體配置</a><li><a href='ch10指向函式的指標.html'>ch10指向函式的指標</a><li><a href='ch11結語.html'>ch11結語</a></li></ul><li><a href='C++.html'>C++</a><li><a href='Python.html'>Python</a><ul><li><a href='what is new.html'>what is new</a><li><a href='style guide.html'>style guide</a><li><a href='typing.html'>typing</a><li><a href='dunder.html'>dunder</a><li><a href='Flake8.html'>Flake8</a><li><a href='unittest.html'>unittest</a><li><a href='lark.html'>lark</a></li></ul><li><a href='Kotlin.html'>Kotlin</a><li><a href='Red Lang.html'>Red Lang</a></li></ul><li><a href='工具.html'>工具</a><ul><li><a href='Git.html'>Git</a><li><a href='Fossil SCM.html'>Fossil SCM</a><li><a href='Leo Editor.html'>Leo Editor</a><li><a href='SCiTE.html'>SCiTE</a><li><a href='TinyCC.html'>TinyCC</a><li><a href='Qt.html'>Qt</a><li><a href='Kivy.html'>Kivy</a><li><a href='Eirc IDE.html'>Eirc IDE</a><li><a href='CMSimfly.html'>CMSimfly</a></li></ul><li><a href='實習操作.html'>實習操作</a><ul><li><a href='hello.c 與 Github.html'>hello.c 與 Github</a><li><a href='hello.c 與 Fossil.html'>hello.c 與 Fossil</a><li><a href='CMSimfly 操作.html'>CMSimfly 操作</a><li><a href='Pygrouf 操作.html'>Pygrouf 操作</a><li><a href='Pelican 操作.html'>Pelican 操作</a><li><a href='Reveal.js 操作.html'>Reveal.js 操作</a><li><a href='數值分析.html'>數值分析</a><li><a href='Qt C++ 計算器程式.html'>Qt C++ 計算器程式</a><ul><li><a href='Qt5 Tutorial.html'>Qt5 Tutorial</a></li></ul><li><a href='PyQt 計算器程式.html'>PyQt 計算器程式</a><ul><li><a href='PyQt5 實際操作.html'>PyQt5 實際操作</a></li></ul><li><a href='Flask 網際程式.html'>Flask 網際程式</a></li></ul><li><a href='應用範例.html'>應用範例</a><ul><li><a href='計算器.html'>計算器</a><li><a href='Tinkercad.html'>Tinkercad</a><li><a href='讀寫網頁內容.html'>讀寫網頁內容</a><li><a href='查英文單字.html'>查英文單字</a><li><a href='docx 轉 pdf.html'>docx 轉 pdf</a><li><a href='網際繪圖.html'>網際繪圖</a><li><a href='GUI 繪圖.html'>GUI 繪圖</a><ul><li><a href='QPainter.html'>QPainter</a><li><a href='靜態繪圖.html'>靜態繪圖</a><li><a href='Moveblocks.html'>Moveblocks</a><li><a href='PyQt5 範例.html'>PyQt5 範例</a><li><a href='STetris.html'>STetris</a><li><a href='Tetrix.html'>Tetrix</a></li></ul><li><a href='V-rep.html'>V-rep</a><ul><li><a href='Lua 學習.html'>Lua 學習</a></li></ul><li><a href='車輛工程.html'>車輛工程</a><ul><li><a href='維修管理.html'>維修管理</a></li></ul><li><a href='ERPNext.html'>ERPNext</a><li><a href='人臉辨識.html'>人臉辨識</a><li><a href='輔助設計套件.html'>輔助設計套件</a><ul><li><a href='NURB-Python.html'>NURB-Python</a><li><a href='libfive.html'>libfive</a><li><a href='robovision.html'>robovision</a><li><a href='jsketcher.html'>jsketcher</a><li><a href='kmolcad.html'>kmolcad</a></li></li></ul></ul><li><a href='分組專題.html'>分組專題</a><ul><li><a href='分組題目.html'>分組題目</a><li><a href='符號式推導.html'>符號式推導</a><li><a href='CMSimfly 解析.html'>CMSimfly 解析</a><ul><li><a href='CMSimfly 開發.html'>CMSimfly 開發</a></li></ul><li><a href='Pygrouf 解析.html'>Pygrouf 解析</a><li><a href='Pyslvs 解析.html'>Pyslvs 解析</a><ul><li><a href='Pyslvs 範例.html'>Pyslvs 範例</a><li><a href='機構設計參考.html'>機構設計參考</a></li></ul><li><a href='Pyquino 解析.html'>Pyquino 解析</a><li><a href='Solvespace 解析.html'>Solvespace 解析</a><li><a href='V-rep 解析.html'>V-rep 解析</a><li><a href='FreeCAD 解析.html'>FreeCAD 解析</a><li><a href='RigitBody library.html'>RigitBody library</a><li><a href='FiniteElement library.html'>FiniteElement library</a><li><a href='網際平面連桿模擬.html'>網際平面連桿模擬</a></li></ul><li><a href='可攜系統.html'>可攜系統</a><ul><li><a href='帳號整合.html'>帳號整合</a><li><a href='代理主機.html'>代理主機</a></li></ul></nav><section>ch5指標與結構 << <a href='ch5指標與結構.html'>Previous</a> <a href='ch7多維陣列.html'>Next</a> >> ch7多維陣列<br /><h1>ch6字串與字串陣列</h1>
<p>接著, 再回到字串的用法. 下面的例子, 都以全域的方式運用, 亦即, 在任何函式之外發生作用, 包括主函式.</p>
<p>先前的章節曾經談過:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char my_string[40] = "Ted";</pre>
<p>將會配置足夠存放 40 個位元組陣列的空間來存放該變數的值, 並且在最前面的 4 個位元組中放入所設定的字元 (前面三個位元組放入雙引號中的字元, 而最後則放入 '\0')</p>
<p>而實際上, 也可以將 "Ted" 這個字串寫成:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char my_name[] = "Ted";</pre>
<p>編譯器屆時就會計算字元個數, 並且預留最後的 null 字元, 以便能將全部四個字元存入記憶體, 並傳回存放字元的陣列名稱, 這裡採用 my_name.</p>
<p>在某些程式中, 也可以寫成:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char *my_name = "Ted";</pre>
<p>這種方式, 與先前兩種方法有何不同? 答案是: 當然不同. 採用陣列來存放四個位元組是將資料放在靜態記憶體區塊, 每一個字元的最後都會放入 null 字元. 但是若採用指標的方式, 也是需要相同的四個位元組, 並加上 N 個位元組來存放 my_name 這個指標變數 (N 取決於系統, 但通常至少 2 位元組, 也可能是 4 個以上)</p>
<p>陣列的表示法中, my_name 是 &amp;myname[0] 的縮寫, 也就是第一個陣列元素的位址. 由於該陣列位址在執行期間是固定的, 因此不會改變 (不是變數). 而若採用指標的方式, my_name 則是變數. 因此採用指標是較好的方式, 當然也取決於隨後要如何應用這個變數.</p>
<p>若再進一步觀察採用不同方式宣告後, 在函數內將如何發生變化, 這與處在任何函式外的全域用法有很大的不同.</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">void my_function_A(char ptr) { char a[] = "ABCDE" . . } void my_function_B(char ptr)</pre>
<p>在 my_function_A 的案例中, 陣列 a[] 的值, 就是存放其中的資料. 陣列可視為以 ABCDE 值進行啟始化. 而在 my_function_B 的案例, cp 指標值才代表所存放的資料. 指標的啟始是指向 FGHIJ 字串. 在兩個函式內, 變數定義都是局部, 因此 ABCDE 字串存在指標變數所對應值的堆疊中, 而 FGHIJ 則可能存在任何地方. 在我的系統中, 是存在資料區段中.</p>
<p>此外, 採陣列變數自動起始, 就如同 my_function_A 中所示, 在舊的 K&amp;R C 中是無法使用的, 只能用在 ANSI C 的環境中. 這點在考量程式的可攜或向後相容時就顯得很重要.</p>
<p>只要討論有關指標與陣列的關係與差異時, 就需要更進一步討論多維度陣列. 例如下列陣列:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char multi[5][10];</pre>
<p><span>這代表什麼? 讓我們看看.</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char multi[5][10];</pre>
<p>若將有底線的部分視為陣列的變數名稱. 先前的 char 代表資料型別, 而隨後的 [10] 則代表擁有時個字元的陣列. 但是 multi[5] 本身又是一個具有 5 個成員的陣列, 而每一個都帶有 10 個字元的陣列. 亦即, 總共有 5 個陣列各自帶有 10 個字元的陣列.</p>
<p>假設將這個二維的陣列填入資料, 在記憶體中, 可以表示成為五個各自分離的陣列:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">multi[0] = {'0','1','2','3','4','5','6','7','8','9'}
multi[1] = {'a','b','c','d','e','f','g','h','i','j'}
multi[2] = {'A','B','C','D','E','F','G','H','I','J'}
multi[3] = {'9','8','7','6','5','4','3','2','1','0'}
multi[4] = {'J','I','H','G','F','E','D','C','B','A'}</pre>
<p><span>同時, 個別元素可以再表示為:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">multi[0][3] = '3'
multi[1][7] = 'h'
multi[4][0] = 'J'</pre>
<p><span>由於陣列在記憶體中是連續的資料, 因此在真實的記憶區段中, 就成為:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">0123456789abcdefghijABCDEFGHIJ9876543210JIHGFEDCBA
^
|_____ starting at the address &amp;multi[0][0]</pre>
<p>請注意, 這裡並沒有將 multi[0] 寫成"0123456789". 因為若寫成這樣, 電腦會在最 後面補上字串結束用的 '\0', 因為雙引號中間的資料會被當作字串. 這樣, 每一個變數 就會帶有 11 個字元, 而非該有的 10 個字元.</p>
<p>前面的用意在昭示記憶體如何處理二維陣列. 亦即, 以一個二維字元陣列來存放資料, 而不是存成字串陣列.</p>
<p>接著, 編譯器知道陣列中需要多少行, 因此會用 mylti +1 作為 'a' 在第二列之首, 也就是每一列會加上 10, 結合所指的列數來取得正確的資料.</p>
<p>若處理的數值為整數與相同維數的陣列, 在我使用的機器上, 編譯器會加上 10sizeof(int), 而得到 20. 因此第四列第九行的位址, 表示為指標, 將會是 &amp;multi[3][0] 或 (multi + 3). 若希望取得第四列第二個數值, 就可以在此位址上加上 1, 得到下列結果:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">*(*(multi + 3) + 1)</pre>
<p><span>再繼續探究, 可知:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">*(*(multi + row) + col)    與

multi[row][col]            可得到相同的結果.</pre>
<p>下列程式採用整數數列而非字元陣列來驗證這個結果:</p>
<p>------------------- program 6.1 ----------------------</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include &lt;stdio.h&gt;
#define ROWS 5
#define COLS 10
 
int multi[ROWS][COLS];
 
int main(void)
{
    int row, col;
    for (row = 0; row &lt; ROWS; row++)
    {
        for (col = 0; col &lt; COLS; col++)
        {
            multi[row][col] = row*col;
        }
    }
 
    for (row = 0; row &lt; ROWS; row++)
    {
        for (col = 0; col &lt; COLS; col++)
        {
            printf("\n%d  ",multi[row][col]);
            printf("%d ",*(*(multi + row) + col));
        }
    }
 
    return 0;
}</pre>
<p>----------------- end of program 6.1 ---------------------</p>
<p><a href="http://codepad.org/flzRLrx1">執行 Program 6.1</a></p>
<p>由於在陣列程式版本中進行了兩次交互參照取值, 二維陣列的名稱就如同指向陣列的指標. 至於三維陣列則用來處理陣列中陣列所指向的陣列, 因此也等同是指向陣列中陣列的指標. 但這裡的說明將陣列所佔記憶體區段以陣列來加以表示, 因此所處理的記憶體位址為常數而非變數. 亦即所討論的是固定的位址而非變數指標.</p>
<p>上述的取值函式允許從陣列中, 以無需變更位址數值的方式從陣列中取出任何數值 (例如, 以 multi[0][0] 的位址取 multi 符號所對應的值)</p>
<br />ch5指標與結構 << <a href='ch5指標與結構.html'>Previous</a> <a href='ch7多維陣列.html'>Next</a> >> ch7多維陣列</section></div></body></html>
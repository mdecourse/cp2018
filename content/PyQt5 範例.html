<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>計算機程式教材</title> <link rel="stylesheet" type="text/css" href="./../static/cmsimply.css">
<link rel="icon" href="./../static/favicon.ico" type="image/x-icon" />

<script type="text/javascript" src="./../static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCSharp.js"></script>
<link type="text/css" rel="stylesheet" href="./../static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- for LaTeX equations 暫時不用
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>
-->
<!-- 暫時不用
<script src="./../static/fengari-web.js"></script>
<script type="text/javascript" src="./../static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->
<style>
img {
    border: 3px solid red;
}
</style>

<script src="./../static/jquery.js"></script>
<script type="text/javascript">
$(function(){
    $("ul.topmenu> li:has(ul) > a").append('<div class="arrow-right"></div>');
    $("ul.topmenu > li ul li:has(ul) > a").append('<div class="arrow-right"></div>');
});
</script>

</head><header><h1>2018 計算機程式教材</h1> <confmenu>
<ul>
<li><a href="index.html">Home</a></li>
<li><a href="sitemap.html">Site Map</a></li>
<li><a href="./../reveal/index.html">reveal</a></li>
<li><a href="./../blog/index.html">blog</a></li>

</ul>
</confmenu></header>
<div class='container'><nav><ul id='css3menu1' class='topmenu'><li><a href='簡介.html'>簡介</a><ul><li><a href='課程規劃.html'>課程規劃</a><li><a href='機械設計.html'>機械設計</a><li><a href='ANSI C.html'>ANSI C</a><li><a href='指標教材.html'>指標教材</a><ul><li><a href='ch1何謂指標.html'>ch1何謂指標</a><li><a href='ch2指標型別與陣列.html'>ch2指標型別與陣列</a><li><a href='ch3指標與字串.html'>ch3指標與字串</a><li><a href='ch4更多關於字串的用法.html'>ch4更多關於字串的用法</a><li><a href='ch5指標與結構.html'>ch5指標與結構</a><li><a href='ch6字串與字串陣列.html'>ch6字串與字串陣列</a><li><a href='ch7多維陣列.html'>ch7多維陣列</a><li><a href='ch8指向陣列的指標.html'>ch8指向陣列的指標</a><li><a href='ch9指標與動態記憶體配置.html'>ch9指標與動態記憶體配置</a><li><a href='ch10指向函式的指標.html'>ch10指向函式的指標</a><li><a href='ch11結語.html'>ch11結語</a></li></ul><li><a href='C++.html'>C++</a><li><a href='Python.html'>Python</a><ul><li><a href='Python 教材.html'>Python 教材</a><li><a href='what is new.html'>what is new</a><li><a href='style guide.html'>style guide</a><li><a href='typing.html'>typing</a><li><a href='dunder.html'>dunder</a><li><a href='Flake8.html'>Flake8</a><li><a href='unittest.html'>unittest</a><li><a href='lark.html'>lark</a></li></ul><li><a href='Kotlin.html'>Kotlin</a><li><a href='Red Lang.html'>Red Lang</a></li></ul><li><a href='工具.html'>工具</a><ul><li><a href='Git.html'>Git</a><li><a href='Fossil SCM.html'>Fossil SCM</a><li><a href='Leo Editor.html'>Leo Editor</a><li><a href='SCiTE.html'>SCiTE</a><li><a href='TinyCC.html'>TinyCC</a><li><a href='Qt.html'>Qt</a><li><a href='Kivy.html'>Kivy</a><li><a href='Eirc IDE.html'>Eirc IDE</a><li><a href='CMSimfly.html'>CMSimfly</a></li></ul><li><a href='實習操作.html'>實習操作</a><ul><li><a href='2018Fall.html'>2018Fall</a><li><a href='hello.c 與 Github.html'>hello.c 與 Github</a><li><a href='hello.c 與 Fossil.html'>hello.c 與 Fossil</a><li><a href='CMSimfly 操作.html'>CMSimfly 操作</a><li><a href='Pygrouf 操作.html'>Pygrouf 操作</a><li><a href='Pelican 操作.html'>Pelican 操作</a><li><a href='Reveal.js 操作.html'>Reveal.js 操作</a><li><a href='數值分析.html'>數值分析</a><li><a href='Qt C++ 計算器程式.html'>Qt C++ 計算器程式</a><ul><li><a href='Qt5 Tutorial.html'>Qt5 Tutorial</a></li></ul><li><a href='PyQt 計算器程式.html'>PyQt 計算器程式</a><ul><li><a href='PyQt5 實際操作.html'>PyQt5 實際操作</a></li></ul><li><a href='Flask 網際程式.html'>Flask 網際程式</a></li></ul><li><a href='應用範例.html'>應用範例</a><ul><li><a href='計算器.html'>計算器</a><li><a href='Tinkercad.html'>Tinkercad</a><li><a href='讀寫網頁內容.html'>讀寫網頁內容</a><li><a href='查英文單字.html'>查英文單字</a><li><a href='docx 轉 pdf.html'>docx 轉 pdf</a><li><a href='網際繪圖.html'>網際繪圖</a><li><a href='GUI 繪圖.html'>GUI 繪圖</a><ul><li><a href='QPainter.html'>QPainter</a><li><a href='靜態繪圖.html'>靜態繪圖</a><li><a href='Moveblocks.html'>Moveblocks</a><li><a href='PyQt5 範例.html'>PyQt5 範例</a><li><a href='STetris.html'>STetris</a><li><a href='Tetrix.html'>Tetrix</a></li></ul><li><a href='V-rep.html'>V-rep</a><ul><li><a href='Lua 學習.html'>Lua 學習</a></li></ul><li><a href='車輛工程.html'>車輛工程</a><ul><li><a href='維修管理.html'>維修管理</a></li></ul><li><a href='ERPNext.html'>ERPNext</a><li><a href='人臉辨識.html'>人臉辨識</a><li><a href='輔助設計套件.html'>輔助設計套件</a><ul><li><a href='NURB-Python.html'>NURB-Python</a><li><a href='libfive.html'>libfive</a><li><a href='robovision.html'>robovision</a><li><a href='jsketcher.html'>jsketcher</a><li><a href='kmolcad.html'>kmolcad</a></li></li></ul></ul><li><a href='分組專題.html'>分組專題</a><ul><li><a href='分組題目.html'>分組題目</a><li><a href='符號式推導.html'>符號式推導</a><li><a href='CMSimfly 解析.html'>CMSimfly 解析</a><ul><li><a href='CMSimfly 開發.html'>CMSimfly 開發</a></li></ul><li><a href='Pygrouf 解析.html'>Pygrouf 解析</a><li><a href='Pyslvs 解析.html'>Pyslvs 解析</a><ul><li><a href='Pyslvs 範例.html'>Pyslvs 範例</a><li><a href='機構設計參考.html'>機構設計參考</a></li></ul><li><a href='Pyquino 解析.html'>Pyquino 解析</a><li><a href='Solvespace 解析.html'>Solvespace 解析</a><li><a href='V-rep 解析.html'>V-rep 解析</a><li><a href='FreeCAD 解析.html'>FreeCAD 解析</a><li><a href='RigitBody library.html'>RigitBody library</a><li><a href='FiniteElement library.html'>FiniteElement library</a><li><a href='網際平面連桿模擬.html'>網際平面連桿模擬</a></li></ul><li><a href='可攜系統.html'>可攜系統</a><ul><li><a href='帳號整合.html'>帳號整合</a><li><a href='代理主機.html'>代理主機</a></li></ul></nav><section>Moveblocks << <a href='Moveblocks.html'>Previous</a> <a href='STetris.html'>Next</a> >> STetris<br /><h1>PyQt5 範例</h1>
<p>參考: <a href="https://www.e-education.psu.edu/geog489/node/2292">https://www.e-education.psu.edu/geog489/node/2292</a> </p>
<p>利用 PyQt5 建立程式, 都需要透過 QApplication 類別建立應用程式物件, 並且以 exec() 進入主事件迴圈, 完成所需的初始化與後台事物管理. </p>
<p>此一透過 QApplication 建立的 PyQt5 應用程式物件, 對應至一變數名稱 app 後,  接著設置所需的 GUI 元件, 並在程式最後, 調用此應用程式物件的 exec() 方法執行, 以及處理用戶輸入.</p>
<p>QApplication  與 QWidget 類別隸屬於 PyQt5.QtWidgets 模組.</p>
<p>app.exec() 執行後的傳回值 0, 用於從 Python 標準程式庫調用 sys.exit() 函式正常退出 Python 程式.</p>
<p><a href="http://doc.qt.io/qt-5/qapplication.html#exec">QApplication::exec() 說明文件</a></p>
<p><a href="https://docs.python.org/3/library/sys.html">sys.exit() 說明文件</a></p>
<p>Label, push button, line edit, layout, signal and slot:</p>
<p><a href="https://docs.python.org/3/tutorial/classes.html">https://docs.python.org/3/tutorial/classes.html</a> </p>
<p>PyQt5 程式流程:</p>
<ol>
<li>建立 QApplication 物件</li>
<li> 建立主應用程式視窗</li>
<li>設定主視窗參數, 建立或新增子部件</li>
<li>顯示主視窗</li>
<li>啟動 QApplication 物件</li>
</ol>
<p>PyQt5 主要模組:</p>
<ol>
<li>QtCore – 核心非 GUI 工具</li>
<li>QtGui – 視窗系統整合, 事件處理, 2D 繪圖, 影像處理與字型</li>
<li>QtWidgets – 基本 UI 元件, 包含標籤, 按鈕, 文字輸入, 數列, 表格, 表單與工具箱</li>
</ol>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5.QtCore import *
from PyQt5.QtWidgets import *

# 繼承 QWidget 部件, 建立 Form 類別
class Form(QWidget):
    # 類別建構子, 建立案例時會自動執行
    # 無 parent 的 widget 為 window
    def __init__(self, parent=None):
        # 執行父物件的建構子
        super().__init__()

        # 建立 Label 物件
        nameLabel = QLabel("Name:")
        # 建立 Line Edit 物件
        # instance variable
        self.nameLine = QLineEdit()
        self.submitButton = QPushButton("&amp;Submit")

        buttonLayout1 = QVBoxLayout()
        buttonLayout1.addWidget(nameLabel)
        buttonLayout1.addWidget(self.nameLine)
        buttonLayout1.addWidget(self.submitButton)

        self.submitButton.clicked.connect(self.submitContact)

        mainLayout = QGridLayout()
        # mainLayout.addWidget(nameLabel, 0, 0)
        mainLayout.addLayout(buttonLayout1, 0, 1)

        self.setLayout(mainLayout)
        self.setWindowTitle("Hello Qt")

    def submitContact(self):
        name = self.nameLine.text()

        if name == "":
            QMessageBox.information(self, "Empty Field",
                                    "Please enter a name and address.")
            return
        else:
            QMessageBox.information(self, "Success!",
                                    "Hello %s!" % name)

if __name__ == '__main__':
    import sys

    app = QApplication(sys.argv)

    screen = Form()
    screen.show()

    sys.exit(app.exec())</pre>
<p><a href="https://www.thehackeruniversity.com/2014/01/26/pyqt5-beginner-tutorial-part-2/">Simple address book</a>:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (QGridLayout, QHBoxLayout, QLabel, QLineEdit,
        QMessageBox, QPushButton, QTextEdit, QVBoxLayout, QWidget)

class SortedDict(dict):
    class Iterator(object):
        def __init__(self, sorted_dict):
            self._dict = sorted_dict
            self._keys = sorted(self._dict.keys())
            self._nr_items = len(self._keys)
            self._idx = 0

        def __iter__(self):
            return self

        def next(self):
            if self._idx &gt;= self._nr_items:
                raise StopIteration

            key = self._keys[self._idx]
            value = self._dict[key]
            self._idx += 1

            return key, value

        __next__ = next

    def __iter__(self):
        return SortedDict.Iterator(self)

    iterkeys = __iter__

class AddressBook(QWidget):
    def __init__(self, parent=None):
        super(AddressBook, self).__init__(parent)

        self.contacts = SortedDict()
        self.oldName = ''
        self.oldAddress = ''

        nameLabel = QLabel("Name:")
        self.nameLine = QLineEdit()
        self.nameLine.setReadOnly(True)

        addressLabel = QLabel("Address:")
        self.addressText = QTextEdit()
        self.addressText.setReadOnly(True)

        self.addButton = QPushButton("&amp;Add")
        self.addButton.show()
        self.submitButton = QPushButton("&amp;Submit")
        self.submitButton.hide()
        self.cancelButton = QPushButton("&amp;Cancel")
        self.cancelButton.hide()
        self.nextButton = QPushButton("&amp;Next")
        self.nextButton.setEnabled(False)
        self.previousButton = QPushButton("&amp;Previous")
        self.previousButton.setEnabled(False)

        self.addButton.clicked.connect(self.addContact)
        self.submitButton.clicked.connect(self.submitContact)
        self.cancelButton.clicked.connect(self.cancel)
        self.nextButton.clicked.connect(self.next)
        self.previousButton.clicked.connect(self.previous)

        buttonLayout1 = QVBoxLayout()
        buttonLayout1.addWidget(self.addButton, Qt.AlignTop)
        buttonLayout1.addWidget(self.submitButton)
        buttonLayout1.addWidget(self.cancelButton)
        buttonLayout1.addStretch()

        buttonLayout2 = QHBoxLayout()
        buttonLayout2.addWidget(self.previousButton)
        buttonLayout2.addWidget(self.nextButton)

        mainLayout = QGridLayout()
        mainLayout.addWidget(nameLabel, 0, 0)
        mainLayout.addWidget(self.nameLine, 0, 1)
        mainLayout.addWidget(addressLabel, 1, 0, Qt.AlignTop)
        mainLayout.addWidget(self.addressText, 1, 1)
        mainLayout.addLayout(buttonLayout1, 1, 2)
        mainLayout.addLayout(buttonLayout2, 3, 1)

        self.setLayout(mainLayout)
        self.setWindowTitle("Simple Address Book")

    def addContact(self):
        self.oldName = self.nameLine.text()
        self.oldAddress = self.addressText.toPlainText()

        self.nameLine.clear()
        self.addressText.clear()

        self.nameLine.setReadOnly(False)
        self.nameLine.setFocus(Qt.OtherFocusReason)
        self.addressText.setReadOnly(False)

        self.addButton.setEnabled(False)
        self.nextButton.setEnabled(False)
        self.previousButton.setEnabled(False)
        self.submitButton.show()
        self.cancelButton.show()

    def submitContact(self):
        name = self.nameLine.text()
        address = self.addressText.toPlainText()

        if name == "" or address == "":
            QMessageBox.information(self, "Empty Field",
                    "Please enter a name and address.")
            return

        if name not in self.contacts:
            self.contacts[name] = address
            QMessageBox.information(self, "Add Successful",
                    "\"%s\" has been added to your address book." % name)
        else:
            QMessageBox.information(self, "Add Unsuccessful",
                    "Sorry, \"%s\" is already in your address book." % name)
            return

        if not self.contacts:
            self.nameLine.clear()
            self.addressText.clear()

        self.nameLine.setReadOnly(True)
        self.addressText.setReadOnly(True)
        self.addButton.setEnabled(True)

        number = len(self.contacts)
        self.nextButton.setEnabled(number &gt; 1)
        self.previousButton.setEnabled(number &gt; 1)

        self.submitButton.hide()
        self.cancelButton.hide()

    def cancel(self):
        self.nameLine.setText(self.oldName)
        self.addressText.setText(self.oldAddress)

        if not self.contacts:
            self.nameLine.clear()
            self.addressText.clear()

        self.nameLine.setReadOnly(True)
        self.addressText.setReadOnly(True)
        self.addButton.setEnabled(True)

        number = len(self.contacts)
        self.nextButton.setEnabled(number &gt; 1)
        self.previousButton.setEnabled(number &gt; 1)

        self.submitButton.hide()
        self.cancelButton.hide()

    def next(self):
        name = self.nameLine.text()
        it = iter(self.contacts)

        try:
            while True:
                this_name, _ = it.next()

                if this_name == name:
                    next_name, next_address = it.next()
                    break
        except StopIteration:
            next_name, next_address = iter(self.contacts).next()

        self.nameLine.setText(next_name)
        self.addressText.setText(next_address)

    def previous(self):
        name = self.nameLine.text()

        prev_name = prev_address = None
        for this_name, this_address in self.contacts:
            if this_name == name:
                break

            prev_name = this_name
            prev_address = this_address
        else:
            self.nameLine.clear()
            self.addressText.clear()
            return

        if prev_name is None:
            for prev_name, prev_address in self.contacts:
                pass

        self.nameLine.setText(prev_name)
        self.addressText.setText(prev_address)

if __name__ == '__main__':
    import sys

    from PyQt5.QtWidgets import QApplication

    app = QApplication(sys.argv)

    addressBook = AddressBook()
    addressBook.show()

    sys.exit(app.exec_())</pre>
<p>simple Scintilla editor:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sys

import sip
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.Qsci import QsciScintilla, QsciLexerPython


class SimplePythonEditor(QsciScintilla):
    ARROW_MARKER_NUM = 8

    def __init__(self, parent=None):
        super().__init__()

        # Set the default font
        font = QFont()
        font.setFamily('Courier')
        font.setFixedPitch(True)
        font.setPointSize(10)
        self.setFont(font)
        self.setMarginsFont(font)
        self.setUtf8(True)

        # Margin 0 is used for line numbers
        fontmetrics = QFontMetrics(font)
        self.setMarginsFont(font)
        self.setMarginWidth(0, fontmetrics.width("00000") + 6)
        self.setMarginLineNumbers(0, True)
        self.setMarginsBackgroundColor(QColor("#cccccc"))

        # Clickable margin 1 for showing markers
        self.setMarginSensitivity(1, True)
        self.marginClicked.connect(self.on_margin_clicked)
        self.markerDefine(QsciScintilla.RightArrow,
            self.ARROW_MARKER_NUM)
        self.setMarkerBackgroundColor(QColor("#ee1111"),
            self.ARROW_MARKER_NUM)

        # Brace matching: enable for a brace immediately before or after
        # the current position
        #
        self.setBraceMatching(QsciScintilla.SloppyBraceMatch)

        # Current line visible with special background color
        self.setCaretLineVisible(True)
        self.setCaretLineBackgroundColor(QColor("#ffe4e4"))

        # Set Python lexer
        # Set style for Python comments (style number 1) to a fixed-width
        # courier.
        #

        lexer = QsciLexerPython()
        lexer.setDefaultFont(font)
        self.setLexer(lexer)

        text = bytearray(str.encode("Arial"))
        # 32, "Courier New"
        self.SendScintilla(QsciScintilla.SCI_STYLESETFONT, 1, text)

        # Don't want to see the horizontal scrollbar at all
        # Use raw message to Scintilla here (all messages are documented
        # here: http://www.scintilla.org/ScintillaDoc.html)
        self.SendScintilla(QsciScintilla.SCI_SETHSCROLLBAR, 0)

        # not too small
        self.setMinimumSize(600, 450)

    def on_margin_clicked(self, nmargin, nline, modifiers):
        # Toggle marker for the line the margin was clicked on
        if self.markersAtLine(nline) != 0:
            self.markerDelete(nline, self.ARROW_MARKER_NUM)
        else:
            self.markerAdd(nline, self.ARROW_MARKER_NUM)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    editor = SimplePythonEditor()
    editor.show()
    editor.setText(open(sys.argv[0]).read())
    app.exec()</pre>
<p>csv file example:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import csv
import sys
from PyQt5.QtWidgets import (
    QApplication,
    QMainWindow,
    qApp,
    QAction,
    QWidget,
    QFileDialog,
    QTableView
)
from PyQt5.QtGui import (
    QStandardItemModel,
    QStandardItem
)
from PyQt5.QtCore import (
    Qt,
    QAbstractTableModel,
    QVariant
)

class MainWindow(QMainWindow):

    def __init__(self):
        super().__init__()
        self.setWindowTitle("CSV GUI")
        self.create_menu_bar()

    def create_menu_bar(self):
        menu_bar = self.menuBar()
        menu_bar.setNativeMenuBar(False)
        self.create_file_menu(menu_bar)

    def create_file_menu(self, menu_bar):
        exit = QAction("Exit", self)
        exit.setShortcut("Ctrl+Q")
        exit.setStatusTip("Exit CSV GUI")
        exit.triggered.connect(qApp.quit)

        open = QAction("&amp;Open", self)
        open.setShortcut("Ctrl+O")
        open.setStatusTip("Open a CSV file")
        open.triggered.connect(self.open_file)

        file_menu = menu_bar.addMenu("&amp;File")
        file_menu.addAction(open)
        file_menu.addAction(exit)

    def open_file(self):
        file_name, filter = \
            QFileDialog.getOpenFileName(self, "Open file", ".",
                                        "All files (*);;CSV Files (*.csv)")

        with open(file_name) as fin:
            csv_data = [row for row in csv.reader(fin)]
        table_model = SimpleTableModel(csv_data[0], csv_data[1:])
        table_view = QTableView()
        table_view.setModel(table_model)
        self.setCentralWidget(table_view)

class SimpleTableModel(QAbstractTableModel):

    def __init__(self, headers, rows):
        QAbstractTableModel.__init__(self, None)
        self.headers = headers
        self.rows = rows

    def rowCount(self, parent):
        return len(self.rows)

    def columnCount(self, parent):
        return len(self.headers)

    def data(self, index, role):
        if (not index.isValid()) or (role != Qt.DisplayRole):
            return QVariant()
        else:
            return QVariant(self.rows[index.row()][index.column()])

    def headerData(self, section, orientation, role):
        if role != Qt.DisplayRole:
            return QVariant()
        elif orientation == Qt.Vertical:
            return section + 1
        else:
            return self.headers[section]


if __name__=='__main__':
    app = QApplication(sys.argv)
    main = MainWindow()
    main.show()
    sys.exit(app.exec())
</pre>
<p>Graphics 範例:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from math import pi
import sys, os.path
from PyQt5.QtCore import *
from PyQt5.QtGui import *

from PyQt5.QtWidgets import QApplication, QWidget


# library version number
__version__ = "3.0.7pyqt"

print("Imported cs1lib, version " + __version__)

# hint to window manager where to place graphics window
WINDOW_X = 300
WINDOW_Y = 300

# Global canvas object
canvas = None

# main app is global to allow things like timers to be started before/without graphics loop
app = QApplication(sys.argv)

# used for noop callbacks
def noop(*args, **kwargs):
    pass

# Generic State class used to create objects to pass between callbacks in cs1 examples
#   (Monkey-patched to add variables in early examples.)

class State():
    def __init__(self):
        pass

class CS1Image(QImage):
    def get_pixel(self, x, y):
        p = self.pixel(x, y)

        r = qRed(p) / 255.0
        g = qGreen(p) / 255.0
        b = qBlue(p) / 255.0
        a = qAlpha(p) / 255.0

        return (r, g, b, a)

    def set_pixel(self, x, y, r, g, b, a = 1.0):
        ri  = int(r * 255)
        gi  = int(g * 255)
        bi  = int(b * 255)
        ai  = int(a * 255)

        qrgba = qRgba ( ri, gi, bi, ai )
        self.setPixel(x, y, qrgba)

class CS1Canvas(QWidget):

    def __init__(self, draw_fn, data, window_x, window_y, width, height, title, framerate,
                 mouse_press, mouse_release, mouse_move,
                 key_press, key_release):
        super(CS1Canvas, self).__init__()

        # store callback function
        self.draw_fn = draw_fn
        self.mouse_press = mouse_press
        self.mouse_release = mouse_release
        self.mouse_move = mouse_move
        self.key_press = key_press
        self.key_release = key_release

        # data to pass to callback functions
        self.data = data

        self.window_x = window_x
        self.window_y = window_y

        self.width = width
        self.height = height
        self.title = title
        self.framerate = framerate

        # basic state setup

        self.fill_enabled = True
        self.stroke_enabled = True

        self.stroke_width = 1

        self.clear_color = (1, 1, 1, 1)
        self.pen_color = (0, 0, 0, 1)
        self.fill_color = (0, 0, 0, 1)

        # Initial font

        self.font_name = "Arial"
        self.font_size = 14
        self.font_style = QFont.Normal
        self.font_italic = False

        # initialize image just so that there is one for first redraw
        self.image = QImage(self.size(), QImage.Format_ARGB32_Premultiplied)
        self.init_qt()

        # get the size right this time
        self.image = QImage(self.size(), QImage.Format_ARGB32_Premultiplied)

        self.ipainter = QPainter(self.image)
        self.ipainter.setRenderHint(QPainter.Antialiasing, True)
        self.ipainter.setRenderHint(QPainter.SmoothPixmapTransform, True)

        self.closed = False

        # store the set of currently pressed keys
        self.keys_down = set()

        self.mouse_down = False
        self.mx = -1
        self.my = -1

        #self.clear()
        self.timer = QTimer()
        self.timer.timeout.connect(self.draw)
        self.timer.start(1000 / self.framerate)



    def init_qt(self):

        # self.setGeometry(self.window_x, self.window_y, self.width, self.height)
        self.setFixedSize(self.width, self.height)
        self.setWindowTitle(self.title)

        self.show()

        # enable tracking mouse during mouse move
        self.setMouseTracking(True)

        #self.enable_smoothing()

        self.raise_()

    def paintEvent(self, event):

        screen_painter = QPainter(self)

        screen_painter.drawImage(0, 0, self.image)

        screen_painter.end()


    def closeEvent(self, event):
        # qt unhappy if a reference to ipainter is still hanging
        #   around on close

        self.timer.stop()

        self.ipainter = None



    # used for main rendering loop
    def draw(self):
        #print("draw called")

        if self.data:
            self.draw_fn(self.data)
        else:
            self.draw_fn()

        self.update()


    def mousePressEvent(self, event):
        mx = event.x()
        my = event.y()

        self.mouse_down = True
        self.mx = mx
        self.my = my

        if self.data:
            self.mouse_press(mx, my, self.data)
        else:
            self.mouse_press(mx, my)


    def mouseReleaseEvent(self, event):
        mx = event.x()
        my = event.y()

        self.mouse_down = False
        self.mx = mx
        self.my = my

        if self.data:
            self.mouse_release(mx, my, self.data)
        else:
            self.mouse_release(mx, my)

    def mouseMoveEvent(self, event):
        mx = event.x()
        my = event.y()

        self.mx = mx
        self.my = my

        if self.data:
            self.mouse_move(mx, my, self.data)
        else:
            self.mouse_move(mx, my)

    @staticmethod
    def get_key_str(event):
        #key = event.key()
        #print("text: " + event.text())
        #if key &gt;=65 and key &lt;= 90:
        #    modifiers = event.modifiers()
        #    print(str(modifiers))
        #    if (modifiers &amp; Qt.ShiftModifier) == 0:
        #        print("no shift " + chr(key))
        #        key += 32
        #
        #if key &gt;= 0 and key &lt;=255:
        #    return chr(key)

        #return None
        return event.text()


    def keyPressEvent(self, event):

        key_str= self.get_key_str(event)

        self.keys_down.add(key_str)
        print("key pressed " + key_str)
        if key_str:
            if self.data:
                self.key_press(key_str, self.data)
            else:
                self.key_press(key_str)

    def keyReleaseEvent(self, event):
        key_str = self.get_key_str(event)
        self.keys_down.discard(key_str)

        if key_str:
            if self.data:
                self.key_release(key_str, self.data)
            else:
                self.key_release(key_str)

    def is_key_pressed(self, key):
        return key in self.keys_down

    # Commands that affect state such as color or stroke

    # update functions that update the state of Qt based on
    #  state variables.  Call after changing relevant state variables.

    def enable_smoothing(self):
        # left in only for backwards compatibility.  antialising on by default
        pass

    def update_font(self):
        f = QFont(self.font_name, self.font_size, self.font_style, self.font_italic)
        self.ipainter.setFont(f)

    def update_pen(self):
        # set stroke color and width
        if self.stroke_enabled:
            r = int(self.pen_color[0] * 255)
            g = int(self.pen_color[1] * 255)
            b = int(self.pen_color[2] * 255)
            a = int(self.pen_color[3] * 255)
            pen = QPen(QColor(r, g, b, a))
            pen.setWidth(self.stroke_width)
            self.ipainter.setPen(pen)
        else:
            self.ipainter.setPen(Qt.NoPen)

    def update_brush(self):
        # set fill color
        if self.fill_enabled:
            r = int(self.fill_color[0] * 255)
            g = int(self.fill_color[1] * 255)
            b = int(self.fill_color[2] * 255)
            a = int(self.fill_color[3] * 255)
            self.ipainter.setBrush(QBrush(QColor(r, g, b, a)))
        else:
            self.ipainter.setBrush(Qt.NoBrush)

    def set_clear_color(self, r, g, b, alpha=1.0):
        self.clear_color = (r, g, b, alpha)

    def set_stroke_color(self, r, g, b, alpha=1.0):
        self.pen_color = (r, g, b, alpha)
        self.update_pen()

    def set_stroke_width(self, width):
        self.stroke_width = width
        self.update_pen()

    def set_fill_color(self, r, g, b, alpha=1.0):
        self.fill_color = (r, g, b, alpha)
        self.enable_fill()

    def enable_fill(self):
        self.fill_enabled = True
        self.update_brush()

    def disable_fill(self):
        self.fill_enabled = False
        self.update_brush()

    def enable_stroke(self):
        self.stroke_enabled = True
        self.update_pen()

    def disable_stroke(self):
        self.stroke_enabled = False
        self.update_pen()

    def set_font(self, font_name):
        self.font_name = font_name
        self.update_font()

    def set_font_size(self, size):
        self.font_size = size
        self.update_font()

    def set_font_normal(self):
        self.font_style = QFont.Normal
        self.font_italic = False
        self.update_font()

    def set_font_bold(self):
        self.font_style = QFont.Bold
        self.update_font()

    def set_font_italic(self):
        self.font_italic = True
        self.update_font()


    def rotate(self, angle):
        self.ipainter.rotate(angle)

    def translate(self, x, y):
        self.ipainter.translate(x, y)

    def scale(self, sx, sy):
        self.ipainter.scale(sx, sy)

    def save(self):
        self.ipainter.save()

    def restore(self):
        self.ipainter.restore()

    # Drawing command wrapper methods

    def clear(self):

        r = int(self.clear_color[0] * 255)
        g = int(self.clear_color[1] * 255)
        b = int(self.clear_color[2] * 255)
        a = int(self.clear_color[3] * 255)

        self.ipainter.setBackground(QBrush(QColor(r, g, b, a)))
        #print(self.image.rect())
        self.ipainter.eraseRect(self.image.rect());

    def draw_point(self, x, y):
        self.ipainter.drawPoint(x, y)

    def draw_line(self, x1, y1, x2, y2):
        self.ipainter.drawLine(x1, y1, x2, y2)

    def draw_rectangle(self, x, y, w, h):
        self.ipainter.drawRect(x, y, w, h)

    def draw_polygon(self, vertices):
        qpoints = []

        for vertex in vertices:
            qpoints.append(QPoint(vertex[0], vertex[1]))

        poly = QPolygonF(qpoints)
        self.ipainter.drawPolygon(poly)

    def draw_ellipse(self, x, y, rx, ry):
        self.ipainter.drawEllipse(QRectF(x - rx, y - ry, rx * 2, ry * 2))

    def draw_text(self, s, x, y):

        self.ipainter.drawText(x, y, s)


    def get_text_width(self, str):
        f = QFont(self.font_name, self.font_size, self.font_style, self.font_italic)
        fmetric = QFontMetrics(f)
        #return fmetric.boundingRect(str).width()
        return fmetric.width(str)

    def get_text_height(self):
        f = QFont(self.font_name, self.font_size, self.font_style, self.font_italic)
        fmetric = QFontMetrics(f)
        #return fmetric.boundingRect(str).height()
        return fmetric.height()


    def draw_image(self, image, x, y):
        self.ipainter.drawImage(x, y, image)




# cs1lib drawing commands

#  utility

def is_key_pressed(key):
    return canvas.is_key_pressed(key)

def is_mouse_pressed():
    return canvas.mouse_down

def mouse_x():
    return canvas.mx

def mouse_y():
    return canvas.my

def degrees(rad):
    return 180 * rad / pi

#  state commands

def enable_smoothing():
    pass


def disable_smoothing():
    pass


def enable_fill():
    canvas.enable_fill()


def disable_fill():
    canvas.disable_fill()


def set_fill_color(r, g, b, alpha=1.0):
    canvas.set_fill_color(r, g, b, alpha)


def set_clear_color(r, g, b, alpha=1.0):
    canvas.set_clear_color(r, g, b, alpha)


def enable_stroke():
    canvas.enable_stroke()


def disable_stroke():
    canvas.disable_stroke()


def set_stroke_color(r, g, b, alpha=1.0):
    canvas.set_stroke_color(r, g, b, alpha)


def set_stroke_width(width):
    canvas.set_stroke_width(width)


def set_font(font_name):
    canvas.set_font(font_name)


def set_font_size(font_size):
    canvas.set_font_size(font_size)


def set_font_normal():
    canvas.set_font_normal()


def set_font_bold():
    canvas.set_font_bold()

def set_font_italic():
    canvas.set_font_italic()


#  drawing commands

def clear():
    canvas.clear()

def draw_point(x, y):
    canvas.draw_point(x, y)


def draw_line(x1, y1, x2, y2):
    canvas.draw_line(x1, y1, x2, y2)


def draw_polygon(vertices):
    canvas.draw_polygon(vertices)


def draw_triangle(x1, y1, x2, y2, x3, y3):
    draw_polygon([(x1, y1), (x2, y2), (x3, y3)])


def draw_circle(x, y, r):
    draw_ellipse(x, y, r, r)


def draw_ellipse(x, y, rx, ry):
    assert rx &gt;= 0
    assert ry &gt;= 0

    if rx == 0 or ry == 0:
        return

    canvas.draw_ellipse(x, y, rx, ry)


def draw_rectangle(x, y, w, h):
    canvas.draw_rectangle(x, y, w, h)


def draw_text(string, x, y):
    canvas.draw_text(string, x, y)



## transformations and canvas state functions

def push_state():
    canvas.save()

def pop_state():
    canvas.restore()

def rotate(degrees):
    canvas.rotate(degrees)

def translate(x, y):
    canvas.translate(x, y)

# Images

def draw_image(image, x, y, cx = 0, cy = 0, theta = 0):
    push_state()
    translate(x - cx, y - cy)

    if theta != 0:

        translate(cx, cy)
        rotate(theta)
        translate(-cx, -cy)

    canvas.draw_image(image, 0, 0)

    pop_state()

def load_image(filename):
    img = CS1Image()
    img.load(filename)
    return img


def get_text_width(string):
    return canvas.get_text_width(string)


def get_text_height():
    return canvas.get_text_height()

# Main graphics loop

# the frames parameters gives the number of frames to display on the
#  browser version of cs1lib.  Ignored in qt version.
def start_graphics(draw_func=noop, frames=1, data=None, framerate=40,
                title="cs1", width=400, height=400,
                mouse_press=noop, mouse_release = noop, mouse_move=noop,
                key_press=noop, key_release=noop):

    global canvas

    canvas = CS1Canvas(draw_fn = draw_func, data = data, window_x=WINDOW_X, window_y=WINDOW_Y,
                       width=width, height=height, title=title, framerate=framerate,
                       mouse_press=mouse_press, mouse_release=mouse_release, mouse_move=mouse_move,
                       key_press=key_press, key_release=key_release)



    sys.exit(app.exec_())

def cs1_quit():
    print("cs1_quit called")
    app.quit()
    exit()


# for testing purposes
if __name__ == '__main__':

    vx = 1
    x = 200
    y = 200

    def on_click(mx, my):
        print("Mouse click! " + str(mx) + " " + str(my))

    def on_move(mx, my):
        #print("Mouse move! " + str(mx) + " " + str(my))
        pass

    def on_release(mx, my):
        print("Mouse up! " + str(mx) + " " + str(my))

    def on_keydown(key):
        print("Pressed " + key)

    def on_keyup(key):
        print("Released " + key)


    def draw():
        global x, vx
        clear()

        set_clear_color(.8, .4, .4)
        clear()

        set_fill_color(.2, .5, .9)
        set_stroke_color(1, 1, 0)
        draw_rectangle(100, 100, 200, 200)

        set_stroke_color(0, 0, 0)
        set_fill_color(1, 1, 1)
        draw_circle(200, 200, 100)

        if star_img:
            draw_image(star_img, 200, 200, star_img.width()/2, star_img.height()/ 2, x)


        draw_circle(x, y, 5)


        x += vx

        if x + 5 &gt; 300 or x - 5 &lt; 100:
            vx *= -1

        set_font("Times")
        set_font_bold()
        set_font_italic()
        set_font_size(20)

        text = "Hello, world!"
        w = get_text_width(text)

        draw_text("Hello, world!", 200 - w/2, 277)

        h = get_text_height()
        draw_text(str(mouse_x()), 10, 400)
        draw_text( str(mouse_y()), 10, 400 + h)
        draw_text( str(is_mouse_pressed()), 10, 400 + 2 * h)


    star_img = None
    if os.path.exists("star.png"):
        star_img = load_image("star.png")

    start_graphics(draw, width=500, height=500, mouse_press = on_click, mouse_release = on_release, mouse_move = on_move,
                   key_press=on_keydown, key_release=on_keyup)</pre>
<p>html 轉 pdf:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sys
from PyQt5 import QtCore, QtWidgets, QtWebEngineWidgets

app = QtWidgets.QApplication(sys.argv)
loader = QtWebEngineWidgets.QWebEngineView()
loader.setZoomFactor(1)
loader.page().pdfPrintingFinished.connect(
    lambda *args: print('finished:', args))
loader.load(QtCore.QUrl('http://mde.tw/cadp2018/content/index.html'))

def emit_pdf(finished):
    loader.show()
    loader.page().printToPdf("test.pdf")

loader.loadFinished.connect(emit_pdf)

app.exec()</pre>
<p>mouse event and line drawing:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5 import QtWidgets, QtGui, QtCore


class Window(QtWidgets.QWidget):
    def __init__(self):
        QtWidgets.QWidget.__init__(self)
        self.view = View(self)
        self.button = QtWidgets.QPushButton('Clear View', self)
        self.button.clicked.connect(self.handleClearView)
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.view)
        layout.addWidget(self.button)

    def handleClearView(self):
        self.view.scene().clear()

class View(QtWidgets.QGraphicsView):
    def __init__(self, parent):
        QtWidgets.QGraphicsView.__init__(self, parent)
        self.setScene(QtWidgets.QGraphicsScene(self))
        self.setSceneRect(QtCore.QRectF(self.viewport().rect()))

    def mousePressEvent(self, event):
        self._start = event.pos()

    def mouseReleaseEvent(self, event):
        start = QtCore.QPointF(self.mapToScene(self._start))
        end = QtCore.QPointF(self.mapToScene(event.pos()))
        self.scene().addItem(
            QtWidgets.QGraphicsLineItem(QtCore.QLineF(start, end)))
        for point in (start, end):
            text = self.scene().addSimpleText(
                '(%d, %d)' % (point.x(), point.y()))
            text.setBrush(QtCore.Qt.red)
            text.setPos(point)

if __name__ == '__main__':

    import sys
    app = QtWidgets.QApplication(sys.argv)
    window = Window()
    window.resize(640, 480)
    window.show()
    sys.exit(app.exec())</pre>
<p>在場景中加入元件 (<a href="https://github.com/mmisono/pyqt5-example/blob/master/tic_tac_toe.py">來源</a>)</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#!/usr/bin/env python

from PyQt5.QtCore import (QLineF, QPointF, QRectF, Qt)
from PyQt5.QtGui import (QBrush, QColor, QPainter)
from PyQt5.QtWidgets import (QApplication, QGraphicsView, QGraphicsScene, QGraphicsItem,
                             QGridLayout, QVBoxLayout, QHBoxLayout,
                             QLabel, QLineEdit, QPushButton)

# 繼承 QGraphicsItem 類別, 建立 TicTacToe 類別
class TicTacToe(QGraphicsItem):
    # 定義建構子
    def __init__(self):
        # 先執行父物件的建構子方法
        super().__init__()
        # 定義 board instance 屬性
        self.board = [[-1, -1, -1],[-1, -1, -1], [-1, -1, -1]]
        # 定義 O 與 X 與 turn 物件案例屬性
        self.O = 0
        self.X = 1
        self.turn = self.O

    # 定義重置方法
    def reset(self):
        # 以 y=0, 1, 2 重複執行迴圈
        for y in range(3):
            # 以 x=0, 1, 2 重複執行迴圈
            for x in range(3):
                # board 案例數列全設為 -1
                self.board[y][x] = -1
        # turn 設為 O
        self.turn = self.O
        # 執行 update 案例方法
        self.update()

    # 定義 select
    def select(self, x, y):
        # 不在範圍中的 x 與 y 直接 return
        if x &lt; 0 or y &lt; 0 or x &gt;= 3 or y &gt;= 3:
            return
        # 當板中特定位置為 -1, 表示該位置尚未 paint, 則一開始 turn 為 O, 也就是 0
        # 接著 turn 成為 1-0  轉為 1
        if self.board[y][x] == -1:
            self.board[y][x] = self.turn
            self.turn = 1 - self.turn

    def paint(self, painter, option, widget):
        painter.setPen(Qt.black)
        painter.drawLine(0,100,300,100)
        painter.drawLine(0,200,300,200)
        painter.drawLine(100,0,100,300)
        painter.drawLine(200,0,200,300)

        for y in range(3):
            for x in range(3):
                if self.board[y][x] == self.O:
                    painter.setPen(Qt.red)
                    painter.drawEllipse(QPointF(50+x*100, 50+y*100), 30, 30)
                elif self.board[y][x] == self.X:
                    painter.setPen(Qt.blue)
                    painter.drawLine(20+x*100, 20+y*100, 80+x*100, 80+y*100)
                    painter.drawLine(20+x*100, 80+y*100, 80+x*100, 20+y*100)

    def boundingRect(self):
        return QRectF(0,0,300,300)

    # 滑鼠點按事件
    def mousePressEvent(self, event):
        pos = event.pos()
        self.select(int(pos.x()/100), int(pos.y()/100))
        self.update()
        super(TicTacToe, self).mousePressEvent(event)

# 以 QGraphicsView 作為視窗
class MainWindow(QGraphicsView):
    def __init__(self):
        super().__init__()
        # 場景
        scene = QGraphicsScene(self)
        self.tic_tac_toe = TicTacToe()
        # 在場景中加入 TicTacToe() 的案例物件
        scene.addItem(self.tic_tac_toe)
        scene.setSceneRect(0, 0, 300, 300)
        # 在視窗中 setScene
        self.setScene(scene)
        # 設定 CacheMode
        self.setCacheMode(QGraphicsView.CacheBackground)
        self.setWindowTitle("Tic Tac Toe")

    def keyPressEvent(self, event):
        key = event.key()
        # 若按下 R 鍵, 則執行 reset 方法
        if key == Qt.Key_R:
            self.tic_tac_toe.reset()
        # 執行 MainWindow 中的 keyPressEvent
        super(MainWindow, self).keyPressEvent(event)

if __name__ == '__main__':
    import sys
    app = QApplication(sys.argv)
    mainWindow = MainWindow()

    mainWindow.show()
    sys.exit(app.exec())</pre>
<p>納入 matplotlib 動畫 (<a href="https://github.com/mmisono/pyqt5-example/blob/master/plot.py">來源</a>)</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#!/usr/bin/env python

import random
import numpy as np
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

from PyQt5.QtCore import (QLineF, QPointF, QRectF, Qt, QTimer)
from PyQt5.QtGui import (QBrush, QColor, QPainter)
from PyQt5.QtWidgets import (QApplication, QGraphicsView, QGraphicsScene, QGraphicsItem,
                             QGridLayout, QVBoxLayout, QHBoxLayout, QSizePolicy,
                             QLabel, QLineEdit, QPushButton)

# FigureCanvas inherits QWidget
class MainWindow(FigureCanvas):
    def __init__(self, parent=None, width=4, height=3, dpi=100):
        fig = Figure(figsize=(width, height), dpi=dpi)
        self.axes = fig.add_subplot(111)
        self.axes.hold(False)

        super(MainWindow, self).__init__(fig)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(self,
                                   QSizePolicy.Expanding,
                                   QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

        timer = QTimer(self)
        timer.timeout.connect(self.update_figure)
        timer.start(50)

        self.x  = np.arange(0, 4*np.pi, 0.1)
        self.y  = np.sin(self.x)

        self.setWindowTitle("Sin Curve")

    def update_figure(self):
        self.axes.plot(self.x, self.y)
        self.y = np.roll(self.y,-1)
        self.draw()

if __name__ == '__main__':
    import sys
    app = QApplication(sys.argv)
    mainWindow = MainWindow()

    mainWindow.show()
    sys.exit(app.exec())</pre>
<p>表單 Factorial (<a href="https://github.com/mmisono/pyqt5-example/blob/master/factorial.py">來源</a>)</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#!/usr/bin/env python

from PyQt5.QtWidgets import (QApplication, QWidget,
                             QGridLayout, QVBoxLayout, QHBoxLayout,
                             QLabel, QLineEdit, QPushButton)

def factorial(n):
    if n &lt; 0:
        return -1
    elif n == 0:
        return 1
    else:
        return n * factorial(n-1)

class MainWindow(QWidget):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        self.inputLine = QLineEdit()
        self.outputLine = QLineEdit()
        self.outputLine.setReadOnly(True)

        self.calcButton = QPushButton("&amp;Calc")
        self.calcButton.clicked.connect(self.calc)

        lineLayout = QGridLayout()
        lineLayout.addWidget(QLabel("num"), 0, 0)
        lineLayout.addWidget(self.inputLine, 0, 1)
        lineLayout.addWidget(QLabel("result"), 1, 0)
        lineLayout.addWidget(self.outputLine, 1, 1)

        buttonLayout = QVBoxLayout()
        buttonLayout.addWidget(self.calcButton)

        mainLayout = QHBoxLayout()
        mainLayout.addLayout(lineLayout)
        mainLayout.addLayout(buttonLayout)

        self.setLayout(mainLayout)
        self.setWindowTitle("Factorial")

    def calc(self):
        n = int(self.inputLine.text())
        r = factorial(n)
        self.outputLine.setText(str(r))

if __name__ == '__main__':
    import sys
    app = QApplication(sys.argv)
    main_window = MainWindow()

    main_window.show()
    sys.exit(app.exec())</pre>
<p>使用 QGraphicsView 與 QWidget (<a href="https://github.com/mmisono/pyqt5-example/blob/master/cellular_automaton.py">來源</a>)</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#!/usr/bin/env python

import random

from PyQt5.QtCore import (QLineF, QPointF, QRectF, Qt, QTimer)
from PyQt5.QtGui import (QBrush, QColor, QPainter, QIntValidator)
from PyQt5.QtWidgets import (QApplication, QWidget, QGraphicsView, QGraphicsScene, QGraphicsItem,
                             QGridLayout, QVBoxLayout, QHBoxLayout,
                             QLabel, QLineEdit, QPushButton)

class CelllarAutomaton(QGraphicsItem):
    def __init__(self, width=500, height=500, size=5):
        super(CelllarAutomaton, self).__init__()
        self.width = width
        self.height = height
        self.size = size
        self.NH = self.height//size
        self.NW = self.width//size
        self.board = []
        for y in range(self.NH):
            self.board.append([0] * self.NW)
        self.board[0][self.NW//2] = 1
        self.pos = 0

    def reset(self):
        for y in range(self.NH):
            for x in range(self.NW):
                self.board[y][x] = 0
        self.board[0][self.NW//2] = 1
        self.pos = 0
        self.update()

    def randomInit(self):
        for y in range(self.NH):
            for x in range(self.NW):
                self.board[y][x] = 0
        for x in range(self.NW):
            self.board[0][x] = int(random.random() &lt; 0.2)
        self.pos = 0
        self.update()

    def paint(self, painter, option, widget):
        painter.setPen(QColor(220,220,220))
        for y in range(self.NH):
            painter.drawLine(0, y*self.size, self.width, y*self.size)
        for x in range(self.NW):
            painter.drawLine(x*self.size, 0, x*self.size, self.height)

        painter.setBrush(Qt.black)
        for y in range(self.NH):
            for x in range(self.NW):
                if self.board[y][x] == 1:
                    painter.drawRect(self.size*x, self.size*y, self.size, self.size)

    def do_prev(self):
        if self.pos == 0:
            return
        for x in range(self.NW):
            self.board[self.pos][x] = 0
        self.pos -= 1
        self.update()

    def do_next(self, n):
        if self.pos+1 &gt;= self.NH:
            return False
        p = []
        for i in range(8):
            p.append(n &amp; 0b1) 
            n &gt;&gt;= 1

        self.board[self.pos+1][0] = p[(self.board[self.pos][0]&lt;&lt;1) + self.board[self.pos][1]]
        self.board[self.pos+1][self.NW-1] = p[(self.board[self.pos][self.NW-2]&lt;&lt;1) + self.board[self.pos][self.NW-1]]
        for x in range(1,self.NW-1):
            self.board[self.pos+1][x] = p[(self.board[self.pos][x-1]&lt;&lt;2)
                                            + (self.board[self.pos][x]&lt;&lt;1)
                                            + (self.board[self.pos][x+1])]
        self.pos += 1
        self.update()
        return True

    def boundingRect(self):
        return QRectF(0,0,self.width,self.height)

class MainWindow(QWidget):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        self.graphicsView = QGraphicsView()
        scene = QGraphicsScene(self.graphicsView)
        scene.setSceneRect(0, 0, 400, 400)
        self.graphicsView.setScene(scene)
        self.celluarAutomaton = CelllarAutomaton(400,400)
        scene.addItem(self.celluarAutomaton)

        validator = QIntValidator(0,1)
        ruleLayout = QGridLayout()
        ruleLayout.setAlignment(Qt.AlignTop)
        self.ruleEdits = []
        for i in range(7,-1,-1):
            ruleEdit = QLineEdit()
            ruleEdit.setValidator(validator)
            ruleEdit.setText("0")
            ruleEdit.setFixedWidth(30)
            ruleEdit.textEdited.connect(self.update_rule)
            ruleLayout.addWidget(QLabel("{0:03b}".format(i)), 0, 7-i)
            ruleLayout.addWidget(ruleEdit, 1,7-i)
            self.ruleEdits.append(ruleEdit)

        validator2 = QIntValidator(0,255)
        self.rule10Edit = QLineEdit()
        self.rule10Edit.setValidator(validator2)
        self.rule10Edit.textEdited.connect(self.update_rule10)
        rule10Layout = QHBoxLayout()
        rule10Layout.addWidget(QLabel("Rule"))
        rule10Layout.addWidget(self.rule10Edit)

        self.resetButton = QPushButton("&amp;Reset")
        self.resetButton.clicked.connect(self.reset)
        self.randomInitButton = QPushButton("&amp;Random init")
        self.randomInitButton.clicked.connect(self.randomInit)
        self.nextButton = QPushButton("&amp;Next")
        self.nextButton.clicked.connect(self.do_next)
        self.prevButton = QPushButton("&amp;Prev")
        self.prevButton.clicked.connect(self.do_prev)
        self.autoButton = QPushButton("&amp;Auto")
        self.autoButton.clicked.connect(self.auto)
        self.stopButton = QPushButton("&amp;Stop")
        self.stopButton.clicked.connect(self.stop)
        buttonLayout = QVBoxLayout()
        buttonLayout.addWidget(self.resetButton)
        buttonLayout.addWidget(self.randomInitButton)
        buttonLayout.addWidget(self.nextButton)
        buttonLayout.addWidget(self.prevButton)
        buttonLayout.addWidget(self.autoButton)
        buttonLayout.addWidget(self.stopButton)

        propertyLayout = QVBoxLayout()
        propertyLayout.setAlignment(Qt.AlignTop)
        propertyLayout.addLayout(ruleLayout)
        propertyLayout.addLayout(rule10Layout)
        propertyLayout.addLayout(buttonLayout)

        mainLayout = QHBoxLayout()
        mainLayout.setAlignment(Qt.AlignTop)
        mainLayout.addWidget(self.graphicsView)
        mainLayout.addLayout(propertyLayout)

        self.setLayout(mainLayout)
        self.setWindowTitle("Cellular Automaton")
        self.updating_rule = False
        self.rule10Edit.setText("90")
        self.update_rule10()
        self.timer = None

    def update_rule(self):
        if self.updating_rule: return
        rule = 0
        for i in range(8):
            n = self.ruleEdits[i].text()
            if n == "": return
            rule = (rule &lt;&lt; 1) + int(n)
        self.updating_rule = True
        self.rule10Edit.setText(str(rule))
        self.updating_rule = False

    def update_rule10(self):
        n = self.rule10Edit.text()
        if n == "": return
        rule = int(n)
        self.updating_rule = True
        for i in range(7,-1,-1):
            self.ruleEdits[i].setText(str(rule &amp; 0b1))
            rule &gt;&gt;= 1
        self.updating_rule = False

    def do_next(self):
        n = self.rule10Edit.text()
        return self.celluarAutomaton.do_next(int(n))

    def do_prev(self):
        self.celluarAutomaton.do_prev()

    def reset(self):
        self.celluarAutomaton.reset()

    def randomInit(self):
        self.celluarAutomaton.randomInit()

    def auto(self):
        self.timer = QTimer()
        self.timer.setInterval(100)
        self.timer.timeout.connect(self.timeout)
        self.timer.start()

    def timeout(self):
        r = self.do_next()
        if not r:
            self.stop()

    def stop(self):
        if self.timer:
            self.timer.stop()
            self.timer = None

    #def keyPressEvent(self, event):
    #    key = event.key()
    #    super(MainWindow, self).keyPressEvent(event)

if __name__ == '__main__':
    import sys
    app = QApplication(sys.argv)
    mainWindow = MainWindow()

    mainWindow.show()
    sys.exit(app.exec())</pre>
<p>使用 Eric6 開發 PyQt5 GUI 程式:</p>
<p>參考流程: <a href="http://www.science.smith.edu/dftwiki/index.php/PyQt5_Tutorial:_A_Window_Application_with_File_IO">http://www.science.smith.edu/dftwiki/index.php/PyQt5_Tutorial:_A_Window_Application_with_File_IO</a> </p>
<p><a href="./../downloads/qt_designer_tutorial.pdf">Qt Designer 教學.pdf</a></p>
<br />Moveblocks << <a href='Moveblocks.html'>Previous</a> <a href='STetris.html'>Next</a> >> STetris</section></div></body></html>
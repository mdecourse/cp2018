var tipuesearch = {"pages": [{'title': '簡介', 'text': '以 Python 與 PyQt5 為主 \n 這裡是國立虎尾科技大學機械設計工程系計算機程式課程教材, 主要從 Python 程式語言的學習切入, 並教導如何利用\xa0 PyQt5  圖形介面程式庫建立視窗程式, 由於目前的機械設計相關產品, 除了機構元件設計外, 還牽涉部分電子電機與資訊元件的網際協同整合, 因此本系列課程 ( 計算機程式 、網際內容管理、 電腦輔助設計實習 、協同產品設計實習) 在視窗程式中還加入可執行遠端伺服器運算之模組. \n 納入網際伺服運算模組 \n 由於部分機械設計工程分析運算流程, 需要較長運算時間, 因此除了近端單機視窗程式開發外, 本課程採  Flask  網際框架, 並輔以  Brython  與  Fengari-web  等網際 Python 與 Lua 程式語法. 建立所需的機械設計運算叢集伺服器, 使用者可以從近端電腦中, 以批次上傳方式, 將運算要求送至遠端伺服器, 待階段運算任務完成後, 以電子郵件通知使用者檢視結果. \n 引用機電整合模擬與 3D 零組件列印 \n 機械設計工程系的電腦軟體應用, 在培育具有編寫近端單機  PyQt5  程式套件能力, 並且利用多執行緒啟動網際伺服功能, 讓其他參與協同產品設計者, 能夠利用單機視窗程式客戶端或瀏覽器, 與遠端伺服器互換資料, 並且由近端或遠端套件中的模組, 送出致動指令, 驅動  V-rep  上的各種機電整合系統模型. 一旦相關機電資產品的動態控制與模擬完成後, 再藉由各式 3D 列印機製作組合出系統原型. \n 結合 C/C++ 提升運算速度 \n 計算機程式課程以 Python 程式語言導入的目的, 在於能讓初學者快速建立用於電腦輔助機械設計流程相關的程式, 而當 Python 程式需要與 C/C++ 程式庫結合時, 則建議利用  SWIG  ( ref.pdf ) 將現成 C/C++ 程式編寫為能讓 Python 直接呼叫執行的動態連結庫. \n 註: 目前能自動編譯 C++ 程式為 Python 可呼叫的動態程式庫技術為: \n AutoWIG - automatic generation of python bindings for Cpp libraries.pdf \n 學習用於 V-rep 的 Lua \n 本課程提及 Lua 程式語言的原因, 在於隨後課程所使用的  V-rep  嵌入程式採用  Lua  程式與 C++ 結合, 因使用  Fengari-web , 使用者可以直接在 網際 Lua 平台 練習基本程式語法. \n 至於以 Python 語言編寫的某些數值分析程式, 為了提高執行效率, 也提及可以使用  Cython  將這些 Python 程式庫轉為 C 之後, 再編譯為能與主 Python 程式結合的動態連結庫. \n 機電資協同整合設計目標 \n 機械設計工程系的電腦輔助機械設計相關課程, 除了本 計算機程式 外, 還包含網際內容管理,  電腦輔助設計實習 與協同產品設計實習, 希望能夠在課程結束後, 各學員能以團隊整合的模式開發電腦程式, 有效解決電腦輔助機械設計相關問題. \n 課程倉儲:  https://github.com/mdecourse/cp2018 \n 課程目標: \n 本計算機程式課程在導引如何利用電腦輔助方法進行機械設計, 開發有實用價值的程式. \n 需要自學技術: \n \n 電腦英文輸入 \n 電腦中文輸入: 注音輸入,  漢語拼音 \n Windows 10 基本操作:  win10_manual.pdf \n 命令列基本指令操作 \n 個人電腦硬體基本認識  :  computer fundamental tutorial.pdf \n Fundamentals of ICT.pdf \n \n 程式語言: \n \n C/C++: 含 Qt5 圖形介面程式開發 \n Python: 含 PyQt5 圖形介面程式開發 \n Lua: 以能與 C/C++ 結合, 並在  V-rep  環境中使用為目標. \n Javascript: 含  Brython  與  Fengari-web  網際環境導入. \n \n 學習計算機程式訣竅 \n 要堅持不懈 \n 計算機程式是學習如何與電腦溝通, 如同英文或其他外國語言的學習, 是一輩子的任務, 只有開始, 沒有結束. \n 要養成每天都寫程式碼的習慣, 每一個學習或編寫程式碼的時段不用太久, 半小時或 45 分鐘都不算短, 碰到瓶頸, 可以起身走動, 隨思意想, 養足精神後, 再繼續工作. \n 儘早選定主題 \n 電腦程式已經從輔助角色, 逐步發展成能夠獨立自主運作的人工智慧, 用來解決各領域問題的範圍包羅萬象, 計算機程式學習者, 必須儘早選定主題, 集中火力, 在每一個學習階段, 都能透過計算機程式能力, 擴增自我競爭力與協同能力. \n 參與協同設計 \n 正因為電腦軟硬體能夠勝任的工作越來越多, 各種工具套件與模組的更新速度越來越快, 儘早選定主題之後, 在計算機學習進展過程中, 必得設法參與全球化的協同設計生態系, 貢獻自我價值, 將自己已經理解且熟練的內容, 拍成教學影片, 寫進網誌, 配置成網際簡報, 設法教會周遭與網路上的潛在協同者, 不斷推升個人與團隊的競爭力.', 'tags': '', 'url': '簡介.html'}, {'title': '課程規劃', 'text': '課程目標: \n 為了讓機械設計工程師了解, 該如何利用電腦與網路進行機械設計. 總共安排了四門課程: \n 計算機程式 - 內容分為 C, Python, Lua, Html5, CSS, Javascript 等,  利用可攜系統, Git, Fossil SCM, Windows 10 電腦, Ubuntu 電腦與網路的技術, 進行各種問題的解決. \n 最佳化設計問題:  https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html   \n 網際內容管理 - 在 Windows 10 與 Ubuntu 電腦, 建立  CMSimfly  與  Pygrouf  環境. \n 電腦輔助設計實習 - 加入電腦輔助機械設計零組件繪製與機器人模擬與製作技術研習. \n 協同產品設計實習 - 全面利用近端與雲端資源的整合, 進行機電資系統開發. \n 2018 Fall 計算機程式課程規劃心智圖  (under scrum1 At mde) \n 計算機程式課程: \n \n 所有教材都以數位形式存在, 包括 網站 與教學影片 ( Youtube  與  Vimeo ). \n 要求學員編寫紙本筆記: 訓練手到學習, 目的是希望學員上課寫紙本筆記時, 手可以暫時離開手機:-) \n 採用版次管理系統: 能夠保存各階段的版本, 完成呈現事件的歷程資料, 採用  Github  與  Fossil SCM . \n 透過網路協同: 多人可同步或非同步執行專案, 突破時間與空間的限制. (採用  Github  倉儲) \n 實作前模擬: 將機械與電子電機相關整合系統, 以資訊科技模擬呈現. \n 人工智慧應用: 車牌辨識、專家系統與創新設計, 計算機程式經歷輔助式 (Assistant)、導引式 (Guidance) 的發展, 已經逐步進入自主式 (Autonomous) 創新世代. \n \n 課程採用可攜程式系統, 使用者可以下載一般版  p37.7z  (240MB  解開後約 1GB) , 或較 完整的進階版  Qt 可攜系統 .7z  (8GB, 解開後約 21GB). \n 學習 Python 與  PyQt5  用於視窗程式開發: \n 利用 Python 與  PyQt5  可開發 Windows 10 環境執行的視窗程式, 利用 Python 與  Flask  結合  Brython  開發網際程式. \n 學習 C 用於  Tinkercad   Arduino  控制卡模擬: \n 學習  Lua  用於  V-rep  機器人模擬: \n 學習 Javascript 與   Brython  與  Fengari-web  用於網頁動態模擬: \n', 'tags': '', 'url': '課程規劃.html'}, {'title': '機械設計', 'text': '機械設計與表達 \n 從工程(細密規劃, 專精巧飾, 運用科學原理達創造目的之特定流程)的角度而言, 設計是一種明確與具體的表達, 而且是在仔細思考、多方考量後所完成的表達, 表達具有六種形式, 包括口語、文字、2D、3D、數學與實體表達, 設計的結果可以讓執行者有所依循, 根據指示執行後, 可得預期之結果. \n 機械是一種器物, 而且是由固體、流體與軟體元件精巧組合而成, 可互動運作, 達成特定功能之器物. \n 因此機械設計就是靈活運用六種表達, 明確說明如何透過固體、流體與軟體元件之互動運作, 而能達成預定結果之明確與具體表達. \n 參與機械設計的工程師, 為順利完成任務, 解決產品開發過程所面臨的各項問題, 展現創造力的三種必備能力: 自學能力、執行能力與想像能力. \n 由於機械設計流程牽涉許多固體、流體與軟體元件配置, 而且當多名成員在協同設計過程中, 會於不同時間納入各種機械設計組成及六種表達內容, 因此必須要設法運用組態管理 (Configuration Management) 系統, 呈現各時間點詳細的組成內容與狀態. \n 參考資料: \n https://github.com/m2n037/awesome-mecheng   \n https://www.scipy-lectures.org/intro/intro.html   \n https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html   \n http://open.umn.edu/opentextbooks/   \n 身體力行 \n 開課教師如何使用計算機程式相關技術? \n \n 利用 Python 建立  CMSimfly , 將課程內容部署在  Github   倉儲 \n 使用  Leo Editor  IDE 管理與課程相關的所有資料 \n 指導學生利用 Python 建立  Pyslvs , 用於平面機構設計與分析模擬 \n 利用批次檔案建立 USB 可攜程式套件,  p37.7z  (240MB, 解開 1GB),  Qt  (8GB, 解開 21 GB). \n 利用 Python 建立  PyGrouf , 用於多人協同機械設計 \n \n 獲得那些效益? \n \n CMSimfly  結合  reveal.js  與  Pelican , 可以將課程內容、網際簡報與網誌部署於 Github 倉儲 \n 多元資料可以透過  Leo Editor , 獲得有效管理 \n 利用演化運算解決機械設計最佳化問題, 可做為導入 AI 機械設計教育的入門教材 \n 自行利用 Python 模組與  MSYS2  打造自由開放, 且能全面客製化的程式開發工具 \n 導入  oauth2  登入技術, 朝自行開發協同機械設計工具邁進 \n \n 業界能否受用? \n Numerical Python - A Practical Techniques Approach for Industry \n 學員如何延續上述實習內容? \n 議題 \n 可資議論之主題 \n 計算機程式在解決甚麼問題? \n \n 工具易用及易維護性議題 \n 協同資料擷取便性議題 \n 資料版本及歷程長期保存議題 \n 如何尋求可持續改進的電腦輔助設計與工程分析架構與協同機制 \n', 'tags': '', 'url': '機械設計.html'}, {'title': 'ANSI C', 'text': 'Hello ANSIC: \n #include <stdio.h>\n\nint main()\n{\n    printf("Hello, ANSI C!\\n");\n\n    return 0;\n} \n 存為 hello.c \n 然後啟動 Qt 隨身程式系統 ( http://wcmg3.kmol.info./../downloads/Qt_20180714.7z  (或  Qt 下載 , 解開後容量為 20GB)), 可以擷取到  MSYS2  64 位元的  gcc  編譯器, 以隨身系統啟動的命令列執行: \n gcc -o hello hello.c \n 進行編譯後, 可以得到 hello.exe, 執行 hello.exe 後, 可以列印出 Hello ANSI C! \n 上述程式碼也可以直接複製到 SCiTE中, 存為 hello.c 後, 以 Tools->Go 執行. \n 也可以直接在  https://www.onlinegdb.com/online_c_compiler  中執行. \n 接下來利用  http://learn.onlinegdb.com/learn_c_programming  與  codingunit  學習 C 程式語言. \n 函式定義與呼叫: \n #include<stdio.h>\n\nint sum(x, y, z){\n    return x+y+z;\n}\n\nmain()\n{\n    int i;\n    int x;\n    int y = 1;\n    x = 1;\n    y = sum(x, 2, 3);\n    // formated print\n    printf("%d\\n", y);\n    \n    // for loop\n    for (i=0; i<10; i++){\n        printf("Hello World\\n");\n    }\n} \n 格式化列印: \n #include<stdio.h>\n\nmain()\n{\n    int a,b;\n    float c,d;\n\n    a = 15;\n    b = a / 2;\n    printf("%d\\n",b);\n    printf("%3d\\n",b);\n    printf("%03d\\n",b);\n\n    c = 15.3;\n    d = c / 3;\n    printf("%3.2f\\n",d);\n} \n 格式化列印 2: \n #include<stdio.h>\n\nmain()\n{\n\tprintf("The color: %s\\n", "blue");\n\tprintf("First number: %d\\n", 12345);\n\tprintf("Second number: %04d\\n", 25);\n\tprintf("Third number: %i\\n", 1234);\n\tprintf("Float number: %3.2f\\n", 3.14159);\n\tprintf("Hexadecimal: %x\\n", 255);\n\tprintf("Octal: %o\\n", 255);\n\tprintf("Unsigned value: %u\\n", 150);\n\tprintf("Just print the percentage sign %%\\n", 10);\n} \n 華氏溫度與攝式溫度轉換: \n #include<stdio.h>\n\nmain()\n{\n\tint Fahrenheit;\n\n\tfor (Fahrenheit = 0; Fahrenheit <= 300; Fahrenheit = Fahrenheit + 20)\n\t\tprintf("%3d %06.3f\\n", Fahrenheit, (5.0/9.0)*(Fahrenheit-32));\n} \n 參考資料: \n Programming for Engineers: A Foundational Approach to Learning C and Matlab ( https://link.springer.com/book/10.1007/978-3-642-23303-6 ) \n https://dspace.lboro.ac.uk/dspace-jspui/bitstream/2134/10054/6/Programming-in-ANSI-C.pdf   \n https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm   \n http://web.stanford.edu/dept/cs_edu/qt-creator/qt-creator-windows.shtml   \n http://web.stanford.edu/class/archive/cs/cs106b/cs106b.1182/lectures/   \n https://www.codestepbystep.com/about   \n https://google.github.io/styleguide/cppguide.html   \n https://www.programiz.com/c-programming   \n', 'tags': '', 'url': 'ANSI C.html'}, {'title': '指標教材', 'text': '指標:  C 程式語言的指標與陣列 \n 指標教材.pdf  (英文) \n 若您想要專精於利用 C 程式語言編寫程式碼, 就必須徹底了解如何使用指標. 然而, C 指標對初學者而言, 經常是一項障礙, 尤其對於從其他程式語言轉進的學習者. \n 這份資料旨在幫助初學者了解指標. 為了能讓這份資料發揮最大功能, 使用者最好能夠實際執行文章中所列出的各個程式. 因此所有的程式碼都採 ANSI 標準, 以便讓任何符合 ANSI 標準的編譯器都能執行這些程式碼. 內文與程式碼之間, 也特別加以區分開來, 以便使用者可以直接利用複製的方式, 取的各段落的程式碼, 套用到其他系統中進行編譯. 如此才能確實了解這裡所提供的資料. \n', 'tags': '', 'url': '指標教材.html'}, {'title': 'ch1何謂指標', 'text': 'C 語言初學者必須面對的難題之一, 就是指標 (pointer) 的用法. \n 這份教材的目的, 就是針對初學者簡介指標及其應用. \n 其實初學者會對指標產生疑惑, 大多源自於在學習 C 語言時, 對於變數的概念經常一知半解. \n 因此這裡就由 C 變數的一般用法說起. \n 程式中的變數都必須加以命名, 以便存放資料. \n 而編譯器與連結器在處理變數時, 就會挪出電腦記憶體中的特定區域, 以存放變數的資料. \n 這些特定區域的大小, 取決於變數允許存放資料的範圍. \n 例如, 在 32 位元電腦, 一個整數變數的存放範圍, 需要 4 位元. 而在舊的 16 位元電腦, 整數存放需要 2 位元. \n C 程式中的整數變數存放範圍大小, 在各種機器上不一定相同. \n 並且 C 程式中的整數變數也不只一種, 在許多 C 程式教科數中,可以發現有整數, 長整數, 短整數等. 這裡則假設使用 32 位元系統, 因此整數需要 4 位元的存放空間. \n 可以採用下列程式碼,在您所使用的系統中, 查探特定整數型別所需要的記憶體空間: \n #include <stdio.h>\n \nint main()\n{\nprintf("size of a short is %d\\n", sizeof(short));\nprintf("size of a int is %d\\n", sizeof(int));\nprintf("size of a long is %d\\n", sizeof(long));\n} \n 在 codepad.org 執行上述 C 程式 \n 當我們宣告一個變數時, 亦即告知編譯器兩件事, 變數名稱與變數型別. 例如, 可以透過: \n int k; \n 宣告名稱為 k 的整數型別變數. 當編譯器看到 "int" 的敘述時, 就會在電腦的記憶體中, 保留 4 位元的空間, 以便存放整數變數 k 的數值. \n 此外, 電腦也會設置一個符號表, 註明符號 k 與其在記憶體中用來存放 4 位元資料的相對位址. \n 因此, 若在變數宣告後, 使用: \n k = 2; \n 2 這個數值, 就會在程式執行時, 被放在保留給 k 變數的記憶體位址中. \n 在 C 語言中, 整數 k 變數, 可視為一個物件. 其中有兩個值與物件 k 有關, 也就是存放的數值與存放的位址. 有些參考書中將者兩個數值稱為"右值"與"左值". (2 為右值, 而變數位址為左值) \n 在某些語言中, 左值只能放在指定"等號"的左邊, 而右值則只能放在右邊. 位置放錯, 例如:  \n 2 = k; \n 就會出錯. \n 其實, C 語言中有關左值的定義, 根據 K&R II (page 197): [1], 則有些變動. \n "物件為儲存區域的名稱, 而左值則為指向該物件的表示式." \n 這裡先採引用的定義加以說明, 後續將會進一步針對指標加以說明. \n 接著, 假如程式碼為: \n int j, k;\nk = 2; \nj = 7;    <-- line 1 \nk = j;    <-- line 2 \n 編譯器會將第一行 (line 1) 的 j 解讀為變數 j 的位址 (也就是左值), 並且將值 7 放到該位址. 在第二行 (line 2), 則會將 j 視為右值 (因為在"指定"運算子的右方), 指的則是存放在 j 記憶體中的 7 這個數值. 因此第二行執行過後, 存放在 j 的 7 這個數值, 就會被放到 k 變數所對應的"左值" (記憶體位址) 中. \n 在這些範例中, 採用的都是將右值從一個儲存位址, 經由複製將 4 位元的資料複製到另外一個儲存位址. 假如使用 2 位元整數, 則會複製 2 位元資料. \n 這裡, 就會需要一種變數, 用來存放左值 (記憶體位址). 存放此一變數的值, 隨系統而異, 舊的桌上電腦總共只有 64K 的記憶體, 每存放一個整數位址會佔去 2 位元. \n 更多位元數的電腦 (例如 64 位元電腦), 則需要更多的位元位址來存放一個整數資料. \n 實際需要的記憶體大小並不重要, 需要的則是一種方法, 通知編譯器在哪一位址存放哪些資料. \n 這樣的變數稱為"指標變數" (隨後將說明得更清楚). 在 C 語言中定義指標變數時, 必須在變數名稱前方, 加上一個 * 符號. 而這些指標變數的型別, 隨著要存放在指標位址中的資料型別而定, 例如, 假如宣告: \n int *ptr; \n ptr 為變數名稱 (與之前的整數變數名稱 k 相同). 而 "*" 符號則告知編譯器, 此一宣告為指標變數, 亦即保留出足夠的記憶體存放位址. 最前方的 int 則表示, 希望此一指標變數用來存放整數. 而此一指標稱為"指向整數". 需要特別注意的是, 當使用 int k; 時並沒有給 k 初始值, 只有在任何符合 ANSI 規範的編譯器中, 會將宣告在函式外的變數通通以 0 初始. \n 同樣地, ptr 也沒有初始值, 亦即, 還沒有在上述宣告之後, 在保留的位址空間上, 放入任何值. 這裡若宣告是在任何函式之外, 就會被賦予初值, 並且保證不會指向任何 C 物件或函式. 以這種方式初始的指標, 被稱為 "空"指標 (null pointer). \n 而空指標並不一定會被放入 "0" 值, 因為這取決於特定系統中的設定. 為了在不同系統中的不同編譯器彼此相容, 就會利用巨集 (macro) 來表示空指標. 此巨集以 NULL 命名. 因此, 若以 NULL 設定指標值, 則可以確定在不同機器上, 這些指標變數一定是空指標. \n 與整數是否為 0 的判斷式 if(k ==0) 相類似, 可以利用 if(ptr == NULL) 判斷是否 ptr 為空指標. \n 但是, 回到新變數 ptr 的應用, 假設要將整數變數 k 所對應的位址, 存入 ptr, 就必須使用"位址運算子", 寫成: \n ptr = &k; \n "位址運算子"的作用是用來取 k 的左值 (位址), 即使這時 k 位於等號右邊, 上述程式會將 k 的值複製到指標 ptr 的儲存空間中. 這時, ptr 稱為"指向" k. \n 接著再討論另外一個運算子. \n 也就是所謂的"取值運算子" (dereferencing operator), 就是一個 * 符號. 使用方法如下: \n *ptr = 7; \n 這一行程式會將 7 這個數值,複製到 ptr 變數所指向的位址. 也就是說, 假如 ptr 指向 k (ptr 為 k 存放資料的記憶體位址), 這行程式就會將 k 的值設為 7. 換言之, * 運算子可用來改變 ptr 所指向的值, 而不是指標本身的值. (註:指標本身為位址, 也就是所謂的左變數) \n 因此, 可以利用: \n printf("%d\\n",*ptr); \n 將目前存放在 ptr 所指向位址的整數值, 透過 printf() 函式印到螢幕. \n 要釐清上述說明, 可以執行下列程式, 並仔細探討程式碼與其輸出. \n ------------ Program 1.1 --------------------------------- \n /* Program 1.1 from PTRTUT10.TXT   6/10/97 */\n \n#include <stdio.h>\n \nint j, k;\nint *ptr;\n \nint main(void)\n{\n    j = 1;\n    k = 2;\n    ptr = &k;\n    printf("\\n");\n    printf("j has the value %d and is stored at %p\\n", j, (void *)&j);\n    printf("k has the value %d and is stored at %p\\n", k, (void *)&k);\n    printf("ptr has the value %p and is stored at %p\\n", ptr, (void *)&ptr);\n    printf("The value of the integer pointed to by ptr is %d\\n", *ptr);\n \n    return 0;\n} \n 在 codepad.org 執行 Program 1.1 \n 請注意: 我們還沒有談到 C 程式中的 (void *) 表示式. 這裡可以先納入您的測試程式碼中, 隨後將會加以說明. \n 結論: \n \n 變數宣告必須指定名稱與型別 .   ( 例如 :   int   k ;) \n 指標變數宣告也是指定名稱與型別 .   ( 例如 :   int   * ptr ;),   其中的   *   告知編譯器 ,   該名稱為   ptr   的變數 ,   為一個指標變數 ,   而其型別為該指標指向的資料型別   ( 這裡為整數 ). \n 一旦變數已經宣告 ,   可以透過變數前方的位址運算子 ,   取得其位址 ,   例如   & k . \n 可以由指標中 "取值" ,   亦即 ,   以   *   指定到指標所參照的值 ,   例如 :   * ptr . \n 變數的左值為被用來存放在記憶體中的位址值 ,   而變數的右值則式被存放在該位址的數值 . \n \n 參考資料: \n "The C Programming Language" 2nd Edition B. Kernighan and D. Ritchie Prentice Hall ISBN 0-13-110362-8 \n', 'tags': '', 'url': 'ch1何謂指標.html'}, {'title': 'ch2指標型別與陣列', 'text': '接著讓我們來看看, 為何需要指定指標指向變數的型別, 例如: int *ptr; 原因之一是, 宣告之後, 可以透過指向, 寫成: \n *ptr = 2; \n 編譯器就會知道要配置多少記憶體給 ptr 變數, 假如 ptr 宣告為指向整數, 電腦就會複製 4 位元的資料, 其它的浮點與雙浮點變數也是相同. 定義指向變數型別的另外一個用途就是編譯器可以解譯程式碼. 例如, 記憶區中存放 10 個連續的整數資料時, 需要 40 位元的記憶體. \n 假如整數指標 ptr 為這些整數中的第一個變數, 若該整數位於記憶體位址 100. 當程式寫為: \n ptr + 1; \n 因為編譯器知道 ptr 為一個指標變數 (亦即, 其值為一組位址)並且指向某一整數 (目前位址為 100, 即是該整數所在位址), 當 ptr 加上 4 而不是 1 之後, 該指標將會指向下一個整數, 也就是記憶體 104. \n 相同的概念下, 若 ptr 指向短整數, 則應該加上 2 而不是 1. 對於浮點, 雙浮點或使用者自訂的資料型別 - 結構, 也是類似. \n 儘管這並非我們常見的"加法", 但是在 C 語言中, 可以透過指標算數進行"加法"運算, 隨後將會再予以說明. \n 同理, 因為 ++ptr 與 ptr++ 與 ptr + 1 等同 (儘管 ptr 增量的時機點並不一樣). \n 讓指標以 ++ 增量運算子進行增量, 無論是先加或後加, 由 sizeof(type) 中所得到的位址增量, 其型別均為該物件指向變數的型別 (整數為 4 位元). \n 由於這 10 個整數位於記憶體中連續區塊上, 指標可以被用於整數資料陣列的處理. \n 例如: \n int my_array[] = {1,23,17,4,-5,100}; \n 陣列中帶有 6 個整數. 可以透過 my_array 的索引代表這些整數. 亦即利用 my_array[0] 到 my_array[5] 加以表示, 也可以透過指標加以表示成: \n int *ptr;\nptr = &my_array[0];       /* 將指標指向陣列中的第一個整數*/ \n 接著就可以使用陣列索引或取值運算, 列出陣列. \n 下列程式可以用來展示此一應用: \n ----------- Program 2.1 ----------------------------------- \n /* Program 2.1 from PTRTUT10.HTM   6/13/97 */\n \n#include <stdio.h>\n \nint my_array[] = {1,23,17,4,-5,100};\nint *ptr;\n \nint main(void)\n{\n    int i;\n    ptr = &my_array[0];     /* point our pointer to the first\n                                      element of the array */\n    printf("\\n\\n");\n    for (i = 0; i < 6; i++)\n    {\n      printf("my_array[%d] = %d   ",i,my_array[i]);   /*<-- A */\n      printf("ptr + %d = %d\\n",i, *(ptr + i));        /*<-- B */\n    }\n    return 0;\n} \n 在 codepad.org 執行 Program 2.1 \n 編譯執行上列程式就可以仔細觀察 A 行與 B 行程式分別採用兩種方法列出陣列中的同一內容. \n 也可以清楚看到 B 行程式如何應用"取值"運算, 亦即, 首先在指標增量後, 在新的指標中取值. 將 B 行程式改為: \n printf("ptr + %d = %d\\n",i, *ptr++); \n 之後再執行, 接著改為: \n printf("ptr + %d = %d\\n",i, *(++ptr)); \n 再執行, 執行之前先判定結果, 並與實際執行結果進行比較.\n\n在 C 語言, 可以利用 var_name 來替代 &var_name[0], 因此在程式碼中寫成: \n ptr = &my_array[0]; \n 或: \n ptr = my_array; \n 都會得到相同的結果. \n 因此許多參考書都寫道: 陣列的變數名稱就是指標. 但是比較好的想法則是: 陣列的變數名稱就是陣列中第一元件的位址. 許多初學者 (包含作者本人), 都會將其視為指標. \n 但是, 可以寫成: \n ptr = my_array; \n 但是卻不能寫成: \n my_array = ptr; \n 原因就是 ptr 為變數, 但是 my_array 卻是常數, 也就是說, my_array 第一元件的位址, 一旦在 my_array[] 完成宣告後, 就不可以改變. \n 先前曾討論的左值, 中引用 K&R-2 中所言: \n "物件為儲存區域的名稱, 而左值則為指向該物件的表示式." \n 這就衍生出一個有趣的議題. 因為 my_array 為儲存區域的代表名稱, 為何 my_array 在上面的指定敘述程式中, 卻不能用在左值區域? \n 為了說明這點, 可以將 my_array 視為"不可改變的左值". \n 上列範例可以將: \n ptr = &my_array[0]; \n 改為: \n ptr = my_array; \n 確認兩者會得到相同的結果. \n 至於 ptr 與 my_array 之間的差異, 有人將陣列變數名稱視為"常數指標". 為了充分了解所謂"常數"的真諦, 重回變數定義時的說明. \n 當變數宣告時, 用來存值的記憶體就必須加以配置. 這時變數可以透過兩個層面來看. \n 用在指定運算左邊時, 編譯器會視其為記憶位址, 用來指向右側所設定的值. \n 若被用在運算右邊時, 變數名稱會被解讀為存在該記憶體中的值. \n 有了以上的概念, 關注簡單的常數運算: \n int i, k;\ni = 2; \n 其中 i 為存放 2 常數的變數, 並非直接在資料記憶區塊中指定, 而是直接存入程式記憶區塊. \n 當 k = i; 程式碼就會到 &i 位址中抓取要複製到 k 的值, 而 i = 2; 只是將 2 放入程式碼, 而沒有取值的運作. 也就是說, k 與 i 都是物件, 但是 2 則非物件. \n 同理, 由於 my_array 為常數 (為位址值), 一旦編譯器設好用來存值得區域後, my_array[0] 存值得記憶體位址就已經確定, 因此可以使用: \n ptr = my_array; \n 將此在程式區段中的常數位址設給 ptr, 其中並沒有牽涉到資料區段的取值操作. \n 這時就可進一步說明第一章程式 1.1. 中 (void *) 的應用. 由於指標可被用來指向各種資料型別. 除了可以指向整數, 也可以指向字元, 之後還會介紹指向結構與指向指標的指標變數. \n 由於在不同系統中的指標儲值大小會有差別, 並且指標的記憶體空間會隨著指向物件資料型別差異而有所不同. \n 因此若將長整數指給短整數資料型別變數時, 就會發生問題, 也可以將某一型別的指標變數指定給其他不同型別指標變數時, 產生問題. \n 為了克服此一問題, C 語言提供 void 這個空的指標資料型別. \n 假如將某一指標設定為: \n void *vptr; \n 空指標可以視為通用指標. 由於 C 語言不允許整數型別指標與字元型別指標之間的資料交換或比較. 這時就可以透過空指標作為中介, 在特殊情況下在指標型別間進行資料轉換. \n 在第一章的 1.1 程式中, 就是使用空指標將整數指標轉成能與 %p 資料相符的格式. \n 下列各章, 也將透過此一概念進行資料轉換. \n 這裡列出許多技術資料給初學者, 首次閱讀時或許不很容易理解. 因此需要前後執行幾次程式, 看看結果, 並且仔細查驗這兩個例子中的程式碼與產出結果, 才會有所突破. \n 接下來, 將討論指標, 字元陣列與字串間的關係. \n', 'tags': '', 'url': 'ch2指標型別與陣列.html'}, {'title': 'ch3指標與字串', 'text': '字串的研究不僅對進一步理解指標與陣列的關聯有些幫助,也能用來彰顯某些標準 C 字串函數的使用. 最後也可以理解指標如何將資料傳給函式. \n 就 C 而言, 字串為字元所組成的陣列, 其他的語言則未必如此. 無論是 BASIC, Pascal 或是 Fortran 與其他幾種程式語言, 字串自有其資料類別. C 則不然, 字串之於 C 被表為以 0 位元 (寫為\'\\0\'). \n 這裡要以幾行程式碼作為開端, 來加以說明, 如下: \n char my_string[40];\n\nmy_string[0] = \'T\';\nmy_string[1] = \'e\';\nmy_string[2] = \'d\':\nmy_string[3] = \'\\0\'; \n 或許沒有人會用這種方法來建立字串, 以空字元作為結尾. 根據 C 語言的定義, 字串為一組以空字元結尾的字元陣列. 注意這裡的所謂空字元與 "NULL" 不同. 空字元表為以跳脫序 \'\\0\' 表示的"零"字元. 亦即佔了記憶體中的一個位元, 而 NULL 則為用來起始空指標的巨組程式. \n NULL 在 C 編譯器中, 以 #define 在標頭檔案中宣告, 而 nul 則完全無法以 #define 宣告. \n 由於用上述程式來宣告字串非常累人, 因此 C 允許以多種方法來完成一項工作. \n 首先, 可以寫成 \n char my_string[40] = {\'T\', \'e\', \'d\', \'\\0\',}; \n 但是光打字就有些不方便, 因此也可以寫成: \n char my_string[40] = "Ted"; \n 若使用的是雙引號, 而不是先前的單引號, 空字元 (\'\\0\') 會自動被加在字串最後面. \n 上面的例子, 結果都相同. 編譯器會保留連續的 40 位元區塊來存放 Ted\\0 這四個字元. \n 接著看看下列程式: \n ------------------program 3.1------------------------------------- \n /* Program 3.1 from PTRTUT10.HTM   6/13/97 */\n \n#include <stdio.h>\n \nchar strA[80] = "A string to be used for demonstration purposes";\nchar strB[80];\n \nint main(void)\n{\n \n    char *pA;     /* a pointer to type character */\n    char *pB;     /* another pointer to type character */\n    puts(strA);   /* show string A */\n    pA = strA;    /* point pA at string A */\n    puts(pA);     /* show what pA is pointing to */\n    pB = strB;    /* point pB at string B */\n    putchar(\'\\n\');       /* move down one line on the screen */\n    while(*pA != \'\\0\')   /* line A (see text) */\n    {\n        *pB++ = *pA++;   /* line B (see text) */\n    }\n    *pB = \'\\0\';          /* line C (see text) */\n    puts(strB);          /* show strB on screen */\n    return 0;\n} \n --------- end program 3.1 ------------------------------------- \n 在 codepad.org 執行 Program 3.1 \n 上述程式定義了兩個字元陣列, 各有 80 字元. 由於屬於全域變數, 一開始各字元都填入 \'\\0\'. 然後, strA 前 42 個字元被放入所引用的字串內容. \n 接著的程式碼, 宣告兩個字元指標並將其字串顯示在螢幕. 將 pA 指標指向 strA, 也就是附註 strA[0] 的位址給變數 pA. 然後利用 puts() 函數顯示 pA 所指向的內容 puts() 函式的宣告為: \n int puts(const char *s); \n 現在先不用管 const, 傳給 puts() 函數的變數為指標. 其實是指標所對應的值. 而指標的值為其所指向的位址. 因此寫成 puts(strA), 表示輸入變數為 strA[0] 的位址. \n 同理, 當程式寫 puts(pA); 也是以相同的位址當作輸入, 因為已經透過 \n pA = strA; \n 將位址傳給 pA \n 因此程式執行到 while() 指令中的 A 行時, A 行內容為: \n 當 pA 所指向的字元並非 nul 字元時 (也就是\'\\0\'), 執行其內容: \n 而 B 行程式則表示: 將 pA 指向的字元複製給 pB 所指向的字元, 接著增量 pA 後可以指向下一字元, 而 pB 則會指向下一個記憶體空間. \n 完成最後一個字元複製後, pA 會指向空字元, 也會終止迴圈的執行. \n 其中空字元並沒有複製, 但由於 C 中的字串一定要以空字元結尾, 所以在 C 行程式中再補上空字元. \n 執行此一程式時, 當使用者透過除錯器看著 strA, strB, pA 與 pB 一步步執行, 將非常具有教育意義. \n It is even more educational if instead of simply defining strB[] as has been done above, initialize it also with something like: \n 更有意思的是, 若不將 strB[] 按上述方法定義時, 而是將其起始值設為: \n strB[80] = "12345678901234567890123456789012345678901234567890" \n 讓其數字個數大於 strA 的長度, 然後一步步看著這些變數設定數值. 大家一定得親自做做看. \n 接著再回到 puts() 的原型, 運用 "const" 作為某一參數的宣告飾詞時, 主要在告訴使用者, 該函式無法改變其由 s 所指向的字串值, 意即, 程式會將該字串視為常數. \n 誠然, 上述程式展示了複製字串的一種簡單方式. 一旦確實了解上述程式的用法, 接著將自行編寫可以取代標準 strcpy() 的 C 標準函式, 程式如下: \n char *my_strcpy(char dest[], char source[])\n{\n    int i = 0;\n    while (source[i] != \'\\0\')\n    {\n        dest[i] = source[i];\n        i++;\n    }\n    dest[i] = \'\\0\';\n    return dest;\n} \n 在此一程式中, 同樣運用了指標的傳值. \n 承上述內容, 若將函式寫成可以接受兩個字元指標變數輸入, 也就是位址, 就可以將上述程式改寫為: \n int main(void)\n{\n    my_strcpy(strB, strA);\n    puts(strB);\n} \n 雖然與標準 C 的用法有些不同, 採用了下列原型定義: \n char *my_strcpy(char *destination, const char *source); \n 之所以使用 "const" 飾詞, 主要在確定該函式無法變更指向來源指標的數值. 此點可從上述函式的修改得到印證, 其原型變數, 如 "const" 飾詞所示. 接著在函式中, 增加一行試圖更改該變數由來源指標所指向的值, 意即: \n *source = \'X\'; \n 試著將該字串的第一個字元, 變更為 X. 前面的 const 飾詞就會讓這一行程式產生錯誤, 執行完後就會更加清楚有關 const 變數的使用. \n 接著, 繼續探討上述程式的內涵, 第一步, 將 ptr++ 解讀為由 ptr 指標傳回值後的增量. 主要與運算子的次序有關. 假如寫成 (ptr)++, 表示增量的部分, 並非指標, 而是該指標所指向值的增量. 也就是說, 在上述程式中, 若對第一個字元 \'T\' 增量, 其值就會變成 \'U\'. 使用者可以自行寫程式來印證此一結果. \n 由於字串只不過就是字元所組合而成的陣列, 並在最後一個字元補上 \'\\0\'. 上面所進行的是用來複製陣列. 這些字元陣列的運算技巧, 也可以應用到整數陣列或浮點數陣列. 但是在這些應用中, 陣列的尾端, 並不會補上 nul 字元, 而可以放進某特定值的內容, 來表示其為終點. 例如, 可以在複製正整數時, 在尾數放入一個負值的整數來標示終點. 或者, 寫一個函式, 可以複製字串以外的陣列及其陣列位址, 就如同下列原型所示: \n void int_copy(int *ptrA, int *ptrB, int nbr); \n 其中 nbr 為要進行複製的整數值. 試著寫一個可以用來複製整數陣列的 int_copy() 函式, 看看是否能夠正常運作. \n 如此, 就可以使用函式來處理大陣列. 例如, 有一帶有 5000 個整數的陣列需要處理, 只要將該陣列的位址輸入該函式 (視情形, 可以加上其他相關變數, 如上述程式中的 nbr 變數), 而不需要輸入陣列本身, 意即, 整個陣列值並沒有在堆疊中複製後進行輸入的動作, 而只送出其位址. \n 此一過程與輸入某一整數給某一函式不同. 輸入整數時, 必須複製該整數, 也就是取得該整數的值, 然後放入某一堆疊當中. 這時, 該函式的處理並不影響原始的整數值, 而若以陣列及指標進行處理, 可以將變數位址輸入, 直接處理原始變數的值. \n', 'tags': '', 'url': 'ch3指標與字串.html'}, {'title': 'ch4更多關於字串的用法', 'text': '好的, 在短短的時間裏, 已經介紹了不少東西! 接著再看一次第三章中有關字串複製的部分, 但是採不同的方法. 以下列函式來看: \n char *my_strcpy(char dest[], char source[])\n{\n    int i = 0;\n    while (source[i] != \'\\0\')\n    {\n        dest[i] = source[i];\n        i++;\n    }\n    dest[i] = \'\\0\';\n    return dest;\n} \n 之前曾說過, 字串就是字元所組成的陣列. 這裡我們利用陣列表示而非指標表示, 來進行資料的實質複製. 結果會與之前相同, 亦即, 採此一方法的字串複製, 其結果依然正確. 這也衍生出接下來要討論的有趣論點. \n 由於變數透過值進行傳遞, 可經由前述之字元指標或陣列名稱進行, 其間真正傳遞的則是每一陣列中第一個元素的位址. 亦即, 變數數值的傳遞, 可透過字元指標或陣列名稱來代表此一變數. 也可以說, source[i] 其實與 *(p+i) 的用法一樣. \n 事實上, 這是正確的, 亦即 a[i] 可以利用 *(a+i) 來替代, 而不會產生任何問題. 換言之, 編譯器針對這兩種情形, 會產生相同的編碼. 因此, 指標算術其實與陣列索引編碼相同. 兩種語法會產生相同結果. \n 但是這並非說, 指標與陣列是相同的東西, 其實不然. 這裡只是說, 利用陣列來進行特定元素辨識, 可以採用兩種不同的語法, 其一為採用陣列索引, 而另一種方法則是利用指標算術, 會得到相同的結果. \n 接著, 注意最後的表示式, (a+i) 的部分利用簡單的加號 + 與 C 的語法, 表示式子可以交換, 亦即 (a+i) 與 (i+a) 完全相同. 因此可以將 (i+a) 簡化為 (a+i). \n 但是 *(i+a) 可能來自 i[a]! 綜合上述, 或許會懷疑若: \n char a[20];\nint i; \n 寫成: \n a[3] = \'x\'; \n 其實與下列表示式, 其實是一樣的. \n 3[a] = \'x\'; \n 試試看! 設定一個字元陣列, 內存為整數或長整數等. 對其第三或第四元素, 以傳統方式, 給定特殊值, 接著將值印出加以確認. 然後如前述, 將陣列表示式反轉過來, 一個好編譯器將會毫無疑問的給出相同的結果, 僅只出於好奇, 別無其他用意. \n 程式範例: \n #include <stdio.h>\n \n// 每一個 C 程式都必須要有一個小寫的 main()函式\nint main()\n{\n    // 陣列與指標的應用\n    char a[20];\n    int i;\n    a[3] = \'x\';\n    printf("%c\\n",a[3]);\n    printf("%c\\n",3[a]);\n    printf("%c\\n",*(a+3));\n    printf("%c\\n",*(3+a));\n    return 0;\n} \n 執行上述程式 \n 接著, 來看前面給的函數, 寫成: \n dest[i] = source[i]; \n 由於已知陣列索引與指標算術會得到相同的結果, 因此也可以寫成: \n *(dest + i) = *(source + i); \n 但是, 需要對每一個值分別加上 i. 加法, 一般而言, 會比索引增量 (例如採用 ++ 運算符號的 i++) 耗費更多時間. 或許對現在最佳化的編譯器來說, 不一定就是如此, 但是採用指標通常比陣列索引來得快些. \n 另一個可以加速指標運算的方法, 將: \n \t\nwhile (*source != \'\\0\') \n 簡化為: \n while (*source) \n 兩種情形都會讓括號中為零 (FALSE). \n 這裡可實驗看看, 以指標的方法來寫程式. 用來處理字串應該不錯. 可以將下列標準函式改寫成自己的版本: \n strlen();\nstrcat();\nstrchr(); \n 或者其他在系統中的函式. \n 接下來的章節, 還會再探討字串及其處理. 接下來先討論一下 structures (結構). \n', 'tags': '', 'url': 'ch4更多關於字串的用法.html'}, {'title': 'ch5指標與結構', 'text': '也許你已經知道, 可以利用結構的形式來宣告帶有不同資料型別的資料區塊. 例如, 人事檔案可能包含下列結構: \n struct tag {\n    char lname[20];        /* 姓 */\n    char fname[20];        /* 名 */\n    int age;               /* 年齡 */\n    float rate;            /* 例如: 每小時 100 元 */\n}; \n 假如在磁片檔案中有許多這樣的資料, 當我們需要一筆筆讀出, 並且分別列出姓名, 以做成資料表格. 其他資料並不需要印出. 具體做法, 可以利用函式呼叫, 透過指向結構的指標作為輸入, 就可以完成處理. 這裡只利用一個結構進行示範, 並且主要在編寫函式, 而非讀檔. 這裡已經假設您知道如何進行讀檔. \n 複習一下, 我們可以利用點運算子來擷取結構成員, 正如: \n --------------- program 5.1 ----------------- \n /* Program 5.1 from PTRTUT10.HTM     6/13/97 */\n#include <stdio.h>\n#include <string.h>\n \nstruct tag {\n    char lname[20];      /* last name */\n    char fname[20];      /* first name */\n    int age;             /* age */\n    float rate;          /* e.g. 12.75 per hour */\n};\n \nstruct tag my_struct;       /* declare the structure my_struct */\n \nint main(void)\n{\n    strcpy(my_struct.lname,"Jensen");\n    strcpy(my_struct.fname,"Ted");\n    printf("\\n%s ",my_struct.fname);\n    printf("%s\\n",my_struct.lname);\n    return 0;\n} \n -------------- end of program 5.1 -------------- \n 執行 Program 5.1 \n 或許這裏所使用的結構與一般 C 程式所使用的相比還要小, 為了驗證也可以加入: \n date_of_hire;                  (未顯示資料型別)\ndate_of_last_raise;\nlast_percent_increase;\nemergency_phone;\nmedical_plan;\nSocial_S_Nbr;\n等等..... \n 假如員工的數量眾多, 應該會採用函式進行資料處理. 例如, 將結構輸入該函式, 就能利用函式印出員工姓名. 但是在最原始的 C (Kernighan & Ritchie, 第一版), 無法輸入結構, 只能輸入指向結構的指標. 在 ANSI C 中, 已經允許利用結構作為函式輸入. 而這裡為了進行更多有關指標的學習, 並不直接採用結構. \n 總之, 假如輸入整個結構, 就如同必須在函式呼叫時複製結構內容, 在仍然使用堆疊的系統中, 就等同將整個結構資料送入堆疊中. 針對大型結構時, 可能就會造成問題. 若能只輸入指標, 就可使用最少的堆疊空間. \n 因此這裡主要在談指標, 因此接著來看如何將指向結構的指標變數輸入函式當中. \n 以上面的情況為例, 建立一個能夠接受指標變數 (指向結構) 的函式, 其中我們只想要擷取該結構的部分成員. 例如, 只要印出範例結構中的人員姓名. \n 好, 先前我們已經知道如何宣告指向結構的指標變數 tag. 接著就可以利用 tag 結構, 來宣告指標變數: \n struct tag *st_ptr; \n 並且可以用來指向範例中的結構: \n st_ptr = &my_struct; \n 接下來, 可以利用指標的分割參照, 來指定特定成員. 但是應該如何利用指標的分割參照來指向結構? 假如要利用指標來設定人員的年紀, 可以寫成: \n (*st_ptr).age = 63; \n 仔細看清楚. 此一設定表示, 若將括號中 st_ptr 所指向的內容換成 my_struct, 就會與my_struct.age 相同. \n 但是, 這樣經常會被用到的表示式, 就被設定為與下列表示式涵義相同: \n st_ptr->age = 63; \n 了解了之後, 參考下列程式: \n ------------ program 5.2 --------------------- \n /* Program 5.2 from PTRTUT10.HTM   6/13/97 */\n \n#include <stdio.h>\n#include <string.h>\n \nstruct tag{                     /* the structure type */\n    char lname[20];             /* last name */\n    char fname[20];             /* first name */\n    int age;                    /* age */\n    float rate;                 /* e.g. 12.75 per hour */\n};\n \nstruct tag my_struct;           /* define the structure */\nvoid show_name(struct tag *p);  /* function prototype */\n \nint main(void)\n{\n    struct tag *st_ptr;         /* a pointer to a structure */\n    st_ptr = &my_struct;        /* point the pointer to my_struct */\n    strcpy(my_struct.lname,"Jensen");\n    strcpy(my_struct.fname,"Ted");\n    printf("\\n%s ",my_struct.fname);\n    printf("%s\\n",my_struct.lname);\n    my_struct.age = 63;\n    show_name(st_ptr);          /* pass the pointer */\n    return 0;\n}\n \nvoid show_name(struct tag *p)\n{\n    printf("\\n%s ", p->fname);  /* p points to a structure */\n    printf("%s ", p->lname);\n    printf("%d\\n", p->age);\n} \n -------------------- end of program 5.2 ---------------- \n 執行 Program 5.2 \n 這裡要了解不少東西. 讀者必須實際執行一下上面的程式, 並且利用除錯器一步步觀察 my_struct 與 p 在主函式執行流程中, 才能實際了解函式執行的內容. \n', 'tags': '', 'url': 'ch5指標與結構.html'}, {'title': 'ch6字串與字串陣列', 'text': '接著, 再回到字串的用法. 下面的例子, 都以全域的方式運用, 亦即, 在任何函式之外發生作用, 包括主函式. \n 先前的章節曾經談過: \n char my_string[40] = "Ted"; \n 將會配置足夠存放 40 個位元組陣列的空間來存放該變數的值, 並且在最前面的 4 個位元組中放入所設定的字元 (前面三個位元組放入雙引號中的字元, 而最後則放入 \'\\0\') \n 而實際上, 也可以將 "Ted" 這個字串寫成: \n char my_name[] = "Ted"; \n 編譯器屆時就會計算字元個數, 並且預留最後的 null 字元, 以便能將全部四個字元存入記憶體, 並傳回存放字元的陣列名稱, 這裡採用 my_name. \n 在某些程式中, 也可以寫成: \n char *my_name = "Ted"; \n 這種方式, 與先前兩種方法有何不同? 答案是: 當然不同. 採用陣列來存放四個位元組是將資料放在靜態記憶體區塊, 每一個字元的最後都會放入 null 字元. 但是若採用指標的方式, 也是需要相同的四個位元組, 並加上 N 個位元組來存放 my_name 這個指標變數 (N 取決於系統, 但通常至少 2 位元組, 也可能是 4 個以上) \n 陣列的表示法中, my_name 是 &myname[0] 的縮寫, 也就是第一個陣列元素的位址. 由於該陣列位址在執行期間是固定的, 因此不會改變 (不是變數). 而若採用指標的方式, my_name 則是變數. 因此採用指標是較好的方式, 當然也取決於隨後要如何應用這個變數. \n 若再進一步觀察採用不同方式宣告後, 在函數內將如何發生變化, 這與處在任何函式外的全域用法有很大的不同. \n void my_function_A(char ptr) { char a[] = "ABCDE" . . } void my_function_B(char ptr) \n 在 my_function_A 的案例中, 陣列 a[] 的值, 就是存放其中的資料. 陣列可視為以 ABCDE 值進行啟始化. 而在 my_function_B 的案例, cp 指標值才代表所存放的資料. 指標的啟始是指向 FGHIJ 字串. 在兩個函式內, 變數定義都是局部, 因此 ABCDE 字串存在指標變數所對應值的堆疊中, 而 FGHIJ 則可能存在任何地方. 在我的系統中, 是存在資料區段中. \n 此外, 採陣列變數自動起始, 就如同 my_function_A 中所示, 在舊的 K&R C 中是無法使用的, 只能用在 ANSI C 的環境中. 這點在考量程式的可攜或向後相容時就顯得很重要. \n 只要討論有關指標與陣列的關係與差異時, 就需要更進一步討論多維度陣列. 例如下列陣列: \n char multi[5][10]; \n 這代表什麼? 讓我們看看. \n char multi[5][10]; \n 若將有底線的部分視為陣列的變數名稱. 先前的 char 代表資料型別, 而隨後的 [10] 則代表擁有時個字元的陣列. 但是 multi[5] 本身又是一個具有 5 個成員的陣列, 而每一個都帶有 10 個字元的陣列. 亦即, 總共有 5 個陣列各自帶有 10 個字元的陣列. \n 假設將這個二維的陣列填入資料, 在記憶體中, 可以表示成為五個各自分離的陣列: \n multi[0] = {\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\'}\nmulti[1] = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\',\'h\',\'i\',\'j\'}\nmulti[2] = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\',\'J\'}\nmulti[3] = {\'9\',\'8\',\'7\',\'6\',\'5\',\'4\',\'3\',\'2\',\'1\',\'0\'}\nmulti[4] = {\'J\',\'I\',\'H\',\'G\',\'F\',\'E\',\'D\',\'C\',\'B\',\'A\'} \n 同時, 個別元素可以再表示為: \n multi[0][3] = \'3\'\nmulti[1][7] = \'h\'\nmulti[4][0] = \'J\' \n 由於陣列在記憶體中是連續的資料, 因此在真實的記憶區段中, 就成為: \n 0123456789abcdefghijABCDEFGHIJ9876543210JIHGFEDCBA\n^\n|_____ starting at the address &multi[0][0] \n 請注意, 這裡並沒有將 multi[0] 寫成"0123456789". 因為若寫成這樣, 電腦會在最 後面補上字串結束用的 \'\\0\', 因為雙引號中間的資料會被當作字串. 這樣, 每一個變數 就會帶有 11 個字元, 而非該有的 10 個字元. \n 前面的用意在昭示記憶體如何處理二維陣列. 亦即, 以一個二維字元陣列來存放資料, 而不是存成字串陣列. \n 接著, 編譯器知道陣列中需要多少行, 因此會用 mylti +1 作為 \'a\' 在第二列之首, 也就是每一列會加上 10, 結合所指的列數來取得正確的資料. \n 若處理的數值為整數與相同維數的陣列, 在我使用的機器上, 編譯器會加上 10sizeof(int), 而得到 20. 因此第四列第九行的位址, 表示為指標, 將會是 &multi[3][0] 或 (multi + 3). 若希望取得第四列第二個數值, 就可以在此位址上加上 1, 得到下列結果: \n *(*(multi + 3) + 1) \n 再繼續探究, 可知: \n *(*(multi + row) + col)    與\n\nmulti[row][col]            可得到相同的結果. \n 下列程式採用整數數列而非字元陣列來驗證這個結果: \n ------------------- program 6.1 ---------------------- \n #include <stdio.h>\n#define ROWS 5\n#define COLS 10\n \nint multi[ROWS][COLS];\n \nint main(void)\n{\n    int row, col;\n    for (row = 0; row < ROWS; row++)\n    {\n        for (col = 0; col < COLS; col++)\n        {\n            multi[row][col] = row*col;\n        }\n    }\n \n    for (row = 0; row < ROWS; row++)\n    {\n        for (col = 0; col < COLS; col++)\n        {\n            printf("\\n%d  ",multi[row][col]);\n            printf("%d ",*(*(multi + row) + col));\n        }\n    }\n \n    return 0;\n} \n ----------------- end of program 6.1 --------------------- \n 執行 Program 6.1 \n 由於在陣列程式版本中進行了兩次交互參照取值, 二維陣列的名稱就如同指向陣列的指標. 至於三維陣列則用來處理陣列中陣列所指向的陣列, 因此也等同是指向陣列中陣列的指標. 但這裡的說明將陣列所佔記憶體區段以陣列來加以表示, 因此所處理的記憶體位址為常數而非變數. 亦即所討論的是固定的位址而非變數指標. \n 上述的取值函式允許從陣列中, 以無需變更位址數值的方式從陣列中取出任何數值 (例如, 以 multi[0][0] 的位址取 multi 符號所對應的值) \n', 'tags': '', 'url': 'ch6字串與字串陣列.html'}, {'title': 'ch7多維陣列', 'text': '在前述章節中, 假如給定: \n #define ROWS 5\n#define COLS 10\n\nint multi[ROWS][COLS]; \n 若要擷取此 multi 陣列的元素, 可以透過: \n multi[row][col] \n 或 \n ((multi + row) + col) \n 為能更充分了解, 可以將: \n *(multi + row) \n 以 X 取代如下: \n *(X + col) \n 這樣, 可以看出 X 就如同指標, 因為此一表示式利用指標的取值運算子, 且可知 col 為一個整數. 這裡所使用的算術稱為指標算術. 換言之, 這是針對整數陣列, 指向 X+col+1 的位址值, 一定會大於 X+col 位址, 正好是 sizeof(int) 的整數值大小. \n 因為記憶體配置採用二維陣列, 因此上述所採用的 multi+row 到 multi+row+1 的增量, 將會等於下一列所指向的值, 也就是兩者增量為 COLS*sizeof(int). \n 也就是說 ((multi + row) + col) 能在執行時正確計算的條件, 是編譯器必須將 COLS 的數值考慮進去 (因為是兩個維度的記憶體配置). 正因為如此, 可以如上述說明, 採指標表示式或陣列表示式 multi[row][col]. \n 因此, 為了計算任何一個表示式, 共有五個數值必須先知道: \n 陣列的第一個元素的位址, 從 multi 表示式傳回, 亦即陣列名稱. \n 陣列元素的型別所佔記憶體空間大小, 在此為 sizeof(int). \n 陣列的第二維度大小. 第一維度索引值 row, 以及第二維度索引值 col 等. \n 有了這些值, 就可以設計函式來處理前述陣列宣告及運算. 例如, 可以將陣列 multi 元素的值都設為 1. \n void set_value(int m_array[][COLS])\n{\n    int row, col;\n    for (row = 0; row < ROWS; row++)\n    {\n        for (col = 0; col < COLS; col++)\n        {\n            m_array[row][col] = 1;\n        }\n    }\n} \n 若要呼叫此一函式, 可以採用: \n set_value(multi); \n Now, within the function we have used the values #defined by ROWS and COLS that set the limits on the for loops. But, these #defines are just constants as far as the compiler is concerned, i.e. there is nothing to connect them to the array size within the function. row and col are local variables, of course. The formal parameter definition permits the compiler to determine the characteristics associated with the pointer value that will be passed at run time. \n We really don’t need the first dimension and, as will be seen later, there are occasions where we would prefer not to define it within the parameter definition, out of habit or consistency, I have not used it here. But, the second dimension must be used as has been shown in the expression for the parameter. The reason is that we need this in the evaluation of m_array[row][col] as has been described. \n While the parameter defines the data type (int in this case) and the automatic variables for row and column are defined in the for loops, only one value can be passed using a single parameter. In this case, that is the value of multi as noted in the call statement, i.e. the address of the first element, often referred to as a pointer to the array. Thus, the only way we have of informing the compiler of the 2nd dimension is by explicitly including it in the parameter definition. \n In fact, in general all dimensions of higher order than one are needed when dealing with multi-dimensional arrays. That is if we are talking about 3 dimensional arrays, the 2nd and 3rd dimension must be specified in the parameter definition. \n', 'tags': '', 'url': 'ch7多維陣列.html'}, {'title': 'ch8指向陣列的指標', 'text': 'Pointers, of course, can be "pointed at" any type of data object, including arrays. While that was evident when we discussed program 3.1, it is important to expand on how we do this when it comes to multi-dimensional arrays. To review, in Chapter 2 we stated that given an array of integers we could point an integer pointer at that array using: \n int *ptr;\nptr = &my_array[0];       /* point our pointer at the first\n                             integer in our array */ \n As we stated there, the type of the pointer variable must match the type of the first element of the array. In addition, we can use a pointer as a formal parameter of a function which is designed to manipulate an array. e.g. \n Given: \n int array[3] = {1, 5, 7};\nvoid a_func(int *p); \n Some programmers might prefer to write the function prototype as: \n void a_func(int p[]); \n which would tend to inform others who might use this function that the function is designed to manipulate the elements of an array. Of course, in either case, what actually gets passed is the value of a pointer to the first element of the array, independent of which notation is used in the function prototype or definition. Note that if the array notation is used, there is no need to pass the actual dimension of the array since we are not passing the whole array, only the address to the first element. \n We now turn to the problem of the 2 dimensional array. As stated in the last chapter, C interprets a 2 dimensional array as an array of one dimensional arrays. That being the case, the first element of a 2 dimensional array of integers is a one dimensional array of integers. And a pointer to a two dimensional array of integers must be a pointer to that data type. One way of accomplishing this is through the use of the keyword "typedef". typedef assigns a new name to a specified data type. For example: \n typedef unsigned char byte;\n \n causes the name byte to mean type unsigned char. Hence \n byte b[10];     would be an array of unsigned characters. \n Note that in the typedef declaration, the word byte has replaced that which would normally be the name of our unsigned char. That is, the rule for using typedef is that the new name for the data type is the name used in the definition of the data type. Thus in: \n typedef int Array[10];\n \n Array becomes a data type for an array of 10 integers. i.e. Array my_arr; declares my_arr as an array of 10 integers and Array arr2d[5]; makes arr2d an array of 5 arrays of 10 integers each. \n Also note that Array p1d; makes p1d a pointer to an array of 10 integers. Because p1d points to the same type as arr2d, assigning the address of the two dimensional array arr2d to p1d, the pointer to a one dimensional array of 10 integers is acceptable. i.e. p1d = &arr2d[0]; or p1d = arr2d; are both correct. \n Since the data type we use for our pointer is an array of 10 integers we would expect that incrementing p1d by 1 would change its value by 10sizeof(int), which it does. That is, sizeof(p1d) is 20. You can prove this to yourself by writing and running a simple short program. \n Now, while using typedef makes things clearer for the reader and easier on the programmer, it is not really necessary. What we need is a way of declaring a pointer like p1d without the need of the typedef keyword. It turns out that this can be done and that \n int (*p1d)[10]; \n is the proper declaration, i.e. p1d here is a pointer to an array of 10 integers just as it was under the declaration using the Array type. Note that this is different from \n int *p1d[10]; \n which would make p1d the name of an array of 10 pointers to type int. \n', 'tags': '', 'url': 'ch8指向陣列的指標.html'}, {'title': 'ch9指標與動態記憶體配置', 'text': 'There are times when it is convenient to allocate memory at run time using malloc(), calloc(), or other allocation functions. Using this approach permits postponing the decision on the size of the memory block need to store an array, for example, until run time. Or it permits using a section of memory for the storage of an array of integers at one point in time, and then when that memory is no longer needed it can be freed up for other uses, such as the storage of an array of structures. \n When memory is allocated, the allocating function (such as malloc(), calloc(), etc.) returns a pointer. The type of this pointer depends on whether you are using an older K&R compiler or the newer ANSI type compiler. With the older compiler the type of the returned pointer is char, with the ANSI compiler it is void. \n If you are using an older compiler, and you want to allocate memory for an array of integers you will have to cast the char pointer returned to an integer pointer. For example, to allocate space for 10 integers we might write: \n int *iptr;\niptr = (int *)malloc(10 * sizeof(int));\nif (iptr == NULL)\n\n{ .. ERROR ROUTINE GOES HERE .. } \n If you are using an ANSI compliant compiler, malloc() returns a void pointer and since a void pointer can be assigned to a pointer variable of any object type, the (int *) cast shown above is not needed. The array dimension can be determined at run time and is not needed at compile time. That is, the 10 above could be a variable read in from a data file or keyboard, or calculated based on some need, at run time. \n Because of the equivalence between array and pointer notation, once iptr has been assigned as above, one can use the array notation. For example, one could write: \n int k;\nfor (k = 0; k < 10; k++)\n   iptr[k] = 2; \n to set the values of all elements to 2. \n Even with a reasonably good understanding of pointers and arrays, one place the newcomer to C is likely to stumble at first is in the dynamic allocation of multi-dimensional arrays. In general, we would like to be able to access elements of such arrays using array notation, not pointer notation, wherever possible. Depending on the application we may or may not know both dimensions at compile time. This leads to a variety of ways to go about our task. \n As we have seen, when dynamically allocating a one dimensional array its dimension can be determined at run time. Now, when using dynamic allocation of higher order arrays, we never need to know the first dimension at compile time. Whether we need to know the higher dimensions depends on how we go about writing the code. Here I will discuss various methods of dynamically allocating room for 2 dimensional arrays of integers. \n First we will consider cases where the 2nd dimension is known at compile time. \n METHOD 1: \n One way of dealing with the problem is through the use of the typedef keyword. To allocate a 2 dimensional array of integers recall that the following two notations result in the same object code being generated: \n multi[row][col] = 1;     *(*(multi + row) + col) = 1; \n It is also true that the following two notations generate the same code: \n multi[row]            *(multi + row) \n Since the one on the right must evaluate to a pointer, the array notation on the left must also evaluate to a pointer. In fact multi[0] will return a pointer to the first integer in the first row, multi[1] a pointer to the first integer of the second row, etc. Actually, multi[n] evaluates to a pointer to that array of integers that make up the n-th row of our 2 dimensional array. \n That is, multi can be thought of as an array of arrays and multi[n] as a pointer to the n-th array of this array of arrays. Here the word pointer is being used to represent an address value. While such usage is common in the literature, when reading such statements one must be careful to distinguish between the constant address of an array and a variable pointer which is a data object in itself. Consider now: \n --------------- Program 9.1 -------------------------------- \n /* Program 9.1 from PTRTUT10.HTM  6/13/97 */\n \n#include <stdio.h>\n#include <stdlib.h>\n \n#define COLS 5\n \ntypedef int RowArray[COLS];\nRowArray *rptr;\n \nint main(void)\n{\n    int nrows = 10;\n    int row, col;\n    rptr = malloc(nrows * COLS * sizeof(int));\n    for (row = 0; row < nrows; row++)\n    {\n        for (col = 0; col < COLS; col++)\n        {\n            rptr[row][col] = 17;\n        }\n    }\n \n    return 0;\n} \n ------------- End of Prog. 9.1 -------------------------------- \n 執行 Program 9.1 \n Here I have assumed an ANSI compiler so a cast on the void pointer returned by malloc() is not required. If you are using an older K&R compiler you will have to cast using: \n rptr = (RowArray *)malloc(.... etc.\n \n Using this approach, rptr has all the characteristics of an array name name, (except that rptr is modifiable), and array notation may be used throughout the rest of the program. That also means that if you intend to write a function to modify the array contents, you must use COLS as a part of the formal parameter in that function, just as we did when discussing the passing of two dimensional arrays to a function. \n METHOD 2: \n In the METHOD 1 above, rptr turned out to be a pointer to type "one dimensional array of COLS integers". It turns out that there is syntax which can be used for this type without the need of typedef. If we write: \n int (*xptr)[COLS]; \n the variable xptr will have all the same characteristics as the variable rptr in METHOD 1 above, and we need not use the typedef keyword. Here xptr is a pointer to an array of integers and the size of that array is given by the #defined COLS. The parenthesis placement makes the pointer notation predominate, even though the array notation has higher precedence. i.e. had we written \n int *xptr[COLS]; \n we would have defined xptr as an array of pointers holding the number of pointers equal to that #defined by COLS. That is not the same thing at all. However, arrays of pointers have their use in the dynamic allocation of two dimensional arrays, as will be seen in the next 2 methods. METHOD 3: \n Consider the case where we do not know the number of elements in each row at compile time, i.e. both the number of rows and number of columns must be determined at run time. One way of doing this would be to create an array of pointers to type int and then allocate space for each row and point these pointers at each row. Consider: \n -------------- Program 9.2 ------------------------------------ \n /* Program 9.2 from PTRTUT10.HTM   6/13/97 */\n \n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int nrows = 5;     /* Both nrows and ncols could be evaluated */\n    int ncols = 10;    /* or read in at run time */\n    int row;\n    int **rowptr;\n    rowptr = malloc(nrows * sizeof(int *));\n    if (rowptr == NULL)\n    {\n        puts("\\nFailure to allocate room for row pointers.\\n");\n        exit(0);\n    }\n \n    printf("\\n\\n\\nIndex   Pointer(hex)   Pointer(dec)   Diff.(dec)");\n \n    for (row = 0; row < nrows; row++)\n    {\n        rowptr[row] = malloc(ncols * sizeof(int));\n        if (rowptr[row] == NULL)\n        {\n            printf("\\nFailure to allocate for row[%d]\\n",row);\n            exit(0);\n        }\n        printf("\\n%d         %p         %d", row, rowptr[row], rowptr[row]);\n        if (row > 0)\n        printf("              %d",(int)(rowptr[row] - rowptr[row-1]));\n    }\n \n    return 0;\n} \n --------------- End 9.2 ------------------------------------ \n 執行 Program 9.2 \n In the above code rowptr is a pointer to pointer to type int. In this case it points to the first element of an array of pointers to type int. Consider the number of calls to malloc(): \n To get the array of pointers             1     call\nTo get space for the rows                5     calls\n                                      -----\n                 Total                   6     calls \n If you choose to use this approach note that while you can use the array notation to access individual elements of the array, e.g. rowptr[row][col] = 17;, it does not mean that the data in the "two dimensional array" is contiguous in memory. You can, however, use the array notation just as if it were a continuous block of memory. For example, you can write: \n rowptr[row][col] = 176; \n just as if rowptr were the name of a two dimensional array created at compile time. Of course row and col must be within the bounds of the array you have created, just as with an array created at compile time. If you want to have a contiguous block of memory dedicated to the storage of the elements in the array you can do it as follows: \n METHOD 4: \n In this method we allocate a block of memory to hold the whole array first. We then create an array of pointers to point to each row. Thus even though the array of pointers is being used, the actual array in memory is contiguous. The code looks like this: ----------------- Program 9.3 ----------------------------------- \n /* Program 9.3 from PTRTUT10.HTM   6/13/97 */\n \n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int **rptr;\n    int *aptr;\n    int *testptr;\n    int k;\n    int nrows = 5;     /* Both nrows and ncols could be evaluated */\n    int ncols = 8;    /* or read in at run time */\n    int row, col;\n \n    /* we now allocate the memory for the array */\n \n    aptr = malloc(nrows * ncols * sizeof(int));\n    if (aptr == NULL)\n    {\n        puts("\\nFailure to allocate room for the array");\n        exit(0);\n    }\n \n    /* next we allocate room for the pointers to the rows */\n \n    rptr = malloc(nrows * sizeof(int *));\n    if (rptr == NULL)\n    {\n        puts("\\nFailure to allocate room for pointers");\n        exit(0);\n    }\n \n    /* and now we \'point\' the pointers */\n \n    for (k = 0; k < nrows; k++)\n    {\n        rptr[k] = aptr + (k * ncols);\n    }\n \n    /* Now we illustrate how the row pointers are incremented */\n    printf("\\n\\nIllustrating how row pointers are incremented");\n    printf("\\n\\nIndex   Pointer(hex)  Diff.(dec)");\n \n    for (row = 0; row < nrows; row++)\n    {\n        printf("\\n%d         %p", row, rptr[row]);\n        if (row > 0)\n        printf("              %d",(rptr[row] - rptr[row-1]));\n    }\n    printf("\\n\\nAnd now we print out the array\\n");\n    for (row = 0; row < nrows; row++)\n    {\n        for (col = 0; col < ncols; col++)\n        {\n            rptr[row][col] = row + col;\n            printf("%d ", rptr[row][col]);\n        }\n        putchar(\'\\n\');\n    }\n \n    puts("\\n");\n \n    /* and here we illustrate that we are, in fact, dealing with\n       a 2 dimensional array in a contiguous block of memory. */\n    printf("And now we demonstrate that they are contiguous in memory\\n");\n \n    testptr = aptr;\n    for (row = 0; row < nrows; row++)\n    {\n        for (col = 0; col < ncols; col++)\n        {\n            printf("%d ", *(testptr++));\n        }\n        putchar(\'\\n\');\n    }\n \n    return 0;\n} \n ------------- End Program 9.3 ----------------- \n 執行 Program 9.3 \n Consider again, the number of calls to malloc() To get room for the array itself 1 call To get room for the array of ptrs 1 call ---- Total 2 calls \n Now, each call to malloc() creates additional space overhead since malloc() is generally implemented by the operating system forming a linked list which contains data concerning the size of the block. But, more importantly, with large arrays (several hundred rows) keeping track of what needs to be freed when the time comes can be more cumbersome. This, combined with the contiguousness of the data block that permits initialization to all zeroes using memset() would seem to make the second alternative the preferred one. \n As a final example on multidimensional arrays we will illustrate the dynamic allocation of a three dimensional array. This example will illustrate one more thing to watch when doing this kind of allocation. For reasons cited above we will use the approach outlined in alternative two. Consider the following code: \n ------------------- Program 9.4 ------------------------------------- \n /* Program 9.4 from PTRTUT10.HTM   6/13/97 */\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n \nint X_DIM=16;\nint Y_DIM=5;\nint Z_DIM=3;\n \nint main(void)\n{\n    char *space;\n    char ***Arr3D;\n    int y, z;\n    ptrdiff_t diff;\n \n    /* first we set aside space for the array itself */\n \n    space = malloc(X_DIM * Y_DIM * Z_DIM * sizeof(char));\n \n    /* next we allocate space of an array of pointers, each\n       to eventually point to the first element of a\n       2 dimensional array of pointers to pointers */\n \n    Arr3D = malloc(Z_DIM * sizeof(char **));\n \n    /* and for each of these we assign a pointer to a newly\n       allocated array of pointers to a row */\n \n    for (z = 0; z < Z_DIM; z++)\n    {\n        Arr3D[z] = malloc(Y_DIM * sizeof(char *));\n \n        /* and for each space in this array we put a pointer to\n           the first element of each row in the array space\n           originally allocated */\n \n        for (y = 0; y < Y_DIM; y++)\n        {\n            Arr3D[z][y] = space + (z*(X_DIM * Y_DIM) + y*X_DIM);\n        }\n    }\n \n    /* And, now we check each address in our 3D array to see if\n       the indexing of the Arr3d pointer leads through in a\n       continuous manner */\n \n    for (z = 0; z < Z_DIM; z++)\n    {\n        printf("Location of array %d is %p\\n", z, *Arr3D[z]);\n        for ( y = 0; y < Y_DIM; y++)\n        {\n            printf("  Array %d and Row %d starts at %p", z, y, Arr3D[z][y]);\n            diff = Arr3D[z][y] - space;\n            printf("    diff = %d  ",diff);\n            printf(" z = %d  y = %d\\n", z, y);\n        }\n    }\n    return 0;\n} \n ------------------- End of Prog. 9.4 ---------------------------- \n 執行 Program 9.4 \n If you have followed this tutorial up to this point you should have no problem deciphering the above on the basis of the comments alone. There are a couple of points that should be made however. Let\'s start with the line which reads: Arr3D[z][y] = space + (z(X_DIM * Y_DIM) + yX_DIM); \n Note that here space is a character pointer, which is the same type as Arr3D[z][y]. It is important that when adding an integer, such as that obtained by evaluation of the expression (z(X_DIM * Y_DIM) + yX_DIM), to a pointer, the result is a new pointer value. And when assigning pointer values to pointer variables the data types of the value and variable must match. \n', 'tags': '', 'url': 'ch9指標與動態記憶體配置.html'}, {'title': 'ch10指向函式的指標', 'text': 'Up to this point we have been discussing pointers to data objects. C also permits the declaration of pointers to functions. Pointers to functions have a variety of uses and some of them will be discussed here. \n Consider the following real problem. You want to write a function that is capable of sorting virtually any collection of data that can be stored in an array. This might be an array of strings, or integers, or floats, or even structures. The sorting algorithm can be the same for all. For example, it could be a simple bubble sort algorithm, or the more complex shell or quick sort algorithm. We\'ll use a simple bubble sort for demonstration purposes. \n Sedgewick [1] has described the bubble sort using C code by setting up a function which when passed a pointer to the array would sort it. If we call that function bubble(), a sort program is described by bubble_1.c, which follows: \n /*-------------------- bubble_1.c --------------------*/\n \n/* Program bubble_1.c from PTRTUT10.HTM   6/13/97 */\n \n#include <stdio.h>\n \nint arr[10] = { 3,6,1,2,3,8,4,1,7,2};\n \nvoid bubble(int a[], int N);\n \nint main(void)\n{\n    int i;\n    putchar(\'\\n\');\n    for (i = 0; i < 10; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    bubble(arr,10);\n    putchar(\'\\n\');\n \n    for (i = 0; i < 10; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    return 0;\n}\n \nvoid bubble(int a[], int N)\n{\n    int i, j, t;\n    for (i = N-1; i >= 0; i--)\n    {\n        for (j = 1; j <= i; j++)\n        {\n            if (a[j-1] > a[j])\n            {\n                t = a[j-1];\n                a[j-1] = a[j];\n                a[j] = t;\n            }\n        }\n    }\n} \n ---------------------- end bubble_1.c ----------------------- \n 執行 bubble_1.c \n The bubble sort is one of the simpler sorts. The algorithm scans the array from the second to the last element comparing each element with the one which precedes it. If the one that precedes it is larger than the current element, the two are swapped so the larger one is closer to the end of the array. \n On the first pass, this results in the largest element ending up at the end of the array. The array is now limited to all elements except the last and the process repeated. This puts the next largest element at a point preceding the largest element. The process is repeated for a number of times equal to the number of elements minus 1. The end result is a sorted array. \n Here our function is designed to sort an array of integers. Thus in line 1 we are comparing integers and in lines 2 through 4 we are using temporary integer storage to store integers. What we want to do now is see if we can convert this code so we can use any data type, i.e. not be restricted to integers. \n At the same time we don\'t want to have to analyze our algorithm and the code associated with it each time we use it. We start by removing the comparison from within the function bubble() so as to make it relatively easy to modify the comparison function without having to re-write portions related to the actual algorithm. This results in bubble_2.c: \n /*---------------------- bubble_2.c -------------------------*/\n \n/* Program bubble_2.c from PTRTUT10.HTM   6/13/97 */\n \n   /* Separating the comparison function */\n \n#include <stdio.h>\n \nint arr[10] = { 3,6,1,2,3,8,4,1,7,2};\n \nvoid bubble(int a[], int N);\nint compare(int m, int n);\n \nint main(void)\n{\n    int i;\n    putchar(\'\\n\');\n    for (i = 0; i < 10; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    bubble(arr,10);\n    putchar(\'\\n\');\n \n    for (i = 0; i < 10; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    return 0;\n}\n \nvoid bubble(int a[], int N)\n \n{\n    int i, j, t;\n    for (i = N-1; i >= 0; i--)\n    {\n        for (j = 1; j <= i; j++)\n        {\n            if (compare(a[j-1], a[j]))\n            {\n                t = a[j-1];\n                a[j-1] = a[j];\n                a[j] = t;\n            }\n        }\n    }\n}\n \nint compare(int m, int n)\n{\n    return (m > n);\n}\n/*--------------------- end of bubble_2.c -----------------------*/ \n 執行 bubble_2.c \n If our goal is to make our sort routine data type independent, one way of doing this is to use pointers to type void to point to the data instead of using the integer data type. As a start in that direction let\'s modify a few things in the above so that pointers can be used. To begin with, we\'ll stick with pointers to type integer. \n /*----------------------- bubble_3.c -------------------------*/\n \n/* Program bubble_3.c from PTRTUT10.HTM    6/13/97 */\n \n#include <stdio.h>\n \nint arr[10] = { 3,6,1,2,3,8,4,1,7,2};\n \nvoid bubble(int *p, int N);\nint compare(int *m, int *n);\n \nint main(void)\n{\n    int i;\n    putchar(\'\\n\');\n \n    for (i = 0; i < 10; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    bubble(arr,10);\n    putchar(\'\\n\');\n \n    for (i = 0; i < 10; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    return 0;\n}\n \nvoid bubble(int *p, int N)\n{\n    int i, j, t;\n    for (i = N-1; i >= 0; i--)\n    {\n        for (j = 1; j <= i; j++)\n        {\n            if (compare(&p[j-1], &p[j]))\n            {\n                t = p[j-1];\n                p[j-1] = p[j];\n                p[j] = t;\n            }\n        }\n    }\n}\n \nint compare(int *m, int *n)\n{\n    return (*m > *n);\n}\n \n/*------------------ end of bubble3.c -------------------------*/ \n 執行 Program bubble3.c \n Note the changes. We are now passing a pointer to an integer (or array of integers) to bubble(). And from within bubble we are passing pointers to the elements of the array that we want to compare to our comparison function. And, of course we are dereferencing these pointer in our compare() function in order to make the actual comparison. Our next step will be to convert the pointers in bubble() to pointers to type void so that that function will become more type insensitive. This is shown in bubble_4. \n /*------------------ bubble_4.c ----------------------------*/\n \n/* Program bubble_4.c from PTRTUT10,HTM   6/13/97 */\n \n#include <stdio.h>\n \nint arr[10] = { 3,6,1,2,3,8,4,1,7,2};\n \nvoid bubble(int *p, int N);\nint compare(void *m, void *n);\n \nint main(void)\n{\n    int i;\n    putchar(\'\\n\');\n \n    for (i = 0; i < 10; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    bubble(arr,10);\n    putchar(\'\\n\');\n \n    for (i = 0; i < 10; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    return 0;\n}\n \nvoid bubble(int *p, int N)\n{\n    int i, j, t;\n    for (i = N-1; i >= 0; i--)\n    {\n        for (j = 1; j <= i; j++)\n        {\n            if (compare((void *)&p[j-1], (void *)&p[j]))\n            {\n                t = p[j-1];\n                p[j-1] = p[j];\n                p[j] = t;\n            }\n        }\n    }\n}\n \nint compare(void *m, void *n)\n{\n    int *m1, *n1;\n    m1 = (int *)m;\n    n1 = (int *)n;\n    return (*m1 > *n1);\n}\n \n/*------------------ end of bubble_4.c ---------------------*/ \n 執行 bubble_4.c \n Note that, in doing this, in compare() we had to introduce the casting of the void pointer types passed to the actual type being sorted. But, as we\'ll see later that\'s okay. And since what is being passed to bubble() is still a pointer to an array of integers, we had to cast these pointers to void pointers when we passed them as parameters in our call to compare(). \n We now address the problem of what we pass to bubble(). We want to make the first parameter of that function a void pointer also. But, that means that within bubble() we need to do something about the variable t, which is currently an integer. Also, where we use t = p[j-1]; the type of p[j-1] needs to be known in order to know how many bytes to copy to the variable t (or whatever we replace t with). \n Currently, in bubble_4.c, knowledge within bubble() as to the type of the data being sorted (and hence the size of each individual element) is obtained from the fact that the first parameter is a pointer to type integer. If we are going to be able to use bubble() to sort any type of data, we need to make that pointer a pointer to type void. \n But, in doing so we are going to lose information concerning the size of individual elements within the array. So, in bubble_5.c we will add a separate parameter to handle this size information. \n These changes, from bubble4.c to bubble5.c are, perhaps, a bit more extensive than those we have made in the past. So, compare the two modules carefully for differences. \n /*---------------------- bubble5.c ---------------------------*/\n \n/* Program bubble_5.c from PTRTUT10.HTM    6/13/97 */\n \n \n \n#include <stdio.h>\n#include <string.h>\n \nlong arr[10] = { 3,6,1,2,3,8,4,1,7,2};\n \nvoid bubble(void *p, size_t width, int N);\nint compare(void *m, void *n);\n \nint main(void)\n{\n    int i;\n    putchar(\'\\n\');\n \n    for (i = 0; i < 10; i++)\n    {\n        printf("%d ", arr[i]);\n    }\n    bubble(arr, sizeof(long), 10);\n    putchar(\'\\n\');\n \n    for (i = 0; i < 10; i++)\n    {\n        printf("%ld ", arr[i]);\n    }\n \n    return 0;\n}\n \nvoid bubble(void *p, size_t width, int N)\n{\n    int i, j;\n    unsigned char buf[4];\n    unsigned char *bp = p;\n \n    for (i = N-1; i >= 0; i--)\n    {\n        for (j = 1; j <= i; j++)\n        {\n            if (compare((void *)(bp + width*(j-1)),\n                        (void *)(bp + j*width)))  /* 1 */\n            {\n/*              t = p[j-1];   */\n                memcpy(buf, bp + width*(j-1), width);\n/*              p[j-1] = p[j];   */\n                memcpy(bp + width*(j-1), bp + j*width , width);\n/*              p[j] = t;   */\n                memcpy(bp + j*width, buf, width);\n            }\n        }\n    }\n}\n \nint compare(void *m, void *n)\n{\n    long *m1, *n1;\n    m1 = (long *)m;\n    n1 = (long *)n;\n    return (*m1 > *n1);\n}\n \n/*--------------------- end of bubble5.c ---------------------*/ \n 執行 bubble5.c \n Note that I have changed the data type of the array from int to long to illustrate the changes needed in the compare() function. Within bubble() I\'ve done away with the variable t (which we would have had to change from type int to type long). I have added a buffer of size 4 unsigned characters, which is the size needed to hold a long (this will change again in future modifications to this code). The unsigned character pointer *bp is used to point to the base of the array to be sorted, i.e. to the first element of that array. \n We also had to modify what we passed to compare(), and how we do the swapping of elements that the comparison indicates need swapping. Use of memcpy() and pointer notation instead of array notation work towards this reduction in type sensitivity. \n Again, making a careful comparison of bubble5.c with bubble4.c can result in improved understanding of what is happening and why. \n We move now to bubble6.c where we use the same function bubble() that we used in bubble5.c to sort strings instead of long integers. Of course we have to change the comparison function since the means by which strings are compared is different from that by which long integers are compared. And,in bubble6.c we have deleted the lines within bubble() that were commented out in bubble5.c. \n /*--------------------- bubble6.c ---------------------*/\n/* Program bubble_6.c from PTRTUT10.HTM   6/13/97 */\n \n#include <stdio.h>\n#include <string.h>\n \n#define MAX_BUF 256\n \nchar arr2[5][20] = {  "Mickey Mouse",\n \n                      "Donald Duck",\n \n                      "Minnie Mouse",\n \n                      "Goofy",\n \n                      "Ted Jensen" };\n \nvoid bubble(void *p, int width, int N);\nint compare(void *m, void *n);\n \nint main(void)\n{\n    int i;\n    putchar(\'\\n\');\n \n    for (i = 0; i < 5; i++)\n    {\n        printf("%s\\n", arr2[i]);\n    }\n    bubble(arr2, 20, 5);\n    putchar(\'\\n\\n\');\n \n    for (i = 0; i < 5; i++)\n    {\n        printf("%s\\n", arr2[i]);\n    }\n    return 0;\n}\n \nvoid bubble(void *p, int width, int N)\n{\n    int i, j, k;\n    unsigned char buf[MAX_BUF];\n    unsigned char *bp = p;\n \n    for (i = N-1; i >= 0; i--)\n    {\n        for (j = 1; j <= i; j++)\n        {\n          k = compare((void *)(bp + width*(j-1)), (void *)(bp + j*width));\n          if (k > 0)\n            {\n             memcpy(buf, bp + width*(j-1), width);\n             memcpy(bp + width*(j-1), bp + j*width , width);\n             memcpy(bp + j*width, buf, width);\n            }\n        }\n    }\n}\n \nint compare(void *m, void *n)\n{\n    char *m1 = m;\n    char *n1 = n;\n    return (strcmp(m1,n1));\n}\n \n/*------------------- end of bubble6.c ---------------------*/ \n 執行 bubble6.c \n But, the fact that bubble() was unchanged from that used in bubble5.c indicates that that function is capable of sorting a wide variety of data types. What is left to do is to pass to bubble() the name of the comparison function we want to use so that it can be truly universal. Just as the name of an array is the address of the first element of the array in the data segment, the name of a function decays into the address of that function in the code segment. Thus we need to use a pointer to a function. In this case the comparison function. \n Pointers to functions must match the functions pointed to in the number and types of the parameters and the type of the return value. In our case, we declare our function pointer as: \n int *fptr(const void *p1, const void *p2); \n Note that were we to write: \n int *fptr(const void *p1, const void *p2); \n we would have a function prototype for a function which returned a pointer to type int. That is because in C the parenthesis () operator have a higher precedence than the pointer * operator. By putting the parenthesis around the string (*fptr) we indicate that we are declaring a function pointer. \n We now modify our declaration of bubble() by adding, as its 4th parameter, a function pointer of the proper type. It\'s function prototype becomes: \n void bubble(void *p, int width, int N,\n\nint(*fptr)(const void *, const void *)); \n When we call the bubble(), we insert the name of the comparison function that we want to use. bubble7.c illustrate how this approach permits the use of the same bubble() function for sorting different types of data. \n /*------------------- bubble7.c ------------------*/\n \n/* Program bubble_7.c from PTRTUT10.HTM  6/10/97 */\n \n#include <stdio.h>\n#include <string.h>\n \n#define MAX_BUF 256\n \nlong arr[10] = { 3,6,1,2,3,8,4,1,7,2};\nchar arr2[5][20] = {  "Mickey Mouse",\n                      "Donald Duck",\n                      "Minnie Mouse",\n                      "Goofy",\n                      "Ted Jensen" };\n \nvoid bubble(void *p, int width, int N,\n            int(*fptr)(const void *, const void *));\nint compare_string(const void *m, const void *n);\nint compare_long(const void *m, const void *n);\n \nint main(void)\n{\n    int i;\n    puts("\\nBefore Sorting:\\n");\n \n    for (i = 0; i < 10; i++)               /* show the long ints */\n    {\n        printf("%ld ",arr[i]);\n    }\n    puts("\\n");\n \n    for (i = 0; i < 5; i++)                  /* show the strings */\n    {\n        printf("%s\\n", arr2[i]);\n    }\n    bubble(arr, 4, 10, compare_long);          /* sort the longs */\n    bubble(arr2, 20, 5, compare_string);     /* sort the strings */\n    puts("\\n\\nAfter Sorting:\\n");\n \n    for (i = 0; i < 10; i++)             /* show the sorted longs */\n    {\n        printf("%d ",arr[i]);\n    }\n    puts("\\n");\n \n    for (i = 0; i < 5; i++)            /* show the sorted strings */\n    {\n        printf("%s\\n", arr2[i]);\n    }\n    return 0;\n}\n \nvoid bubble(void *p, int width, int N,\n            int(*fptr)(const void *, const void *))\n{\n    int i, j, k;\n    unsigned char buf[MAX_BUF];\n    unsigned char *bp = p;\n \n    for (i = N-1; i >= 0; i--)\n    {\n        for (j = 1; j <= i; j++)\n        {\n            k = fptr((void *)(bp + width*(j-1)), (void *)(bp + j*width));\n            if (k > 0)\n            {\n                memcpy(buf, bp + width*(j-1), width);\n                memcpy(bp + width*(j-1), bp + j*width , width);\n                memcpy(bp + j*width, buf, width);\n            }\n        }\n    }\n}\n \nint compare_string(const void *m, const void *n)\n{\n    char *m1 = (char *)m;\n    char *n1 = (char *)n;\n    return (strcmp(m1,n1));\n}\n \nint compare_long(const void *m, const void *n)\n{\n    long *m1, *n1;\n    m1 = (long *)m;\n    n1 = (long *)n;\n    return (*m1 > *n1);\n}\n \n/*----------------- end of bubble7.c -----------------*/ \n 執行 bubble7.c \n References for Chapter 10: \n "Algorithms in C" Robert Sedgewick Addison-Wesley ISBN 0-201-51425-7 \n', 'tags': '', 'url': 'ch10指向函式的指標.html'}, {'title': 'ch11結語', 'text': "I have written the preceding material to provide an introduction to pointers for newcomers to C. In C, the more one understands about pointers the greater flexibility one has in the writing of code. The above expands on my first effort at this which was entitled ptr_help.txt and found in an early version of Bob Stout's collection of C code SNIPPETS. The content in this version has been updated from that in PTRTUTOT.ZIP included in SNIP9510.ZIP. \n I am always ready to accept constructive criticism on this material, or review requests for the addition of other relevant material. Therefore, if you have questions, comments, criticisms, etc. concerning that which has been presented, I would greatly appreciate your contacting me via email me at tjensen@ix.netcom.com. \n", 'tags': '', 'url': 'ch11結語.html'}, {'title': 'C++', 'text': '計算機程式除了包含語法、資料結構與演算法外, 還需要針對不同應用領域所需的知識, 才能用來解決問題. \n 以機械設計工程系的角度看 C++ 計算機程式, 學員未來可以利用 C++ 與  Qt  程式框架, 開發用來控制機器人的套件, 或 CAD/E/M 等電腦輔助設計、工程分析與輔助製造相關的程式. \n 從本計算機程式課程, 延伸至網際內容管理、電腦輔助設計實習與協同產品設計等課程的教學目標而言, 學習 C++ 程式的目的, 在於能夠延伸類似  Solvespace  C++ 程式原始碼, 有效解決電腦輔助設計相關問題. \n 以下我們將引用  https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-096-introduction-to-c-january-iap-2011/  中的課程資料, 簡介 C++ 程式語法與相關應用. \n C++ Introduction \n C++ Flow of Control \n C++ Functions \n C++ Arrays and Strings \n C++ Pointers \n C++ Classes \n C++ Object Oriented Programming \n C++ Memory Management \n C++ Advanced Topics I \n C++ Advanced Topics II \n 另外, 我們也將參考  https://web.stanford.edu/class/cs106l/  課程中的資料: \n Standard C++ Programming Laboratory full reader.pdf \n 最後, 在 C++ 計算機程式語言的學習, 針對最新 C++ 的程式標準, 請參考  http://pages.cs.wisc.edu/~gerald/cs368/  課程中的資料: \n Teach Modern C++.pdf \n', 'tags': '', 'url': 'C++.html'}, {'title': 'Python', 'text': '根據 Google 的搜尋, 以及 IEEE Spectrum 資料分析, Python 為目前最流行的計算機程式語言之一. \n http://pypl.github.io/PYPL.html \n https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018 \n ./../downloads/AE1205-Python-Tutorial-v3.11.pdf  在機械設計相關技術開發方面, Python 結合  PyQt5  與演化分析, 可用來建立機構模擬與合成套件:  https://github.com/KmolYuan/Pyslvs-PyQt5 \n Python 也可以套用 Flask 框架, 建立簡單的網際內容管理系統:  https://github.com/chiamingyen/cmsimfly  或結合 oauth2 與 ORM 資料庫模組, 建立網際協同群組軟體:  https://github.com/chiamingyen/pygrouf \n Python 也被用於自動化特定流程:  https://automatetheboringstuff.com/ \n Python 工程教材:  http://homepage.tudelft.nl/7p97s/docs/AE1205-Python-Tutorial-v3.11.pdf  (將 AE1205-Python-Tutorial-v3.1.1.pdf 改寫為 Python3) \n Python3 import and modules.pdf \n 2015 An Introduction to Python and Computer Programming: \n https://link.springer.com/book/10.1007/978-981-287-609-6   \n 其他參考資料: \n Python 入門課程教學影片 \n https://www.cs.cmu.edu/~112/   (2018 Fall) \n Stanford 2017 \n MIT 2016 Fall \n Cambridge Python3 notes \n Python 程式語言 \n Brython  是一套能讓使用者在網頁中執行 Python3 程式的 Javascript 程式庫, 與 C 所編寫的 Python 3.7 差異比較: \n https://www.brython.info/static_doc/en/stdlib.html   \n 本課程為了提升 Python3 初學者執行程式碼的方便性, 在  CMSimfly  內容管理系統中導入  Brython . 使用者可以利用以下編輯區執行  Brython  程式. \n Python 是一種非常適合初學者學習的電腦程式語言, 變數資料或字串的列印, 可以直接使用 print() 函式執行. \n 由於 Python 解譯系統在設計的過程, 保留了部分的關鍵字, 因此使用者在學習 Python 時, 必須了解有那些關鍵字, 不能被用來設定為程式中變數設計的名稱. \n 上面的敘述, 提到程式中的術語有變數, 字串, print () 函式,  解譯系統 與關鍵字. \n 變數 ( Variables ), 在 Wikipedia 說明如下: \n In computer programming, a variable or scalar is a storage location (identified by a memory address) paired with an associated symbolic name (an identifier), which contains some known or unknown quantity of information referred to as a value. \n The variable name is the usual way to reference the stored value, in addition to referring to the variable itself, depending on the context. This separation of name and content allows the name to be used independently of the exact information it represents. \n The identifier in computer source code can be bound to a value during run time, and the value of the variable may thus change during the course of program execution. \n Variables in programming may not directly correspond to the concept of variables in mathematics. The latter is abstract, having no reference to a physical object such as storage location. The value of a computing variable is not necessarily part of an equation or formula as in mathematics. \n Variables in computer programming are frequently given long names to make them relatively descriptive of their use, whereas variables in mathematics often have terse, one- or two-character names for brevity in transcription and manipulation. \n A variable\'s storage location may be referred by several different identifiers, a situation known as aliasing. Assigning a value to the variable using one of the identifiers will change the value that can be accessed through the other identifiers. \n Compilers have to replace variables\' symbolic names with the actual locations of the data. While a variable\'s name, type, and location often remain fixed, the data stored in the location may be changed during program execution. \n print() 函式, 可以接受多個列印資料輸入, 且可透過 end 與 sep 輸入變數的設定, 決定列印結尾與分隔對應字串. \n 參考:  Get Started ,  Data and Expressions \n  啟動 Brython 時, 設定 pythonpath 為 /static/, 並將共用 .py 放入, 可以在隨後的程式中導入使用  \n  導入 brython  \n \n \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  印出版次與關鍵字程式  \n \n \n \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n Filename:  .py   \n Run   Output   清除 \n \n  ****************************** keyword start  \n \n \n  ****************************** keyword end  \n \n  ****************************** for1 start  \n \n \n  ****************************** for1 end  \n  ***************************** hello start  \n \n  ***************************** hello end  \n  ***************************** input start  \n \n \n \n  ***************************** input end  \n \n  ***************************** math start  \n \n \n \n  ***************************** math end  \n keyword for1 hello input math \n 初步了解 print() 函式的應用後,  接下來學習如何自定函式與呼叫函式, 了解 Python 程式如何能夠不需像 C/C++ 使用 {} 來界定執行從屬關係, 且如何利用函式中的 return 傳回有用的資料. \n 參考資料:  Functions ,  Conditionals \n  *********************************************************************************************  \n  用來顯示 prog1 程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n Filename:  .py   \n Run   Output   清除 \n \n  ***************************** hello start  \n \n  ***************************** hello end  \n  prog1 編輯器中, 會以最後引用物件的程式碼為顯示內容, 即下列的 prog1  \n  ***************************** prog1 start  \n \n \n \n  ***************************** prog1 end  \n prog1 hello1 \n Python 程式中的迴圈. \n 參考資料:  Loops ,  Debugging ,  Testing and Exceptions ,  Strings ,  Algorithmic Thinking ,  Style ,  1D Lists and Tuples ,  2D Lists ,  Sets ,  Dictionalry ,  Efficiency ,  OOP ,  Recursion ,  Recursion2 ,  Large Project Design and Documentation \n  *********************************************************************************************  \n  用來顯示 prog2 程式碼的 editor 區域  \n \n Filename:  .py   \n Run   Output   清除 \n \n  ***************************** hello start  \n \n  ***************************** hello end  \n  prog2 編輯器中, 會以最後引用物件的程式碼為顯示內容, 即下列的 prog2  \n  ***************************** prog2 start  \n \n \n \n  ***************************** prog2 end  \n  ********************************** sum start  \n \n \n \n prog2 hello2 sum \n', 'tags': '', 'url': 'Python.html'}, {'title': 'Python 教材', 'text': '本教材根據  https://www.cs.cmu.edu/~112/  內容改寫, 文中英文單字請使用  Merriam-Webster  英英線上或手機 App 字典查詢, 並網羅用來解釋特定英文生字的相關常用單字, 以提升自我的英文閱讀能力. \n https://www.cs.cmu.edu/~112/notes/notes-getting-started.html  中提到的 \n Logistics  與  Preliminary  的解釋中,  就包含  procurement ,  maintenance ,  facilities  與  campaign  等常用單字. 假如學員願意花點時間研究這些英文單字的相關意涵, 並多次復習, 就能持續不斷改進自我的英文閱讀能力,  自行查詢網路上所提供的眾多 Python 英文教學資料. \n Logistics  指後勤物流, 在上課教材中, 指的是與課程有關的"事物"及"流程"說明介紹, 其中包括課程目標、課程網站、課程政策、教學大綱與上課時程安排等內容. \n Preliminary  則是指將對課程的進行方式與基本上課模式, 進行初步的說明介紹. \n Python 教材的建置目的, 是希望學員在學習九週之後, 能夠六人一組, 嘗試開發有用的程式. \n 這些程式專案可以是任何主題, 或者直接與往後的機電資整合產品開發流程相關. \n 先來一段 git 的基本練習 \n 啟動 p37 可攜系統 \n 在其中一個 Dos 命令列中, 輸入: \n     c: \n 表示要從 y: 槽切換到 c: 槽, 然後再下: \n     cd \\ \n 表示要更換目錄到 c: 槽的根目錄. 接下來建立一個 test 目錄: \n     mkdir test \n 然後更換目錄到此 test 目錄中. \n     cd test \n 接下來要執行 git 指令, 表示要將 test 起始為 Git 的倉儲: \n     git init \n 這時, c:\\test 目錄中會新增一個 .git 目錄, 表示現在這個 c:\\test 已經是 Git 倉儲. \n 接下來要利用 SciTE 編輯器, 在 test 目錄中建立一個 myprogram.txt 文字檔案, 在此之前, 請利用 SciTE 的下拉式功能表 Options 中的 Open Global Options File 開啟 SciTEGlobal.properties 設定檔案, 找到第 137 行的 \n     load.on.activate=1 \n 去掉原先最前頭的 "#" 符號, 然後存檔, 之後關閉所有開啟的 SciTE 編輯器, 如此, 可以讓 SciTE 所開啟的檔案, 內容有修改時, 可以即時呈現在編輯區中. \n 接著, 重新在 Dos 命令列中輸入: \n     y:\\SciTE\\bin\\Sc1.exe  \n 開啟已經修改 SciTEGlobal.properties 設定檔案之後的 SciTE 編輯區,  並且在  myprogram.txt 檔案中, 只加入一行: \n     my program \n 接著存檔, 這時 c:\\test 目錄中除了有 .git 目錄, 又多了一個 myprogram.txt 檔案. \n 接下來要對 c:\\test 倉儲進行新增與提交流程, 將 myprogram.txt 納入 .git 的版次管理. \n     git add myprogram.txt \n     git commit -m "initial add" \n 這時, c:\\test 倉儲中已經有一個改版的記錄, 接下來再編輯 myprogram.txt  檔案. 在其中的 "my program" 字串後, 連按兩個 Enter 後, 加入: \n     first function \n 然後存檔, 接著再執行 git add 與 git commit: \n     git add . \n     git commit -m "add first function" \n 接著重覆上述編輯動作, 新增 "second function" \n 然後, 再執行 git add 與 git commit : \n     git add . \n     git commit -m "add second function" \n 這時, 使用者已經可以利用: \n     git log \n 看到倉儲中已經有三個提交. 分別為: \n     a3a2eb3 add second function     9295dfd add first function     3019d3f initial add \n 這時若希望在加入 first function 版本狀態時, 新增一個測試功能, 若通過測試符合需求, 則併入已經納入 second function 的版本中, 若不符合需求, 則可將該測試分支刪除. \n 先準備將工作目錄, 導回 "add first function" 的提交版本. \n     git checkout 9295dfd \n 然後以此提交版本內容, 新增一個 dev 分支: \n     git branch dev \n 然後利用 git checkout 在工作目錄中導出 dev 的版本 (其實, 修改前的 dev 狀態與 "add first function" 提交時相同 \n     git checkout dev \n 接下來, 對 myprogram.txt 改版, 在 first function 字串後,  連按兩個 Enter  後, 輸入: \n     add test function \n myprogram.txt 存檔後, 接著, 進行另一次的新增與提交. \n     git add . \n     git commit -m "add test function" \n 這時若希望看到各提交點間的關係, 可以利用: \n     git log --graph --oneline --all \n 然後, 假設該測試功能已經通過, 準備與 add  second function 後的版本進行合併, 這時 git 出現 myprogram.txt 合併衝突, 因為 first function 後, 已經加入 seconf function, 但是 dev 分支是在 first function 加入後所導出的版本, 因此使用者在合併當下,  必須決定 add second function 與 add test function, 是只保留其中一項功能, 或者同時保留. \n     git checkout master \n 將工作目錄轉為 master 的版本, 然後將 dev 分支的內容合併進來: \n     git merge dev \n 這時的 myprogram.txt 內容為: \n 必須要刪除衝突標註符號, 同時保留 add second function 與 add test function, 存檔後成為: \n \n 最後對此一合併後的版本, 進行新增與提交: \n     git add . \n     git commit -m "complete first, second and test functions adding" \n 再以 git log --oneline --graph --all 檢查各提交間的關聯, 畫面如下圖所示: \n \n 利用以上方式管理檔案版次的好處是, 使用者可以透過高效能的 Git 工具, 導出各提交點的版本, 或者從任一版本建立分支進行各種測試, 不會影響到其他提交版本資料的發布, 等到近端的 git 倉儲進一步推送到遠端的伺服器時, 遠端倉儲不僅可以提供協同, 也可提升資料保全效益, 無論是近端或遠端電腦硬碟發生問題, 都可以從任一參與協同的倉儲中回復所有已經提交的各版本內容. \n 最後要將工作目錄導向最初 initial add 提交時的版本: \n     git checkout 9439e67 \n 導回 add first function 時的版本: \n     git checkout 5fcdac9 \n 導回 add second function 時的版本: \n     git checkout fb092cc \n 導回 dev 時的狀態: \n     git checkout 1c3d5ff \n 將工作目錄導回最後 master 合併 dev 分支的版本: \n     git checkout ace97d7 \n 將上述 test (畫面中為 test1) 目錄壓縮後:  cp_w3_test_repo.7z \n 經過上述的 Git 近端指令操作, 可以了解在程式開發過程, 可以透過  Git 分散式版本管理系統的功能, 以非常具有彈性的流程進行程式碼的編寫, 尤其當協同開發人員眾多時,  Git 與 Github 將更能發揮其條理開發的特定, 並且安全地保存各版次資料內容. \n 除了 Git 與 Github, 在計算機程式課程中還推薦另一項使用者較容易全盤主導的分散式版次管理工具:  Fossil SCM . \n Fossil SCM  的功能類似 Git, 而且近端工具與遠端工具都只需要一個檔案: fossil.exe (目前的最新版本為 2.7 版, 可以從  https://fossil-scm.org/index.html/uv/download.html  下載) \n 等大家都熟悉如何使用 Git 與 Github 來管理所開發的 Python 程式碼之後, 我們將在分組協同專案執行過程, 介紹如何在自建的 Ubuntu 伺服器上安裝  Fossil SCM . \n  Python 程式課程說明 \n 在  https://www.cs.cmu.edu/~112/  中的課程說明如下: \n A technical introduction to the fundamentals of programming with an emphasis on producing clear, robust, and reasonably efficient code using top-down design, informal analysis, and effective testing and debugging. Starting from first principles, we will cover a large subset of the Python programming language, including its standard libraries and programming paradigms. We will also target numerous deployment scenarios, including standalone programs, shell scripts, and web-based applications. This course assumes no prior programming experience. Even so, it is a fast-paced and rigorous preparation for 15-122. Students seeking a more gentle introduction to computer science should consider first taking 15-110. NOTE: students must achieve a C or better in order to use this course to satisfy the pre-requisite for any subsequent Computer Science course. \n 而課程學習目標: \n \n Develop computational problem-solving skills using Python as a tool to be applied to new problems, especially in the student\'s home academic discipline \n Produce clear, robust, and efficient code in Python by \n \n employing modular, top-down design \n using sequential, conditional, and loop statements where appropriate \n using strings, lists, tuples, and dictionaries where appropriate \n using objects and classes where appropriate \n integrating recursive functions where appropriate \n proactively designing and writing test cases to effectively test and debug code \n \n \n Develop an effective programming style based on established standards, practices, and guidelines \n Describe the difference between programming and Computer Science, and gain exposure to some of the Big Ideas of Computer Science (e.g., Computability) \n Explain and analyze the efficiency of algorithms by: \n \n proving the running time (Big-O) of various well-known searching and sorting algorithms \n determining (not proving) the running time (Big-O) of a small piece of code \n describing the difference between small code optimizations and more substantive algorithmic optimizations \n \n \n Design and implement event-based graphical animations \n Develop and write a substantial (500-1500 line) program in Python to implement a solution to a term project of their choosing over three to four weeks \n \n 如何執行 Python 程式 \n 在本課程中, 至少有三種方法可以執行 Python 程式: \n \n 啟動  P37  可攜程式系統後, 以 SciTE 編輯器開啟或新建副檔名為 py 的檔案, 使用下拉式功能表 Tools -> Go, 就可以執行 Python 程式. \n 使用可攜系統所啟動的 Dos 命令列, 在 .py 程式碼所在的目錄, 以 python 程式碼檔名.py, 按下 Enter, 就可以執行該 Python 程式. \n 部分原生 Python 程式碼與  Brython  特有程式用法, 可以在導入  Brython  解譯器的網頁中執行與 Python 相容的程式碼. \n \n  啟動 Brython 時, 設定 pythonpath 為 /static/, 並將共用 .py 放入, 可以在隨後的程式中導入使用  \n  導入 brython  \n \n \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n 開始練習 print() 用法, 並著手建立函式 \n  印出版次與關鍵字程式  \n \n \n \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n Filename:  .py   \n Run   Output   清除 \n \n  ****************************** keyword start  \n \n \n  ****************************** keyword end  \n  ***************************** slide ex1 start  \n \n \n \n  ***************************** slide ex1 end  \n  ***************************** slide ex2 start  \n \n \n \n  ***************************** slide ex2 end  \n  ***************************** slide ex3 start  \n \n \n \n  ***************************** slide ex3 end  \n  ***************************** slide ex4 start  \n \n \n \n  ***************************** slide ex4 end  \n Keyword Ex1 Ex2 Ex3 Ex4 \n 認識 Syntax, Runtime 與 Logical Errors \n Syntax errors, also known as parsing errors, 指 Python 解譯器在解讀程式碼的過程所發生的語法錯誤. 例如: 在 if , elif , else , for , while , class ,def 宣告時未能加上":". \n 比較操作符未能使用 "==". \n 因為界定程式執行範圍的縮排單位不一致. \n 整數或浮點數與字串以 + 串接時, 忘記利用  str()  轉為字串, 或字串與整數運算時, 忘記利用  int()  將字串轉為整數. \n 字串設定未能使用單引號, 雙引號或三引號界定. \n 變數命名錯誤, 例如: 以數字開頭變數命名, 或誤用關鍵字作為變數名稱. \n 數列引用超出範圍. \n 參考資料: \n http://inventwithpython.com/blog/2012/07/09/16-common-python-runtime-errors-beginners-find/   \n 利用 input() 取得使用者輸入 \n 在網頁中透過  Brython , 可以讓  input()  函式的執行跳出視窗表單, 讓使用者以互動方式執行 Python 程式. 經由  input()  取得的資料型別為字串, 若要將取得的變數當作整數使用, 必須利用  int()  將字串轉為整數. 若需轉為浮點數, 則可使用  float() . \n 若在程式執行, 需要將整數型別資料轉為字串, 可以使用  str()  函式轉換. \n Python 3 的內建函式 \n Built-in Functions: \n https://docs.python.org/3.7/library/functions.html   \n PEP (Python Enhancement Proposals): \n Index of PEP:  https://www.python.org/dev/peps/   \n Style Guide for Python Code:  https://www.python.org/dev/peps/pep-0008/   \n Docstring Conventions:  https://www.python.org/dev/peps/pep-0257/   \n Python WSGI V1.0.1:  https://www.python.org/dev/peps/pep-3333/   \n Python 3.7 Release Schedule:  https://www.python.org/dev/peps/pep-0537/   \n Type Hints:  https://www.python.org/dev/peps/pep-0484/   \n 條件判斷式用法:  https://www.cs.cmu.edu/~112/notes/notes-conditionals.html   \n 迴圈用法:  https://www.cs.cmu.edu/~112/notes/notes-loops.html   \n 程式除錯:  https://www.cs.cmu.edu/~112/notes/notes-debugging.html   \n 字串:  https://www.cs.cmu.edu/~112/notes/notes-strings.html   \n 1 維數列與元組:  https://www.cs.cmu.edu/~112/notes/notes-1d-lists.html   \n 2 維數列:  https://www.cs.cmu.edu/~112/notes/notes-2d-lists.html   \n 集合:  https://www.cs.cmu.edu/~112/notes/notes-sets.html   \n 字典:  https://www.cs.cmu.edu/~112/notes/notes-dictionaries.html   \n 效率:  https://www.cs.cmu.edu/~112/notes/notes-efficiency.html   \n 物件導向:  https://www.cs.cmu.edu/~112/notes/notes-oop.html   \n 遞迴:  https://www.cs.cmu.edu/~112/notes/notes-recursion-part1.html \n https://www.cs.cmu.edu/~112/notes/notes-recursion-part2.html   \n 執行緒:  https://docs.python.org/3/library/threading.html   \n 演算法思維:  https://www.cs.cmu.edu/~112/notes/notes-algorithmic-thinking.html   \n 如何解決問題:  https://en.wikipedia.org/wiki/How_to_Solve_It   \n Python Tutorial:  https://docs.python.org/3.7/tutorial/index.html   \n Flask 網際程式:  http://flask.pocoo.org/   \n 範例:  CMSimfly  與  PyGrouf \n PyQt5 視窗程式:  tutorial1 ,  tutorial2 ,  tutorial 3 ,  tutorial 4 ,  Eric6 IDE \n 範例:  Pyslvs   \n 了解如何導入與建立模組 \n https://docs.python.org/3/tutorial/modules.html   \n 如何吸引更多人運用計算機程式工具 \n How to make teenage girls love coding using Python and the visual arts orienting language Processing.pdf \n 參考資料 \n AutoWIG - automatic generation of python bindings for Cpp libraries.pdf \n https://github.com/StatisKit/AutoWIG   \n Solving inverse problems in building physics - an overview of guidelines for a careful and optimal use of data.pdf', 'tags': '', 'url': 'Python 教材.html'}, {'title': 'what is new', 'text': "https://docs.python.org/3.0/whatsnew/3.0.html   \n https://docs.python.org/3/whatsnew/3.4.html \n https://docs.python.org/3/whatsnew/3.5.html \n https://docs.python.org/3/whatsnew/3.6.html   \n https://docs.python.org/3/whatsnew/3.7.html   \n Python 3.7 關鍵字: \n # Python 3.7\n> keyword.kwlist\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] \n 模組化程式設計: \n https://www.python-course.eu/python3_modules_and_modular_programming.php   \n Python 3.7 Data Classes \n https://www.python.org/dev/peps/pep-0557/   \n https://stackoverflow.com/questions/47955263/what-are-data-classes-and-how-are-they-different-from-common-classes   \n", 'tags': '', 'url': 'what is new.html'}, {'title': 'style guide', 'text': 'Python docstring conventions: \n https://www.python.org/dev/peps/pep-0257/   \n One line docstring: \n def kos_root():\n    """Return the pathname of the KOS root directory."""\n    global _kos_root\n    if _kos_root: return _kos_root\n    ... \n Multiline docstring: \n def complex(real=0.0, imag=0.0):\n    """Form a complex number.\n\n    Keyword arguments:\n    real -- the real part (default 0.0)\n    imag -- the imaginary part (default 0.0)\n    """\n    if imag == 0.0 and real == 0.0:\n        return complex_zero\n    ... \n Aligned with opening delimiter. \n foo = long_function_name(var_one, var_two,\n                         var_three, var_four) \n List: \n my_list = [\n    1, 2, 3,\n    4, 5, 6,\n    ] \n \n Easy to match operators with operands: \n income = (gross_wages\n          + taxable_interest\n          + (dividends - qualified_dividends)\n          - ira_deduction\n          - student_loan_interest) \n Surround top-level function and class definitions with two blank lines. \n Method definitions inside a class are surrounded by a single blank line. \n Extra blank lines may be used (sparingly) to separate groups of related functions. Blank lines may be omitted between a bunch of related one-liners (e.g. a set of dummy implementations). \n Use blank lines in functions, sparingly, to indicate logical sections. \n Python style guide: \n https://www.python.org/dev/peps/pep-0008/   \n Type hins: \n https://www.python.org/dev/peps/pep-0484/   \n', 'tags': '', 'url': 'style guide.html'}, {'title': 'typing', 'text': 'Python 3.5 之後才支援 typing 模組: \n https://docs.python.org/3.6/library/typing.html   \n', 'tags': '', 'url': 'typing.html'}, {'title': 'dunder', 'text': 'Module level "dunders" (i.e. names with two leading and two trailing underscores) such as __all__, __author__, __version__, etc. should be placed after the module docstring but before any import statements except from __future__ imports. Python mandates that future-imports must appear in the module before any other code except docstrings: \n """This is the example module.\n\nThis module does stuff.\n"""\n\nfrom __future__ import barry_as_FLUFL\n\n__all__ = [\'a\', \'b\', \'c\']\n__version__ = \'0.1\'\n__author__ = \'Cardinal Biggles\'\n\nimport os\nimport sys \n What Are Dunder Methods? \n In Python, special methods are a set of predefined methods you can use to enrich your classes. They are easy to recognize because they start and end with double underscores, for example __init__ or __str__. \n As it quickly became tiresome to say under-under-method-under-under Pythonistas adopted the term “dunder methods”, a short form of “double under.” \n These “dunders” or “special methods” in Python are also sometimes called “magic methods.” But using this terminology can make them seem more complicated than they really are—at the end of the day there’s nothing “magical” about them. You should treat these methods like a normal language feature. \n Dunder methods let you emulate the behavior of built-in types. For example, to get the length of a string you can call len(\'string\'). But an empty class definition doesn’t support this behavior out of the box: \n class NoLenSupport:\n    pass\n\n>>> obj = NoLenSupport()\n>>> len(obj)\nTypeError: "object of type \'NoLenSupport\' has no len()" \n To fix this, you can add a __len__ dunder method to your class: \n class LenSupport:\n    def __len__(self):\n        return 42\n\n>>> obj = LenSupport()\n>>> len(obj)\n42 \n Another example is slicing. You can implement a __getitem__ method which allows you to use Python’s list slicing syntax: obj[start:stop]. \n #括號後與括號前不要有空白)\nspam(ham[1], {eggs: 2}) \n\n#逗點後不要有空白\nfoo = (0,)\n\n# 冒號緊接在 4 之後\nif x == 4: print x, y; x, y = y, x\n\nham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]\nham[lower:upper], ham[lower:upper:], ham[lower::step]\nham[lower+offset : upper+offset]\nham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]\nham[lower + offset : upper + offset]\n\nspam(1)\n\nx = 1\ny = 2\nlong_variable = 3\n\ni = i + 1\nsubmitted += 1\nx = x*2 - 1\nhypot2 = x*x + y*y\nc = (a+b) * (a-b)\n\ndef complex(real, imag=0.0):\n    return magic(r=real, i=imag)\n\ndef munge(input: AnyStr): ...\ndef munge() -> AnyStr: ...\n\ndef munge(sep: AnyStr = None): ...\ndef munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...\n\nif foo == \'blah\':\n    do_blah_thing()\ndo_one()\ndo_two()\ndo_three()\n\nFILES = [\n    \'setup.cfg\',\n    \'tox.ini\',\n    ]\ninitialize(FILES,\n           error=True,\n           ) \n Reference \n https://dbader.org/blog/python-dunder-methods   \n', 'tags': '', 'url': 'dunder.html'}, {'title': 'Flake8', 'text': 'Flake8 is a Tool for style guide enforcement. \n http://flake8.pycqa.org/en/latest/   \n https://github.com/PyCQA/pyflakes   \n Python 程式編寫, 必須通過 Flake8 格式查驗. \n', 'tags': '', 'url': 'Flake8.html'}, {'title': 'unittest', 'text': "https://docs.python.org/3/library/unittest.html   \n http://pythontesting.net/framework/unittest/unittest-introduction/   \n doctest: \n https://docs.python.org/3.7/library/doctest.html   \n doctest 可用來執行程式文件中所提供的範例, 確認能得到預期結果. doctest 可以用在比較簡單的程式測試, 較複雜的測試流程, 則建議使用 unittest. \n unittest 標準工作流程: \n \n 繼承 unittest.TestCase , 定義希望進行 unit test 的新類別. \n 在新類別中定義所需的測試方法, 各方法必須以 test_ 開頭命名. \n 執行 unittest.main() 以啟動所定義類別中的各測試方法. \n \n 簡單 unit test 範例: \n import unittest\n\ndef multiply(a, b):\n    return a * b\n \nclass TestUM(unittest.TestCase):\n \n    def setUp(self):\n        pass\n \n    def test_numbers_3_4(self):\n        self.assertEqual( multiply(3,4), 12)\n \n    def test_strings_a_3(self):\n        self.assertEqual( multiply('a',3), 'aaa')\n \nif __name__ == '__main__':\n    unittest.main() \n \n", 'tags': '', 'url': 'unittest.html'}, {'title': 'lark', 'text': 'https://github.com/lark-parser/lark   \n http://blog.erezsh.com/how-to-write-a-dsl-in-python-with-lark/   \n 如何利用 python lark 模組寫 DSL (Domain Specific Language) \n Matlab 與 Mathematica 就是 DSL 的典型範例. \n 首次使用 Logo 時, 感覺跟變魔術沒兩樣. 只要輸入簡短的指令組合, 就能在螢幕畫出非常複雜的圖形. \n 下面這一段教學, 將要展示如何利用 70 行程式, 透過解讀與解譯過程完成類似 Logo 的程式語言. 延續此一應用, 您將可自行打造自己的語言. 為了完成此一任務, 我們將使用 Lark 解讀程式庫與 turtle 繪圖模組. 讓我們開始! \n What is a DSL and why should you care \n When writing a software project, you might encounter information that your language of choice isn\'t very good at expressing or representing. It could be data, configuration, a list of commands, etc. Some abstraction might be missing, the language might prove too verbose, or writing the code might be too error-prone because there\'s no appropriate validation. When that happens, you might benefit from creating your own language, that describes the information in a clean and concise manner. That\'s called a "Domain-Specific Language", or DSL. \n DSLs tend to be small and concise. And like most things, they have both pros and cons. \n DSL Pros: \n \n Complete freedom of expression (within computational bounds) \n Clean and concise code that\'s easier to read, write, and debug. \n Validation by design \n Dynamic - it can be evaluated in run-time \n Reuse: DSLs can be shared between different languages and platforms (for example: Regular expressions) \n \n DSL Cons: \n \n Now there\'s another language to learn (but that\'s a lazy excuse) \n You won\'t have direct access to Python\'s features (or whatever is your host language) \n It\'s detached from your IDE \n It might be difficult to design and to code(For a more detailed overview of DSLs pros and cons, visit here) \n \n Overall, there are many great reasons to use DSLs, but many programmers choose to avoid it, rightfully fearing the DSL will add complexity and take a long time to write. But, it doesn\'t have to be this way... \n I\'m going to take you step-by-step as we write our own DSL, starting with a naive solution, until we reach a working program with a parser and an interpreter. Hopefully, by the end of it I will convince you that DSLs can be a viable and cost-effective choice for your projects. \n Designing a language \n In this tutorial, we\'re going to write a DSL for Python\'s Turtle module! For those who don\'t know it, it\'s a Logo-inspired module for drawing vector graphics using simple commands. The first step when designing a language is to learn about the problem we\'re trying to solve (the domain). So if you never used the Turtle module, it might be prudent to look at some code, browse the docs, or play around with it a little bit. \n To summarize, the Turtle module is used via a series of instructions. We can move the "turtle" on the canvas with spatial instructions (left, right, forward, etc.), we can change the size & color of the turtle\'s pen, instruct it to move with or without drawing, or otherwise alter the state of the turtle and/or window. \n The next step is to choose what your language is going to do: Which features or concepts it\'s going to support, and what you will leave out. To keep this tutorial short, we\'re going to support only a small subset of instructions: \n \n Left, right, forward and backward \n Color \n Repeat - since we can\'t use Python\'s "for" directly \n Fill - activates filling mode. Chosen to demonstate structure \n \n Now that we know the contents of the language, we can move on to the third step: Choosing a syntax. This step is part common-sense, part art, and part subjective opinion. However, I do believe there are some guidelines that are innately true. \n Guidelines to choosing syntax for a language: \n \n Use popular idioms, based on your target audience. By using structures, keywords and symbols everyone already knows, you cut the time it takes to learn your language. \n Brevity of expression should correlate to the size of the language. For small languages, it\'s okay to use a lot of shorthands (see: regexps), but when the language gets bigger, opt for clarity instead (aka don\'t be Perl). \n Design for innate correctness. Try to design the language so it will promote good practices, and discourage abuse. \n \n For example, Python was aimed at C programmers (among others), so it borrowed C syntax like += for in-place addition , and keywords like break and continue. \n For our Turtle DSL, I will borrow my idioms and syntax from Logo, but with a modern twist. We\'ll use {curly-braces} for code blocks. And since we\'ll be designing a very small, interpreted language, we can make our basic commands one-lettered. \n Here\'s how a program looks in my imaginary Turtle Language: \n c green blue    # fg & bg colors\nfill { repeat 36 {\n  f200 l170     # forward & left\n}}\n \n But it\'s not going to be imaginary for long! Let\'s move on to the practical side of things. \n Writing the grammar \n Step 1) EBNF \n Now that we know what our language looks like, we can to write a formal grammar for it. Later, we will feed our grammar to the parser, so it will know how to parse free-form text written in our language into a structured parse-tree that\'s easy to work with programmatically. \n The standard way to write grammars is in EBNF form, and that\'s what we\'ll do in this tutorial. EBNF grammars are basically a hierarchy of rules and strings of the form: \n name: production \n Where production is a list of names and values. \n Or informally: \n rule: rule1, "keyword", rule2, rule3, .. \n Rules can be recursive, but it\'s better to describe loops with repetition-operators. For example, this is how I would define Python\'s dictionary syntax in EBNF: \n dict: "{" dict_item* "}"\ndict_item: name ":" value\n... \n This is enough to allow us to describe an instruction in Turtle Language: \n instruction: "f" number\n           | "b" number\n           | "l" number\n           | "r" number\n           | "c" color [color] // bgcolor is optional\n           | "fill" code_block\n           | "repeat" number code_block\n \ncode_block: "{" instruction+ "}"  // one or more instructions\n \n This is an accurate and fairly succinct description of our syntax. We could however make it a little shorter, by avoiding repetition. \n instruction: ("f"|"b"|"l"|"r") number\n           | "c" color [color]\n           | "fill" code_block\n           | "repeat" number code_block\n \ncode_block: "{" instruction+ "}"\n \n This variation is equivalent to the first one, just a little shorter. \n You may have noticed our grammar contains a recursion between "code_block" and "instruction". That\'s totally fine, this is what parsers live for. \n We still haven\'t defined "number" and "color". We\'ll do that next. \n Step 2) Lark \n So far, everything we did was fairly agnostic of a specific parsing library. But now is a good time to introduce Lark. \n Lark is an open-source parsing library I spent the last month writing. I know, there are dozens of other parsing libraries. Why introduce yet another one? Here\'s why: \n Lark uses the Earley parsing algorithm, a dynamic parsing algorithm that can handle all context-free grammars, including ambiguous grammars. It also supports a scannerless mode, which means terminals (tokens) are resolved by Earley at parse-time. The end result is that when you write your grammar with Lark, you don\'t have to worry about restrictions or state-machines. All grammar structures are allowed. If your grammar makes logical sense, Lark can parse it. \n Lark is the only library that can make this claim. It also accepts grammars in a convenient EBNF form. It supplies a library of common terminals (i.e. regexps), to save its users from re-inventing the wheel in every grammar. And it can build a parse-tree automatically for every grammar. \n Here ends the sales pitch, although I could go on. Let\'s look at how our grammar will look like in Lark, and I will follow with a thorough explanation: \n start: instruction+\n \ninstruction: ("f"|"b"|"l"|"r") NUMBER\n           | "c" COLOR [COLOR]\n           | "fill" code_block\n           | "repeat" NUMBER code_block\n \ncode_block: "{" instruction+ "}"\n \nCOLOR: ("a".."z")+   \nNUMBER: ("0".."9")+\nWHITESPACE: (" " | "\\n")+\n%ignore WHITESPACE\n \n (If you are following this by trying the the code, that\'s awesome! Don\'t forget to escape the \'\\n\'.) \n In the first line, we tell Lark that our program is basically a list of instructions. \n The next part is literally a copy-paste of our EBNF definition from above, only we change "color" and "number" to their terminal form, and define them. \n When names are written in uppercase in Lark, they are treated as terminals. Terminals are a little like rules: They also match input by combining smaller particles. But while rules match structure, terminals match strings. If we defined COLOR as a rule instead (lowercase color), the parser will create structure where it makes no sense (For example, Tree("r", "e", "d") instead of just the string "red"). \n Another thing about terminals is that they are greedy, which is just what we need in this case. \n Then finally, the last line tells lark to ignore whitespace. (Extra information!) \n Now it\'s time to see how we did. Let\'s run Lark on our sample language using our grammar, and see what we get: \n text = """\nc red yellow\nfill { repeat 36 {\n    f200 l170\n}}    \n"""\n \nfrom lark import Lark\nparser = Lark(turtle_grammar)  # Scannerless Earley is the default\n \nprint(parser.parse(text))\n \n We get this: \n Tree(start, [Tree(instruction, [Token(COLOR, u\'red\'), Token(COLOR, u\'yellow\')]), Tree(instruction, [Tree(code_block, [Tree(instruction, [Token(NUMBER, u\'36\'), Tree(code_block, [Tree(instruction, [Token(NUMBER, u\'200\')]), Tree(instruction, [Token(NUMBER, u\'170\')])])])])])]) \n Let\'s make it more readable: \n >>> print(parser.parse(text).pretty())\nstart\n  instruction\n    red\n    yellow\n  instruction\n    code_block\n      instruction\n        36\n        code_block\n          instruction   200\n          instruction   170\n \n This is much better! We get a tree that correctly represents the structure of our program. However, it\'s a little hard to tell, because some of the strings are missing! This is by design: Lark automatically removes anonymous strings because it assumes they are just punctuation. This is a very convenient default, and there are several ways to keep the strings. One obvious way is to make them into named terminals. Then they are no longer anonymous, and they will appear in the tree. We\'re going to do this for movement (b/f/l/r). But we don\'t really need the strings themselves, we just want to know which instruction was specified. So for the rest, we\'ll use a more elegant approach: Rename the branches, by using aliases. \n While we\'re at it, let\'s also simplify the grammar and import some of our terminals from our grammar library, instead of defining them. \n Let\'s just rewrite the grammar, since the change is fairly straight-forward: \n start: instruction+\n \ninstruction: MOVEMENT NUMBER            -> movement\n           | "c" COLOR [COLOR]          -> change_color\n           | "fill" code_block          -> fill\n           | "repeat" NUMBER code_block -> repeat\n \ncode_block: "{" instruction+ "}"\n \nMOVEMENT: "f"|"b"|"l"|"r"\nCOLOR: LETTER+\n \n%import common.LETTER\n%import common.INT -> NUMBER\n%import common.WS\n%ignore WS\n \n Imported terminals are defined using regular EBNF, just like we defined COLOR and NUMBER. You can see their definition here (common.g). \n And when we run the parser again, we get this: \n start\n  change_color\n    red\n    yellow\n  fill\n    code_block\n      repeat\n        36\n        code_block\n          movement\n            f\n            200\n          movement\n            l\n            170\n \n This parse-tree expresses exactly what we want, and nothing more. That is a good ideal to aspire to: A minimal parse-tree is a happy parse-tree! \n Now that we know how to turn free-form text in Turtle Language into a structural tree, it\'s time to write the actual interpreter! \n Interpreting the parse-tree \n The purpose of a language is to run free. Let\'s allow Turtle Language to start running. \n It\'s common practice, when interpreting code, to compile the parse-tree into byte code that can run efficiently, and is more compact. We are not troubled by such earthly concerns; our toy DSL is small and doesn\'t do much. We are going to do something a little taboo: Run by directly reading from our pretty parse tree. \n We will write a function called "run_instruction" that accepts branches of the tree, and executes them according to the branch name. \n The Tree class in Lark has two attributes: data, which may contain any value (i.e any Python object), and children, which is a mixed list of Trees and values. So, a single tree structure is just a bunch of Tree instances nested inside each other as children. The Tree.pretty() method, that we saw earlier, just prints out these two attributes in an indented format according to their nesting-level. In the context of a parse-tree, these attributes represent specific concepts: \n 1. data -> returns the name of the rule that was matched 2. children -> returns the subrules (trees) and tokens (strings) that were matched inside it. This is known as the production, or expansion. \n With that knowledge, the function itself is simple: \n import turtle\n \ndef run_instruction(t):\n    if t.data == \'change_color\':\n        turtle.color(*t.children)   # We just pass the color names as-is\n \n    elif t.data == \'movement\':\n        name, number = t.children\n        {\n            \'f\': turtle.fd,\n            \'b\': turtle.bk,\n            \'l\': turtle.lt,\n            \'r\': turtle.rt,\n        }[name](int(number))\n \n    elif t.data == \'repeat\':\n        count, block = t.children\n        for i in range(int(count)):\n            run_instruction(block)\n \n    elif t.data == \'fill\':\n        turtle.begin_fill()\n        run_instruction(t.children[0])\n        turtle.end_fill()\n \n    elif t.data == \'code_block\':\n        for cmd in t.children:\n            run_instruction(cmd)\n \n    else:\n        raise SyntaxError(\'Unknown instruction: %s\' % t.data)  \n \n This straight-forward Python code is really all we need to run the instructions. \n And now, for the main-loop: \n parser = Lark(turtle_grammar)\n \ndef run_turtle(program):\n    parse_tree = parser.parse(program)\n \n    for inst in parse_tree.children:\n        run_instruction(inst)\n \ndef main():\n    while True:\n        code = input(\'> \')\n        try:\n            run_turtle(code)\n        except Exception as e:\n            print(e)\n \n Run this under python, and you can now program interactively in the Turtle Language! \n We can also call run_turtle directly: \n run_turtle("""\nc green blue\nfill { repeat 36 {\n  f200 l170\n}}\n""")\n \n To get this unblinking eye: \n \n https://github.com/lark-parser/lark/blob/master/examples/turtle_dsl.py   \n Conclusion \n In this tutorial, we implemented a parser and an interpreter in few lines of code, and without having to know many technical details. \n We implemented a very small language, but it\'s easy to extend. Adding commands should be very simple, since the template for that already exists. Adding variables that can be used in expressions won\'t be much of a challenge either. You can see how Lark\'s calculator example does exactly that with relative ease. Combining these two grammars with a little bit of glue code, will result in something that feels like a real programming language, albeit simplistic. \n I hope I inspired to go and write a DSL for your project. If you need any help in doing so, or if Lark is missing a feature you need dearly, drop me a line and I\'ll be happy to assist you. You can reach me at erezshin at gmail com. \n', 'tags': '', 'url': 'lark.html'}, {'title': 'Kotlin', 'text': 'https://kotlinlang.org/  是最近幾年崛起的計算機程式語言. \n http://kotlinlang.org/docs/kotlin-docs.pdf  ( 中文翻譯.pdf ) \n https://www.tutorialspoint.com/kotlin/kotlin_tutorial.pdf   \n http://plugins.netbeans.org/plugin/68590/kotlin   \n https://www.uv.es/capgeminiuv/documents/Kotlin_for_Android_Development.pdf   \n https://ithelp.ithome.com.tw/users/20107165/ironman/1351  (脫魯實錄) \n http://steve-yegge.blogspot.com/2017/05/why-kotlin-is-better-than-whatever-dumb.html  ( Steve Yegge ) \n \n', 'tags': '', 'url': 'Kotlin.html'}, {'title': 'Red Lang', 'text': 'https://www.red-lang.org/   \n http://www.mycode4fun.co.uk/About-Red-Programming   \n', 'tags': '', 'url': 'Red Lang.html'}, {'title': '工具', 'text': '\n \n \n \n \n \n \n \n \n USB 可攜程式開發系統 \n 可解譯 ANSI C \n 可解譯 Python \n 可解譯 Lua \n 可攜啟動設定: \n start.bat \n @echo off\nREM 設定 y 硬碟代號與 data 目錄對應\nset Disk=y\nsubst %Disk%: "data"\nREM 設定 leo 相關對應 Home 位置\nset HomePath=%Disk%:\\home\nset HomeDrive=%Disk%:\\home\nset Home=%Disk%:\\home\nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\nREM 將後續的指令執行, 以 %Disk% 為主\n%Disk%:\nREM 設定 PYTHONPATH\nset PYTHONPATH=%Disk%:\\python36\\DLLs;%Disk%:\\python36\\Lib;%Disk%:\\python36\\Lib\\site-packages;\nset PYTHONHOME=%Disk%:\\python36\nREM for Qt and Qt Creator\nset LLVM_INSTALL_DIR=%Disk%:\\LLVM;\nset QBS_INSTALL_DIR=%Disk%:\\qbs-windows-x86_64-1.10.0;\nREM for TCL\nset TCL_LIBRARY=%Disk%:\\python36\\tcl\\tcl8.6\nset TK_LIBRARY=%Disk%:\\python36\\tcl\\tcl8.6\nREM 設定 Leo 所用的編輯器\nset LEO_EDITOR=%Disk%:\\scite\\bin\\Sc1.exe;\nset BOOST_ROOT=%Disk%:\\boost_1_66_0\\;\nREM set CMAKE_PREFIX_PATH=%Disk%:\\msys64\\mingw64\\\nREM for fossil https 連線設定\nREM 若在近端使用 fossil ui 則要蓋掉\nREM set HTTPS=on\nREM 指令搜尋路徑設定\nREM set path1=%PATH%;%Disk%:;%Disk%:\\python36;%Disk%:\\git\\bin;%Disk%:\\stunnel\\bin;%Disk%:\\sqlite-tools;%Disk%:\\python36\\Scripts;%Disk%:\\Git\\bin;%Disk%:\\vrep331;\nREM path1 is base of this portable Python3.6 system\nset path1=%Disk%:;%Disk%:\\python36;%Disk%:\\git\\bin;%Disk%:\\stunnel\\bin;%Disk%:\\sqlite-tools;%Disk%:\\python36\\Scripts;%Disk%:\\Git\\bin;%Disk%:\\vrep331;%Disk%:\\python36\\Lib\\site-packages\\PyQt5\\Qt\\bin;\nREM path2 is for pandoc and miktex\nset path2=%Disk%:\\pandoc-2.0.2;%Disk%:\\miktex_portable\\texmfs\\install\\miktex\\bin;%Disk%:\\lua-5.3.4\\bin;%Disk%:\\coreutils-5.3.0\\bin;%Disk%:\\qtcreator-4.7.0-rc1\\bin;\nREM path3 is for gcc development \nset path3=%Disk%:\\msys64\\mingw64\\bin;%Disk%:\\swigwin-3.0.12;%Disk%:\\cmake-3.10.1-win64-x64\\bin;%Disk%:\\diffutils-2.8.7-1\\bin;%Disk%:\\patch-2.5.9-7\\bin;%Disk%:\\graphviz-2.38\\bin;\nset path4=%Disk%:\\boost_1_66_0\\;%Disk%:\\Strawberry\\perl\\bin;%D%:\\jom_1_1_2;%Disk%:\\LLVM\\bin;%Disk%:\\QtCreator\\bin;%Disk%:\\vrep340_rev1;%Disk%:\\python36\\tcl\\tcl8.6;%Disk%:\\xsltproc;\nset path5=%Disk%:\\ffmpeg-20180504-dc7a8f7-win64-static\\bin;%Disk%:\\oce-0.18.1\\bin\\;%Disk%:\\oce-0.18.1\\lib\\;%Disk%:\\gnuplot\\bin;\nset JAVA_HOME=%Disk%:\\Java\\jdk1.8.0_172;\nset ANDROID_HOME=%Disk%:\\Android\\sdk;\nset path6=%Disk%:\\Java\\jdk1.8.0_172\\bin;%Disk%:\\Java\\jre1.8.0_172\\bin;%Disk%:\\Android\\AndroidStudio\\bin;%Disk%:\\Android\\sdk\\tools;%Disk%:\\Android\\sdk\\platform-tools;\nREM for Pythonocc under MSYS2 according to https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/pythonocc/z-NI9A-Vyic/8QjD81q-AwAJ\nset CSF_GraphicShr=%Disk%:\\oce-0.18.1\\bin\\TKOpenGl.dll\npath=%path%;%path1%;%path2%;%path3%;%path4%;%path5%;%path6%;\nstart /MIN %Disk%:\\scite\\bin\\Sc1.exe\nstart /MIN %Disk%:\\scite\\bin\\Sc1.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe /k "y:\\cp2018.bat"\nstart /MIN cmd.exe /k "y:\\cp2018_http_server.bat\nstart /MIN cmd.exe /k "y:\\cadp2018.bat"\nREM 啟動 Leo 編輯器\nREM %Disk%:\\python36\\python.exe %Disk%:\\launchLeo.py\nREM 啟動 stunnel\nREM start /MIN fossil.exe server -P 127.0.0.1:8080 %Disk%:\\tmp\\fossil_repo\nREM start /MIN stunnel.exe\nstart qtcreator\nExit \n stop.bat \n @echo off\nset Disk=y\nREM 關閉 SciTE\ntaskkill /IM Sc1.exe /F\nREM 關閉 python\ntaskkill /IM python.exe /F\ntaskkill /IM pythonw.exe /F\nREM 關閉 stunnel\ntaskkill /IM stunnel.exe /F\nREM 關閉 fossil\ntaskkill /IM fossil.exe /F\ntaskkill /IM sharex.exe /F\nREM 清除 log 資料\npath=%PATH%;\nREM del /Q /F  V:\\tmp\\*.*\nREM 終止虛擬硬碟與目錄的對應\nsubst %Disk%: /D\nREM 關閉 cmd 指令視窗\ntaskkill /IM cmd.exe /F\nREM taskkill /IM mingw32 /F\nEXIT \n 在 start.bat 啟動中的: \n start /MIN cmd.exe /k "y:\\cp2018.bat"\nstart /MIN cmd.exe /k "y:\\cp2018_http_server.bat"\nstart /MIN cmd.exe /k "y:\\cadp2018.bat" \n 需要 cp2018.bat, cp2018_http_server.bat 與 cadp2018.bat, 目的在隨身系統啟動時, 可以直接開啟近端網際內容管理系統. \n cp2018.bat \n cd /d c:\\2018\\cp2018\npython wsgi.py \n cp2018_http_server.bat \n cd /d c:\\2018\\cp2018\npython http-server.py \n cadp2018.bat \n cd /d c:\\2018\\cadp2018\npython wsgi.py \n 上述使用 cmd.exe /k 執行 batch 檔案的目的, 在執行完指令後, 會回應到 dos command 指令, 以便執行其下的指令. \n 同時, 在近端或區域網路維護 CMSimfly 時, 需要利用 Python 執行 Flask 框架程式, 且同時利用 cp2018_http_server.py 程式啟動 www 伺服器, 除了可以查驗靜態 CMSimfly 網頁的內容外, 也能一併檢查 reveal.js 與 Pelican Blog 的網頁內容. \n 當 reveal.js 或 Pelican Blog 希望引用 CMSimfly 內容時, 則引用其最終轉換後的靜態資料相關連結. \n 隨身系統資料管理: \n SciTE: 文字檔案編輯器與 Python, ANSI C, 及 Lua 程式解譯器. \n Leo Editor: 大綱管理器與整合程式開發環境, Python 程式解譯器. \n Qt Creator: Qt C++ 程式整合開發環境. \n Eric IDE: PyQt 程式整合開發環境. \n CMSimfly: 網際內容管理系統, 屬於電子書章節明確的三層次網際資料管理. \n Pelican: 靜態網誌產生系統, 可分類, 以關鍵字架構及時間序建立的網際流程紀錄. \n Reveal.js: 網際簡報系統,, 可引用  CMSimfly 及 Pelican Blog 內容的網際簡報系統. \n Python 非官方 Windows 模組:  https://www.lfd.uci.edu/~gohlke/pythonlibs/   \n', 'tags': '', 'url': '工具.html'}, {'title': 'Git', 'text': 'https://git-scm.com/   \n https://git-scm.com/book/zh-tw/v2   \n https://github.com/   \n http://www.globallegalchronicle.com/microsofts-7-5-billion-acquisition-of-github/   \n git 常用指令 \n git add . \n 新增所有改版內容 \n git commit -m "提交訊息, 用來辨識版本" \n 在近端提交改版內容 \n git push \n 將近端改版內容推送到遠端 \n git pull ( 比較 與 git fetch 的差異與兩者用法) \n 拉下遠端新版本內容, 在 fossil scm 使用 fossil update \n git log \n 查驗 git 提交推送紀錄 \n git status \n 查驗狀態 \n git 新增提交推送的身分綁定 \n 以 scrum1@mde.tw 註冊帳號為 scrum-1 為例: \n git config --global user.name "scrum-1" \n git config --global user.email "scrum1@mde.tw" \n 若網路直接連線過慢, 可以透過 proxy 執行 git \n git config --global http.proxy http://proxy.kmol.info:3128 \n 以上的 git config 會將設定存入 Y:/home/.gitconfig 檔案中 \n 刪除近端與遠端的 Git 分支. \n To delete a local branch \n git branch -D the_local_branch \n To remove a remote branch \n git push origin :the_remote_branch \n or \n git push origin --delete the_remote_branch \n', 'tags': '', 'url': 'Git.html'}, {'title': 'Fossil SCM', 'text': "https://www.fossil-scm.org \n Fossil SCM 是一套簡潔可靠的分散式組態管理工具, 內建網際介面, 臭蟲追蹤, 快記與技術筆記功能的單一可執行檔. \n Fossil SCM 為自由開放源軟體, 使用者可以自行在 Windows 或 Linux 環境中編譯. 例如: 在 Windows 環境, 以  MSYS2  編譯:  http://lab.kmol.info/blog/msys2_compile_fossil_scm.html \n 在 Windows 單機環境使用: \n 下載 fossil.exe:  https://www.fossil-scm.org/index.html/uv/download.html \n 解開壓縮檔案後, 可以直接在 Windows 命令列中執行 fossil.exe \n 目前 Fossil SCM 最新版為 2.6, 若配合遠端 Ubuntu 伺服器使用, 必須確認客戶端與伺服器端的 fossil 版本一致, 否則將可能造成使用上的問題. \n 查核 fossil.exe 版本: \n fossil version \n 利用 fossil help 可以列出常用指令. \n Fossil SCM 單機基本操作: \n 建立倉儲檔案 \n fossil init foo.fossil \n 表示建立一個新的倉儲專案, 且倉儲檔案名稱為 foo.fossil, 在 fossil SCM 中建立新專案時, 登入用戶名稱會成為內定的倉儲管理者, 若要指定管理者名稱, 可以附加 -A USERNAME 或 --admin-user USERNAME, 新增的倉儲就會以 USERNAME 作為管理者名稱, 且指定對應的密碼 (有關   fossil 密碼管理 ), 當使用者在近端以網際模式啟動該倉儲時 (以   fossil ui   指令) fossil SCM 會直接以管理者身份登入, 無需輸入管理者密碼. \n 以 fossil sql 指令擷取 .fossil 檔案內容 \n 使用者以 fossil init foo.fossil 建立倉儲檔案後, 可以利用 fossil 指令查驗倉儲資料庫檔案的內容. \n fossil sql -R foo.fossil \n 進入 sqlite 指令環境後, 可以利用 .schema user 查驗 user 資料表的欄位設計. \n 以 select login, pw, cap from user; \n 可以查詢目前 foo.fossil 檔案中 user 資料表 login, pw 與 cap 等3個欄位的資料內容. \n 若要更改特定 login 登入帳號的 pw 或 cap 可以使用下列 sqlite3 SQL 語法: \n update user set pw='mynewpassword' where login='myloginaccount'; \n update user set cap='s' where login='myloginaccount'; \n 倉儲 clone \n \n $ fossil clone http://your_domain_name ~/fossils/yourdb.fossil\n$ fossil open ~/fossils/foo.fossil \n 上述 fossil 指令表示要從 http://your_domain_name fossil 伺服器中, clone 倉儲檔案, 然後存在近端的 ~/fossils/yourdb.fossil 檔案中. \n \n 接下來則可以選擇適當的目錄, 以 fossil open 將 .fossil 檔案解開, 此所在目錄即為該 .fossil 倉儲的 近端工作目錄. \n Fossil SCM \n \n SQLite \n \n \n \n \n \n \n \n", 'tags': '', 'url': 'Fossil SCM.html'}, {'title': 'Leo Editor', 'text': 'http://www.leoeditor.com/   \n', 'tags': '', 'url': 'Leo Editor.html'}, {'title': 'SCiTE', 'text': 'https://www.scintilla.org/SciTE.html   \n 利用 SciTE 執行 Pelican 網誌 Markdown 轉為 html: \n SciTEUser.properties 設定 \n 以下的設定, 是將近端與遠端   Pelican   轉檔指令, 設為 Pelican-blog 與 Github-blog 下拉式功能表, 位於 Tools-Go 下方, 唯一的限制是, 當執行這兩個指令時,   SciTE   必須處於開啟 content 目錄之外的 local_publishconf.py 檔案, 因為   SciTE   會以開啟檔案所在目錄, 執行所設定的   Pelican   指令. \n import Properties\\python\nimport _platform\nimport _config\n \n#~ #  1142  Pelican-blog\ncommand.name.42.*=Pelican-blog\ncommand.42.*="pelican content -o blog -s local_publishconf.py"\n#command.subsystem.42.*=2\n#command.quiet.42.*=1\ncommand.shortcut.42.*=Ctrl+Shift+P\n \n#~ #  1143 Github-blog\ncommand.name.43.*=Github-blog\ncommand.43.*="pelican content -o blog -s publishconf.py"\n#command.subsystem.42.*=2\n#command.quiet.42.*=1\ncommand.shortcut.43.*=Ctrl+Shift+G \n \n 啟動 IPv4 或 IPv6 www 伺服器\n 當   Pelican   轉檔指令執行結束後,   SciTE   會在輸出區列出執行結束訊息, 若轉檔過程發生錯誤, 也會一併顯示. 之後為了檢視轉換完成的近端簡報或網誌檔案, 必須將原先位於   Leo Editor   button 區的按鈕 Python3 程式移出, 分別存為 .py 檔案. \n 由於原先的   Leo Editor   button 位於 users 目錄中執行, 因此轉出的 .py 檔案也存入 users 目錄中, 程式內容如下: \n users/ipv4_www_server.py 程式檔 \n #ipv4_www_server.py 存入 users 目錄\nimport os\nimport subprocess\nimport threading\nimport http.server, ssl\n \ndef domake():\n    # build directory\n    os.chdir("./../")\n    server_address = (\'localhost\', 5443)\n    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)\n    httpd.socket = ssl.wrap_socket(httpd.socket,\n                                   server_side=True,\n                                   certfile=\'localhost.crt\',\n                                   keyfile=\'localhost.key\',\n                                   ssl_version=ssl.PROTOCOL_TLSv1)\n    print(os.getcwd())\n    print("5443 https server started")\n    httpd.serve_forever()\n \n# 利用執行緒執行 https 伺服器\nmake = threading.Thread(target=domake)\nmake.start() \n users/ipv6_www_server.py 程式檔 \n #ipv6_www_server.py 存入 users 目錄\nimport os\nimport subprocess\nimport threading\nimport socket\nimport http.server, ssl\n \nclass HTTPServerV6(http.server.HTTPServer):\n    address_family = socket.AF_INET6\n \ndef domake():\n    # build directory\n    os.chdir("./../")\n    ipv6_address = \'::1\'\n    server_address = (ipv6_address, 6443)\n    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)\n    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)\n    httpd.socket = ssl.wrap_socket(httpd.socket,\n                                   server_side=True,\n                                   certfile=\'localhost.crt\',\n                                   keyfile=\'localhost.key\',\n                                   ssl_version=ssl.PROTOCOL_TLSv1)\n    print("6443 https server started")\n    httpd.serve_forever()\n \n# 利用執行緒執行 https 伺服器\nmake = threading.Thread(target=domake)\nmake.start() \n \n \n', 'tags': '', 'url': 'SCiTE.html'}, {'title': 'TinyCC', 'text': 'https://bellard.org/tcc/   \n https://github.com/jerch/python-tinycc   \n https://github.com/SasView/tinycc   \n #include <stdio.h>\n\n/* a struct with some bytes and a length */\ntypedef struct Test {\n    int length;\n    unsigned char *bytes;\n} Test;\n\n/* some globals */\n\n#ifdef STANDALONE\nTest test = {10, "standalone"};\n#else\nTest test = {26, "abcdefghijklmnopqrstuvwxyz"};\n#endif\n\nint value = 12345;\n\nint main(int argc, char **argv) {\n    int i;\n    char **pos = argv;\n\n    printf("Hello Tiny C!\\n");\n\n    /* list arguments */\n    for (i=0; i<argc; ++i, ++pos) {\n        printf("arg %d: %s\\n", i, *pos);\n    }\n\n    /* byte printing the hard way ;) */\n    printf("test.value: \'");\n    for (i=0; i<test.length; ++i)\n        printf("%c", *(test.bytes+i));\n    printf("\'");\n\n\n    if (*test.bytes == \'a\')\n        printf(" - not so impressive.\\n");\n    else if (*test.bytes == \'s\')\n        printf(" - ok.\\n");\n    else\n        printf(" - Busted!\\n");\n    return 0;\n} \n 利用 Tiny C 編譯 Tiny C \n 利用 Tiny C compiler 編譯 Windows 10 64 位元 dll 動態連結庫, 並由 Python 程式呼叫執行. \n 從  http://download.savannah.gnu.org/releases/tinycc/   下載  Win64 C 程式編譯器, 並 下載  Tiny C compiler 0.9.27版程式原始碼. 利用下列批次檔案進行編譯. \n compile.bat 檔案內容: \n echo Use TCC to compile TCC\n\nset /p VERSION= < VERSION\necho > config.h #define TCC_VERSION "%VERSION%"\n\n \necho Set CC=tcc\n \nset CC=tcc\nset target=-DTCC_TARGET_PE -DTCC_TARGET_X86_64\nset P=64\n \necho tools: tiny_impdef.exe, tiny_libmaker.exe\n \n%CC% %target% win32/tools/tiny_impdef.c -o tiny_impdef.exe\n%CC% %target% win32/tools/tiny_libmaker.c -o tiny_libmaker.exe\n \necho Compile libtcc.dll\n \nif not exist libtcc\\nul mkdir libtcc\n%CC% %target% -w -shared -DLIBTCC_AS_DLL -DONE_SOURCE libtcc.c -o libtcc.dll\ntiny_impdef libtcc.dll -o libtcc/libtcc.def\n \necho Compile tcc.exe\n \n%CC% %target% tcc.c -o tcc.exe -ltcc -Llibtcc\n \necho Compile libcc1.a\n \n%CC% %target% -c lib/libtcc1.c\n%CC% %target% -c win32/lib/crt1.c\n%CC% %target% -c win32/lib/wincrt1.c\n%CC% %target% -c win32/lib/dllcrt1.c\n%CC% %target% -c win32/lib/dllmain.c\n%CC% %target% -c win32/lib/chkstk.S\n%CC% %target% -c lib/alloca86_64.S\ntiny_libmaker lib/libtcc1.a libtcc1.o alloca86_64.o crt1.o wincrt1.o dllcrt1.o dllmain.o chkstk.o \n 編譯 dll 動態程式庫 \n 首先, 建立一個 multiply.c 程式: \n #include <stdio.h>\n \nint multiply(int, int);\n \n__declspec(dllexport) int\nmultiply(int num1, int num2)\n{\nreturn num1 * num2;\n} \n 利用下列指令, 將 multiply.c 編譯為動態連結庫 myltiply.dll \n tcc -w -shared -DLIBTCC_AS_DLL -DONE_SOURCE multiply.c -o multiply.dll \n 接著利用下列 Python3 程式, 透過 ctypes 模組導入 multiply.dll, 並且執行動態連結程式庫中的 multiply() 函式. \n import ctypes\n \nlib = ctypes.CDLL(\'multiply.dll\')\nresult = lib.multiply(3, 2)\nprint(result) \n 因為   ctypes   內建傳回值為 int, 因此若 C 對應動態連結庫輸入或傳回值為浮點數, 就必須手動宣告. \n 例如, 將上述函式的輸入與輸出均由 int 改為 float 如下: \n // multiply2.c\n#include <stdio.h>\n \nfloat multiply(float, float);\n \n__declspec(dllexport) float\nmultiply(float num1, float num2)\n{\nreturn num1 * num2;\n} \n 可利用下列指令, 將 multiply2.c 編譯為動態連結庫 myltiply2.dll \n tcc -w -shared -DLIBTCC_AS_DLL -DONE_SOURCE multiply2.c -o multiply2.dll \n 但是 Python3 程式部份就必須改為: \n import ctypes\n \nlib = ctypes.CDLL(\'multiply2.dll\')\n# By default functions are assumed to return the C int type. Other return types can be specified by setting the restype attribute of the function object.\nlib.multiply.restype = ctypes.c_float\nresult = lib.multiply(ctypes.c_float(3.0), ctypes.c_float(2.0))\nprint(result) \n 有關 Tiny C Compiler 資料位於  https://github.com/mdecourse/cp2018/tree/gh-pages/tinyc   \n \n', 'tags': '', 'url': 'TinyCC.html'}, {'title': 'Qt', 'text': 'Qt  是一個跨平台的 C++ 程式開發框架.  Qt5 提供  Qt Creator IDE  (Integrated Development Environment),  Qt Designer  GUI (Graphics User Interface) builder,   qmake  build tool,  Qt Linguist  tool,  Qt Document Assistant  等開發工具. \n Qt for Android \n 目前只能使用 Jdk 8:  https://stackoverflow.com/questions/48189272/qt-creator-android-error-platform-sdk-installed   \n Qt Creator \n Qt Creator is an integrated development environment (IDE) that provides you with tools to design and develop applications with the Qt application framework. Qt is designed for developing applications and user interfaces once and deploying them to several desktop, embedded, and mobile operating systems, such as Android and iOS. It is available for Linux, macOS and Windows operating systems. Qt Creator provides you with tools for accomplishing your tasks throughout the whole application development life-cycle, from creating a project to deploying the application to the target platforms. \n Qt Designer \n Qt Designer provides four editing modes: Widget Editing Mode, Signals and Slots Editing Mode, Buddy Editing Mode and Tab Order Editing Mode. When working with Qt Designer, you will always be in one of these four modes. To switch between modes, simply select it from the Edit menu or the toolbar. \n qmake \n The qmake tool helps simplify the build process for development projects across different platforms. It automates the generation of Makefiles so that only a few lines of information are needed to create each Makefile. You can use qmake for any software project, whether it is written with Qt or not. \n qmake generates a Makefile based on the information in a project file. Project files are created by the developer, and are usually simple, but more sophisticated project files can be created for complex projects. \n qmake contains additional features to support development with Qt, automatically including build rules for   moc   and   uic . \n qmake can also generate projects for Microsoft Visual studio without requiring the developer to change the project file. \n 參考資料: \n http://doc.qt.io/qt-5/topics-app-development.html   \n http://download.qt.io/development_releases/qtcreator/4.7/4.7.0-rc1/   \n https://www.bogotobogo.com/Qt/Qt5_TutorialHelloWorld.php   \n https://wiki.qt.io/MSYS2   \n  編程指南:  https://qtguide.ustclug.org/   \n https://qmlbook.github.io/   (QML 使用 Javascript 技術) \n', 'tags': '', 'url': 'Qt.html'}, {'title': 'Kivy', 'text': "https://kivy.org   \n Kivy 是一套可用於開發支援手機與多點觸控等自然使用者介面輸入 (Natural User Interface, NUI) 應用套件的 MIT 使用授權 Python 開放源程式框架. 利用  Kivy 開發的程式, 可以在 Android, iOS, Linux, OSX 與 Windows 操作系統中運行. \n python -m pip install kivy Pillow \n python -m pip install pygame kivy.deps.sdl2 kivy.deps.glew \n python -m pip install kivy.deps.gstreamer (not needed for pse) \n https://media.readthedocs.org/pdf/kivy/latest/kivy.pdf   \n pong.kv \n #:kivy 1.0.9\n\n<PongBall>:\n    size: 50, 50 \n    canvas:\n        Ellipse:\n            pos: self.pos\n            size: self.size          \n\n<PongPaddle>:\n    size: 25, 200\n    canvas:\n        Rectangle:\n            pos:self.pos\n            size:self.size\n\n<PongGame>:\n    ball: pong_ball\n    player1: player_left\n    player2: player_right\n    \n    canvas:\n        Rectangle:\n            pos: self.center_x - 5, 0\n            size: 10, self.height\n    \n    Label:\n        font_size: 70  \n        center_x: root.width / 4\n        top: root.top - 50\n        text: str(root.player1.score)\n        \n    Label:\n        font_size: 70  \n        center_x: root.width * 3 / 4\n        top: root.top - 50\n        text: str(root.player2.score)\n    \n    PongBall:\n        id: pong_ball\n        center: self.parent.center\n        \n    PongPaddle:\n        id: player_left\n        x: root.x\n        center_y: root.center_y\n        \n    PongPaddle:\n        id: player_right\n        x: root.width - self.width\n        center_y: root.center_y \n pong.py \n from kivy.app import App\nfrom kivy.uix.widget import Widget\nfrom kivy.properties import (\n    NumericProperty, ReferenceListProperty, ObjectProperty\n)\nfrom kivy.vector import Vector\nfrom kivy.clock import Clock\n\n\nclass PongPaddle(Widget):\n    score = NumericProperty(0)\n\n    def bounce_ball(self, ball):\n        if self.collide_widget(ball):\n            vx, vy = ball.velocity\n            offset = (ball.center_y - self.center_y) / (self.height / 2)\n            bounced = Vector(-1 * vx, vy)\n            vel = bounced * 1.1\n            ball.velocity = vel.x, vel.y + offset\n\n\nclass PongBall(Widget):\n    velocity_x = NumericProperty(0)\n    velocity_y = NumericProperty(0)\n    velocity = ReferenceListProperty(velocity_x, velocity_y)\n\n    def move(self):\n        self.pos = Vector(*self.velocity) + self.pos\n\n\nclass PongGame(Widget):\n    ball = ObjectProperty(None)\n    player1 = ObjectProperty(None)\n    player2 = ObjectProperty(None)\n\n    def serve_ball(self, vel=(4, 0)):\n        self.ball.center = self.center\n        self.ball.velocity = vel\n\n    def update(self, dt):\n        self.ball.move()\n\n        # bounce of paddles\n        self.player1.bounce_ball(self.ball)\n        self.player2.bounce_ball(self.ball)\n\n        # bounce ball off bottom or top\n        if (self.ball.y < self.y) or (self.ball.top > self.top):\n            self.ball.velocity_y *= -1\n\n        # went of to a side to score point?\n        if self.ball.x < self.x:\n            self.player2.score += 1\n            self.serve_ball(vel=(4, 0))\n        if self.ball.x > self.width:\n            self.player1.score += 1\n            self.serve_ball(vel=(-4, 0))\n\n    def on_touch_move(self, touch):\n        if touch.x < self.width / 3:\n            self.player1.center_y = touch.y\n        if touch.x > self.width - self.width / 3:\n            self.player2.center_y = touch.y\n\n\nclass PongApp(App):\n    def build(self):\n        game = PongGame()\n        game.serve_ball()\n        Clock.schedule_interval(game.update, 1.0 / 60.0)\n        return game\n\n\nif __name__ == '__main__':\n    PongApp().run() \n 參考:  \n pse 0.5.zip \n https://stackoverflow.com/questions/44219563/kivy-not-working-error-unable-to-find-any-valuable-window-provider   \n https://www.researchgate.net/project/pse-Python-Simulation-Environment   \n", 'tags': '', 'url': 'Kivy.html'}, {'title': 'Eirc IDE', 'text': '目前 Eric6 18.07 只能配合使用 Python 3.6.5, 一方面 Python 3.7.0 尚無法以 pip install pyqt5-tools 安裝, 且 Python3.7.0 在 Eric6 18.07 尚存 bugs. \n 這與 Qt 目前還無法使用 Jdk 9 與 10 的情況相同, 許多工具仍然尚未配合最新版本的 Python 與 Java 解譯或編譯工具進行更改. \n', 'tags': '', 'url': 'Eirc IDE.html'}, {'title': 'CMSimfly', 'text': 'https://github.com/chiamingyen/cmsimfly \n', 'tags': '', 'url': 'CMSimfly.html'}, {'title': 'Kmol-editor', 'text': 'https://github.com/KmolYuan/kmol-editor \n 若以  P37_adv.7z \xa0 進行編譯, 除了\xa0 \n pip install -r requirements.txt \n 之外, 還需要將 git/bin/sh.exe 改名後, 以 \n mingw32-make \n 執行編譯.', 'tags': '', 'url': 'Kmol-editor.html'}, {'title': '實習操作', 'text': '請所有學員根據 分組協同流程 說明, 複製  2018fall  倉儲, 建立各組的分組網頁, 範例:  https://cpgx.kmol.info   \n 上課實際操作影片, 將會送到  Youtube mdecourse 教學影片區 . \n 基本指令操作 \n command_shell.pdf \n Python 發展歷史 \n Python 名稱由來 \n 取自當時英國電視喜劇名稱. \n https://en.wikipedia.org/wiki/Monty_Python   \n 2018.07.12 起, Python 發明人 宣布 不再主導未來發展 \n https://hub.packtpub.com/why-guido-van-rossum-quit/   \n 如何執行 Python 程式 \n KMOL 可攜程式開發環境 \n 下載  p37.7z , 解開到 USB 隨身碟, 啟動 start.bat 即可啟動 Python 3.7.0 程式開發環境. \n Windows 10 安裝 Python 3.7.0 \n Download   Windows x86-64 executable installer  後執行標準安裝. \n Python IDE \n KMOL  使用  SciTE ,  Leo Editor  與  Eric6 , 其他團隊可能推薦使用  Pycharm . Pycharm 可攜版本:  https://sourceforge.net/projects/pycharm-portable/   \n https://www.cs.cornell.edu/courses/cs1110/2018fa/materials/python.php   \n Python 的保留關鍵字 \n 列印 Python 關鍵字 \n import keyword\nprint(keyword.kwlist) \n Python 變數命名 \n A variable can have a short name (like x and y) or a more descriptive name (age, carname, total_volume). \n Rules for Python variables: \n A variable name must start with a letter or the underscore character A variable name cannot start with a number A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ) Variable names are case-sensitive (age, Age and AGE are three different variables) \n Python 程式的內縮 \n 不同於許多其他程式語言, 利用大括號來界定執行區塊, Python 採用 4 個空白字元為一個內縮單位來界定執行區塊. \n Python 的資料列印 \n print() \n Python 內建資料型別:  https://docs.python.org/3/library/stdtypes.html   \n Python 的 for 迴圈 \n for i in range(): \n Python 的註解 \n 單行註解 # \n 多行註解 """ \n Python 的字串、整數與浮點數 \n len() \n 字串的 .lower() 與 .upper() 方法 \n int(), float() 與 str() \n Python 其他內建函式:  https://docs.python.org/3/library/functions.html   \n Python 的 List、Tuple 與 Dictionary \n Lists:  https://automatetheboringstuff.com/chapter4/   \n Python 的函式 \n python_functions.pdf \n Python 的類別 \n https://docs.python.org/3/tutorial/classes.html   \n 參考資料 \n Python Tutorial \n https://www.w3schools.com/python/default.asp   \n Think Python \n http://greenteapress.com/thinkpython2/thinkpython2.pdf   \n Python_book.pdf  (2018 版) \n How to code in Python 3.pdf \n https://www.cs.cmu.edu/~112/   \n http://stanfordpython.com/  ', 'tags': '', 'url': '實習操作.html'}, {'title': '2018Fall', 'text': '機械設計工程系教室:  https://github.com/mdecp2018   \n 進修部車輛工程系教室:  https://github.com/vecp2018   \n 以上各學員之期中報告倉儲原始檔案來自:  https://github.com/mdecourse/2018fall   \n 此倉儲系統的使用說明, 請參考: http://mde.tw/2018fall/   \n \n 自第十週起, 以六人一組籌組, 並且選擇一使用  Flask  與 (或)  PyQt5  系統, 開發分組期末專案程式. \n CMS 範例: \n \n 延伸  CMSimfly , 可以指定 images 目錄下的子目錄, 將影像檔案放入後, 可以在特定頁面中分頁顯示出所有影像檔案. \n 研究  https://github.com/mdecourse/FlatFileFlaskBlog   \n \n Math: \n https://github.com/Notgnoshi/mathemagics   \n Machine Learning: \n https://work.caltech.edu/telecourse.html   \n 其他: \n https://medium.freecodecamp.org/what-can-you-do-with-python-the-3-main-applications-518db9a68a78  ', 'tags': '', 'url': '2018Fall.html'}, {'title': 'hello.c 與 Github', 'text': '操作目的: \n 了解如何執行最簡單的 .c 程式, 了解如何修改 .c 程式碼. \n 了解如何利用 git 指令, 在新增、提交、推送不同 .c 版本之後,  如何擷取不同版本 .c 程式碼的資料. \n 了解 Github 所提供的功能與使用方法. \n 所欲解決問題: \n 程式開發過程, 如何有效管理各階段資料的歷程.  尤其當多人協同進行程式開發時, 如何精確呈現各改版內容間的差異, 讓各成員藉以迅速因應配合. \n 第一週操作影片拍攝與上傳 \n 下載 USB 可攜檔案 \n 申請 Github 帳號 \n Github 倉儲設定 \n 建立 Github 倉儲 \n 倉儲分支與 Github Pages (gh-pages 分支特性) \n 維護 Github 倉儲內容  (網際與單機操作) \n 利用 SciTE 建立 hello.c \n 以 SciTE 執行 hello.c \n 以 gcc 編譯執行 hello.c \n 將 hello.c 納入倉儲 (了解 .gitignore 與 git config, git add, git commit, git push 指令) \n 了解 git clone, Github fork 與 forked 倉儲透過 pull requests 正反更新 \n Github issues 應用', 'tags': '', 'url': 'hello.c 與 Github.html'}, {'title': 'hello.c 與 Fossil', 'text': '操作目的: \n 讓學員了解除了 git 與 Github 之外, 也可以藉由 Fossil SCM 自行打造近端與遠端的分散式版次管理系統. \n 所欲解決問題: \n 由於 Github 並未提供原始碼 , 使用者只能決定採用與否 (免費或付費), 若希望自行搭建能完整掌控的分散式版次管理, 可以採用  gitlab 社群開源版  或 Fossil SCM. \n Fossil SCM  學習 \n 有了 git 與 Github, 為何還需要  Fossil SCM ? \n 在此將 Github 視為雲端網站式的分散式版次管理應用, 雖然近端也存有對應版本, 且允許無人數限制的免費協同運作, 但是對於 Github 所提供的各項服務依賴性極高,  \n 若採用 Fossil SCM, 因為檔案小, 使用者的掌握度高, 可以在單機, 區域網路或自架的廣域網路上運行, 適合百人以內的小團隊使用. \n 建立倉儲 \n fossil init hello.fossil \n fossil ui hello.fossil 啟動倉儲的近端網際介面 \n 修改倉儲內容 \n fossil sql -R foo.fossil \n 進入 sqlite 指令環境後, 可以利用 .schema user 查驗 user 資料表的欄位設計. \n 以 select login, pw, cap from user; \n 可以查詢目前 foo.fossil 檔案中 user 資料表 login, pw 與 cap 等3個欄位的資料內容. \n 若要更改特定 login 登入帳號的 pw 或 cap 可以使用下列 sqlite3 SQL 語法: \n update user set pw=\'mynewpassword\' where login=\'myloginaccount\'; \n update user set cap=\'s\' where login=\'myloginaccount\'; \n 倉儲 clone 與 open \n fossil clone \n fossil open \n 倉儲改版新增與 commit \n fossil add . \n fossil commit (改版內容將會自動與近端及遠端倉儲同步) \n Fossil SCM doc 網際擷取 \n doc/trunk/ 可以擷取 files 檔案, trunk 為最新版本, 也可填入各版次號, 擷取各版次的對應內容 \n 操作步驟: \n fossil init hello.fossil \n fossil ui hello.fossil \n mkdir wd \n cd wd \n mkdir hello \n cd hello \n fossil open ./../../hello.fossil \n 新增 hello.c \n 以 SciTE Tools->Go 執行 \n 以 gcc 編譯執行 hello.c \n 修改 hello.c 後, 以 fossil add . 及 fossil commit -m "改版訊息" 改版 \n 新增 index.html 後, 以 fossil add, commit 改版後, 再以 fossil ui hello.fossil 啟動網際介面後, 以 localhost:8080/doc/trunk/index.html 擷取 index.html 內容. \n Fossil SCM 基本設定 \n Fossil SCM Wiki Timeline 與 upload 檔案 \n 以 C 解最大化問題: \n // 必須在演算過程中, 設法限制各變數的上下限!\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <memory.h>\n#include <time.h>\n \n// 最大族群數, NP\n#define MAXPOP  5000\n// 最大向量維度, D\n#define MAXDIM  35\n// MAXIMAPROBLEM =1 最大化 0 最小化\n#define MAXIMAPROBLEM 1\n// 最大化時 PENALITY 必須為負值, 否則為正值\n#define PENALITY -1000\n/*\n#define MAXIMAPROBLEM 0\n#define PENALITY 1000\n*/\n \n/*------Constants for rnd_uni()--------------------------------------------*/\n \n#define IM1 2147483563\n#define IM2 2147483399\n#define AM (1.0/IM1)\n#define IMM1 (IM1-1)\n#define IA1 40014\n#define IA2 40692\n#define IQ1 53668\n#define IQ2 52774\n#define IR1 12211\n#define IR2 3791\n#define NTAB 32\n#define NDIV (1+IMM1/NTAB)\n#define EPS 1.2e-7\n#define RNMX (1.0-EPS)\n \n/*------------------------Globals---------------------------------------*/\n \nlong  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */\ndouble c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];\ndouble (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];\n \n/*---------Function declarations----------------------------------------*/\n \nvoid  assignd(int D, double a[], double b[]);\ndouble rnd_uni(long *idum);    /* uniform pseudo random number generator */\ndouble extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */\n \n/*---------Function definitions-----------------------------------------*/\n// 指定向量 b 為 a\nvoid  assignd(int D, double a[], double b[])\n{\n   int j;\n   for (j=0; j<D; j++)\n   {\n      a[j] = b[j];\n   }\n}\n \n// 產生 0 ~ 1 間的亂數\ndouble rnd_uni(long *idum)\n{\n  long j;\n  long k;\n  static long idum2=123456789;\n  static long iy=0;\n  static long iv[NTAB];\n  double temp;\n \n  if (*idum <= 0)\n  {\n    if (-(*idum) < 1) *idum=1;\n    else *idum = -(*idum);\n    idum2=(*idum);\n    for (j=NTAB+7;j>=0;j--)\n    {\n      k=(*idum)/IQ1;\n      *idum=IA1*(*idum-k*IQ1)-k*IR1;\n      if (*idum < 0) *idum += IM1;\n      if (j < NTAB) iv[j] = *idum;\n    }\n    iy=iv[0];\n  }\n  k=(*idum)/IQ1;\n  *idum=IA1*(*idum-k*IQ1)-k*IR1;\n  if (*idum < 0) *idum += IM1;\n  k=idum2/IQ2;\n  idum2=IA2*(idum2-k*IQ2)-k*IR2;\n  if (idum2 < 0) idum2 += IM2;\n  j=iy/NDIV;\n  iy=iv[j]-idum2;\n  iv[j] = *idum;\n  if (iy < 1) iy += IMM1;\n  if ((temp=AM*iy) > RNMX) return RNMX;\n  else return temp;\n \n}/*------End of rnd_uni()--------------------------*/\n \n// 將上下限轉為全域變數\ndouble inibound_h;      /* upper parameter bound              */\ndouble inibound_l;      /* lower parameter bound              */\n// 與機構合成相關的全域變數\n// 宣告一個座標結構\nstruct Coord {\n    double x;\n    double y;\n  // 這裡保留 double z;\n};\n \nmain(int argc, char *argv[])\n{\n   char  chr;             /* y/n choice variable                */\n   char  *strat[] =       /* strategy-indicator                 */\n   {\n            "",\n            "DE/best/1/exp",\n            "DE/rand/1/exp",\n            "DE/rand-to-best/1/exp",\n            "DE/best/2/exp",\n            "DE/rand/2/exp",\n            "DE/best/1/bin",\n            "DE/rand/1/bin",\n            "DE/rand-to-best/1/bin",\n            "DE/best/2/bin",\n            "DE/rand/2/bin"\n   };\n \n   int   i, j, L, n;      /* counting variables                 */\n   int   r1, r2, r3, r4;  /* placeholders for random indexes    */\n   int   r5;              /* placeholders for random indexes    */\n   int   D;               /* Dimension of parameter vector      */\n   int   NP;              /* number of population members       */\n   int   imin;            /* index to member with lowest energy */\n   int   refresh;         /* refresh rate of screen output      */\n   int   strategy;        /* choice parameter for screen output */\n   int   gen, genmax, seed;   \n \n   long  nfeval;          /* number of function evaluations     */\n \n   double trial_cost;      /* buffer variable                    */\n   // 將上下限轉為全域變數, 可能要根據各變數加以設定\n   //double inibound_h;      /* upper parameter bound              */\n   //double inibound_l;      /* lower parameter bound              */\n   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */\n   double cost[MAXPOP];    /* obj. funct. values                 */\n   double cvar;            /* computes the cost variance         */\n   double cmean;           /* mean cost                          */\n   double F,CR;            /* control variables of DE            */\n   double cmin;            /* help variables                     */\n \n   FILE  *fpin_ptr;\n   FILE  *fpout_ptr;\n \n// 計算執行過程所需時間起點, 需要導入 time.h\n  clock_t start = clock();\n \n/*------Initializations----------------------------*/\n \n// 將結果寫入 out.dat\n fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */\n// 目前已經採用 strategy 3 可以得到最佳結果\n  strategy = 3;\n  genmax = 2000;\n  refresh = 100;\n  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值\n  D = 2;\n  NP = 200;\n  inibound_h = 50.;\n  inibound_l = 0.;\n/*得到最佳解\n  F = 0.85;\nCR 必須介於 0 to 1. 之間\n  CR = 1.;\n*/\n  F = 0.85;\n  CR = 1.;\n  seed = 3;\n \n //fclose(fpin_ptr);\n \n/*-----Checking input variables for proper range----------------------------*/\n \n  if (D > MAXDIM)\n  {\n     printf("\\nError! D=%d > MAXDIM=%d\\n",D,MAXDIM);\n     exit(1);\n  }\n  if (D <= 0)\n  {\n     printf("\\nError! D=%d, should be > 0\\n",D);\n     exit(1);\n  }\n  if (NP > MAXPOP)\n  {\n     printf("\\nError! NP=%d > MAXPOP=%d\\n",NP,MAXPOP);\n     exit(1);\n  }\n  if (NP <= 0)\n  {\n     printf("\\nError! NP=%d, should be > 0\\n",NP);\n     exit(1);\n  }\n  if ((CR < 0) || (CR > 1.0))\n  {\n     printf("\\nError! CR=%f, should be ex [0,1]\\n",CR);\n     exit(1);\n  }\n  if (seed <= 0)\n  {\n     printf("\\nError! seed=%d, should be > 0\\n",seed);\n     exit(1);\n  }\n  if (refresh <= 0)\n  {\n     printf("\\nError! refresh=%d, should be > 0\\n",refresh);\n     exit(1);\n  }\n  if (genmax <= 0)\n  {\n     printf("\\nError! genmax=%d, should be > 0\\n",genmax);\n     exit(1);\n  }\n  if ((strategy < 0) || (strategy > 10))\n  {\n     printf("\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n",strategy);\n     exit(1);\n  }\n  if (inibound_h < inibound_l)\n  {\n     printf("\\nError! inibound_h=%f < inibound_l=%f\\n",inibound_h, inibound_l);\n     exit(1);\n  }\n \n/*-----Initialize random number generator-----------------------------*/\n \n rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */\n nfeval       =  0;  /* reset number of function evaluations */\n \n/*------Initialization------------------------------------------------*/\n/*------Right now this part is kept fairly simple and just generates--*/\n/*------random numbers in the range [-initfac, +initfac]. You might---*/\n/*------want to extend the init part such that you can initialize-----*/\n/*------each parameter separately.------------------------------------*/\n \n   for (i=0; i<NP; i++)\n   {\n      for (j=0; j<D; j++) /* spread initial population members */\n      {\n        c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l);\n      }\n      cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */\n   }\n   cmin = cost[0];\n   imin = 0;\n   for (i=1; i<NP; i++)\n   {\n     if(MAXIMAPROBLEM == 1)\n     {\n       // 改為最大化\n        if (cost[i]>cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n      else\n      {\n        // 最小化問題\n        if (cost[i]<cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n   }\n \n   assignd(D,best,c[imin]);            /* save best member ever          */\n   assignd(D,bestit,c[imin]);          /* save best member of generation */\n \n   pold = &c; /* old population (generation G)   */\n   pnew = &d; /* new population (generation G+1) */\n \n/*=======================================================================*/\n/*=========Iteration loop================================================*/\n/*=======================================================================*/\n \n   gen = 0;                          /* generation counter reset */\n   while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */\n   {                                            /* is accepted by compiler    */\n      gen++;\n      imin = 0;\n \n      for (i=0; i<NP; i++)         /* Start of loop through ensemble  */\n      {\n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 2 !!!     */\n       r1 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while(r1==i);            \n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 3 !!!     */\n       r2 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r2==i) || (r2==r1));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 4 !!!     */\n       r3 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r3==i) || (r3==r1) || (r3==r2));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 5 !!!     */\n       r4 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 6 !!!     */\n       r5 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));\n \n/*=======EXPONENTIAL CROSSOVER============================================================*/\n \n/*-------DE/best/1/exp--------------------------------------------------------------------*/\n/*-------Our oldest strategy but still not bad. However, we have found several------------*/\n/*-------optimization problems where misconvergence occurs.-------------------------------*/\n     if (strategy == 1) /* strategy DE0 (not in our paper) */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/1/exp-------------------------------------------------------------------*/\n/*-------This is one of my favourite strategies. It works especially well when the-------*/\n/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/\n/*-------as a first guess.---------------------------------------------------------------*/\n     else if (strategy == 2) /* strategy DE1 in the techreport */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/\n/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/\n/*-------If you get misconvergence try to increase NP. If this doesn\'t help you----------*/\n/*-------should play around with all three control variables.----------------------------*/\n     else if (strategy == 3) /* similiar to DE2 but generally better */\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                       \n         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/\n     else if (strategy == 4)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/\n     else if (strategy == 5)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n \n/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/\n \n/*-------DE/best/1/bin--------------------------------------------------------------------*/\n     else if (strategy == 6) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/1/bin-------------------------------------------------------------------*/\n     else if (strategy == 7) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/\n     else if (strategy == 8) \n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/best/2/bin--------------------------------------------------------------------*/\n     else if (strategy == 9)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/2/bin--------------------------------------------------------------------*/\n     else\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n \n \n/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/\n \n     trial_cost = evaluate(D,tmp,&nfeval);  /* Evaluate new vector in tmp[] */\n   if(MAXIMAPROBLEM == 1)\n   {\n    // 改為最大化\n       if (trial_cost >= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost>cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n    else\n    {\n          // 最小化問題\n       if (trial_cost <= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost<cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n \n      }   /* End mutation loop through pop. */\n \n      assignd(D,bestit,best);  /* Save best population member of current iteration */\n \n      /* swap population arrays. New generation becomes old one */\n \n      pswap = pold;\n      pold  = pnew;\n      pnew  = pswap;\n \n/*----Compute the energy variance (just for monitoring purposes)-----------*/\n \n      cmean = 0.;          /* compute the mean value first */\n      for (j=0; j<NP; j++)\n      {\n         cmean += cost[j];\n      }\n      cmean = cmean/NP;\n \n      cvar = 0.;           /* now the variance              */\n      for (j=0; j<NP; j++)\n      {\n         cvar += (cost[j] - cmean)*(cost[j] - cmean);\n      }\n      cvar = cvar/(NP-1);\n \n \n/*----Output part----------------------------------------------------------*/\n \n      if (gen%refresh==1)   /* display after every refresh generations */\n      { /* ABORT works only if conio.h is accepted by your compiler */\n    printf("\\n\\n                         PRESS ANY KEY TO ABORT"); \n    printf("\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n",cmin);\n \n    for (j=0;j<D;j++)\n    {\n      printf("\\n best[%d]=%-15.10g",j,best[j]);\n    }\n    printf("\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n    printf("\\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\\n",\n               NP,F,CR,cvar);\n      }\n \n      fprintf(fpout_ptr,"%ld   %-15.10g\\n",nfeval,cmin);\n   }\n/*=======================================================================*/\n/*=========End of iteration loop=========================================*/\n/*=======================================================================*/\n \n/*-------Final output in file-------------------------------------------*/\n \n \n   fprintf(fpout_ptr,"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n",cmin);\n \n   for (j=0;j<D;j++)\n   {\n     fprintf(fpout_ptr,"\\n best[%d]=%-15.10g",j,best[j]);\n   }\n   fprintf(fpout_ptr,"\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n   fprintf(fpout_ptr,"\\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\\n",\n           NP,F,CR,cvar); \n \n  fclose(fpout_ptr);\n \n  /* Code you want timed here */\n  printf("Time elapsed: %f\\n", ((double)clock() - start) / CLOCKS_PER_SEC);\n   return(0);\n}\n \n/*-----------End of main()------------------------------------------*/\n \n// 適應函式 fittness function (cost function)\ndouble evaluate(int D, double tmp[], long *nfeval)\n{\n   double result=0, surface = 80.0, z, volume, penality;\n   (*nfeval)++;\n   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));\n   volume = tmp[0]*tmp[1]*z;\n \n  if(volume <= 0){\n    return PENALITY;\n  }\n// 只限制長度與寬度必須大於 0\n  if(tmp[0] <= inibound_l){\n    return PENALITY;\n  }\n \n  if(tmp[1] <= inibound_l){\n    return PENALITY;\n  }\n/*\n  if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){\n    return PENALITY;\n  }\n \n  if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){\n    return PENALITY;\n  }\n  */\n  // volume must >0 and max volume\n  // 目前為最小化問題\n   //return 1+1/(volume*volume);\n  return volume;\n}\n  \n \n', 'tags': '', 'url': 'hello.c 與 Fossil.html'}, {'title': 'CMSimfly 操作', 'text': '操作目的: \n 讓學員透過  https://github.com/chiamingyen/cmsimfly  的程式編寫架構與使用, 了解如何利用 Python 與  Flask 網際框架, 自行建構網際內容管理系統. \n 所欲解決問題: \n 機械設計工程師若能將協同產品設計流程搬至網際環境, 將可有效提升設計效能. \n 本課程即使用 CMSimfly 管理與教學內容相關的資料管理. \n 取得  p37.7z  檔案後, 解開後容量約 1GB. 放入 USB 隨身碟, 以 start.bat 啟動系統. \n 取得  Qt 可攜系統 .7z  檔案後, 解開後容量約 21 GB. 放入 USB 隨身碟, 以 start.bat (必須配合修改 CMSimfly 所在位置)啟動系統. \n 以瀏覽器開啟 https://localhost:8443 後, 以管理者密碼登入 CMSimfly. \n 由於 CMSimfly 頁面依照 h1, h2, h3 標註循序存入 content.htm, 使用者必須按照由上到下的順序建立所需頁面. \n 完成各階段改版後, 必須點擊 generate_pages 進行轉檔, 將 content.htm 內容分頁存靜態網站於 content 目錄中. \n CMSimfly 靜態網頁模式將從根目錄的 index.html 跳轉頁面至 content 目錄中的 index.html, 顯示網際內容管理中的資料, 並由 blog 目錄導引網誌內容, reveal 目錄則導引網際投影片內容. \n Python 程式檢定題庫 \n 來源:   http://www.im.cyut.edu.tw/html/html/board/p_test/ptest_board.htm   \n cyut_python_quiz_1.pdf  (進修部) \n cyut_python_quiz_2.pdf  (日間部) \n \n 請日夜間部各計算機程式課程學員, 以學號在  Github  登記帳號 \n 建立一個 學號.github.io 倉儲 ( 參考 ) \n 在倉儲中納入  CMSimfly  +  reveal.js  +  Pelican blog  系統 \n 啟動  Brython  網際 Python 系統 \n 日間部學員將  cyut_python_quiz_2.pdf  中各題目的程式配置在個人的 學號.github.io 網頁中 \n 夜間部學員將  cyut_python_quiz_1.pdf  中各題目的程式配置在個人的 學號.github.io 網頁中 \n 請各學員在每週上課結束後, 利用 學號.github.io/blog/ 紀錄學習歷程 \n 請各學員在每週上課結束後, 利用 學號.github.io/reveal/ 進行網際學習簡報 \n \n 備註: \n 除了在  Github  系統中建立 學號.github.io 網站外, 也可以自行利用  Fossil SCM , 在系上協同設計室中的伺服器, 建立與  Github Pages  同等功能的  Fossil doc  網站. (欲額外自建伺服器之學員, 請洽計算機程式課程助教) \n 參考資料 \n 2016 Python Recipes Handbook \n https://link.springer.com/book/10.1007/978-1-4842-0241-8   \n 2015 Algorithmic Problem Solving with Python.pdf \n \n', 'tags': '', 'url': 'CMSimfly 操作.html'}, {'title': 'Pygrouf 操作', 'text': '操作目的: \n 讓學員了解如何利用 Python、Flask 網際框架與 MySQL (SQLite 或 PostgreSQL) 資料庫管理群組產品開發過程中的資料. \n 所欲解決的問題: \n 如何透過 oauth2 登入系統, 如何透過 peewee ORM 存取 MySQL, SQLite 或 PostgreSQL 等資料庫內容. \n 如何整合 Flask Server 與 tinymce4 Javascript, 提供群組軟體伺服端與瀏覽器端的資料整合. \n https://github.com/chiamingyen/pygrouf   \n 需要以下模組: \n pymysql \n authomatic \n mako \n peewee \n oauth2 綁定: \n 使用 2016springwcm 郵件帳號登記憑證 \n 登入後連結  https://console.developers.google.com \n 以 https://localhost:6443 啟動 \n 若希望在區域或廣域網路啟動, 則需設定啟動 callback 與 /login 連結. \n', 'tags': '', 'url': 'Pygrouf 操作.html'}, {'title': 'Pelican 操作', 'text': '操作目的: \n 讓學員了解如何利用 Python、Pelican 與 Leo Editor 建立靜態網誌. \n 所欲解決問題: \n 機械設計工程師如何透過網際日誌, 詳實紀錄與產品開發有關的資料. \n 位於 markdown 目錄為 Pelican 網誌的原始檔案, 轉檔後將網誌存入 blog 目錄, 並需要 theme 與 plugin 目錄, 以及  local_publishconf.py, pelicanconf.py 與 publishconf.py 等設定檔案. \n pelican.leo 位於 config/pelican.leo 目錄, 用於 Pelican 靜態網誌 markdown 目錄中輸入 .md  檔案與 Pelican 設定檔案的編輯管理與轉檔. \n', 'tags': '', 'url': 'Pelican 操作.html'}, {'title': 'Reveal.js 操作', 'text': '操作目的: \n 讓學員能夠利用網際資料進行簡報. \n 所欲解決問題: \n 如何利用網際無遠弗屆與超文件資料的特性, 有效展示與產品開發有關的簡報資料. \n 位於 reveal 目錄中為  reveal.js  網際投影片系統, 改版時利用 cmsimfly.leo 中的 "編輯 reveal" 節點進行. \n 啟動 Leo Editor, 以 SciTE 編輯器開啟 y:\\launchLeo.py 後, 用 Tools -> Go 執行, 接著以 File -> Open-Outline 開啟 cmsimfly.leo \n 投影片內容: \n <section data-markdown>\n    <script type="text/template">\n@others\n    </script>\n</section> \n 而 @others  內容: \n # 投影片快捷鍵\n\n* 利用箭頭上下前後換頁\n* 按 f 鍵進入全螢幕模式 (full screen)\n* 按 s 鍵可以顯示投影片筆記 (show)\n* 按 o 鍵可以切換單張或全域檢視 (overview)\n* 按 b 或 . 鍵可以切換螢幕黑屏 (black)\n* 按 Esc 可以退出全螢幕或全域檢視 (Escape) \n 其中, 單層 section 標註為向右展開的網際投影片, 而雙層 section 標註的投影片, 則向下展開. \n', 'tags': '', 'url': 'Reveal.js 操作.html'}, {'title': '數值分析', 'text': '操作目的: \n 讓學員了解如何利用電腦程式解數學問題. \n 所欲解決問題: \n 如何結合計算機程式與微積分及工程數學, 解決工程設計所可能面臨的問題. \n Numerical Analysis \n 何謂微分方程 (取自 Wikipedia:  微分方程 )? 如何 應用 ? \n 微分方程 (Differential equation) 是一種數學方程, 用來描述某一類函數與其導數之間的關係. 微分方程的解是一個符合方程的函數.  \n 微分方程的應用十分廣泛, 可以解決許多與導數有關的問題. 物理中許多涉及變力的運動學、動力學問題, 如空氣的阻力為速度函數的落體運動等問題, 很多可以用微分方程求解.  \n 只有少數簡單的微分方程可以求得解析解. 不過即使沒有找到其解析解. 仍然可以確認其解的部份性質. 在無法求得解析解時, 可以利用數值分析的方式, 利用電腦來找到其數值解. 動力系統理論強調對於微分方程系統的量化分析. 而許多數值方法可以計算微分方程的數值解, 且有一定的準確度. \n 解微分方程式: \n Euler\'s Method:  http://tutorial.math.lamar.edu/Classes/DE/EulersMethod.aspx   \n Runge-Kutta Method:  https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods   \n ANSI C 與  gnuplot : \n /* Runge Kutta for a set of first order differential equations */\n \n#include <stdio.h>\n#include <math.h>\n \n#define N 2 /* number of first order equations */\n#define dist 0.1 /* stepsize in t*/\n#define MAX 30.0 /* max for t */\n \nFILE *output; /* internal filename */\nFILE *output1; /* internal filename */\n// 利用 pipe 呼叫 gnuplot 繪圖\nFILE *pipe;\n \nvoid runge4(double x, double y[], double step); /* Runge-Kutta function */\ndouble f(double x, double y[], int i); /* function for derivatives */\n \nvoid main(){\n \n  double t, y[N];\n  int j;\n \n  output=fopen("osc.dat", "w"); /* external filename */\n  output1=fopen("osc1.dat", "w"); /* external filename */\n \n  y[0]=1.0; /* initial position */\n  y[1]=0.0; /* initial velocity */\n \n  //fprintf(output, "0\\t%f\\n", y[0]);\n \n  for (j=1; j*dist<=MAX ;j++) /* time loop */{\n \n    t=j*dist;\n    runge4(t, y, dist);\n    fprintf(output, "%f\\t%f\\n", t, y[0]);\n    fprintf(output1, "%f\\t%f\\n", t, y[1]);\n  }\n \n  fclose(output);\n  fclose(output1);\n \n  pipe = popen("gnuplot -persist","w");\n  //fprintf(pipe,"set term png enhanced font \\"v:/fireflysung.ttf\\" 18 \\n");\n  fprintf(pipe,"set term png enhanced font \\"y:/wqy-microhei.ttc\\" 18 \\n");\n  //fprintf(pipe,"set yrange [68:70]\\n");\n  fprintf(pipe,"set output \\"test.png\\"\\n");\n  fprintf(pipe, "plot \\"osc.dat\\" title \\"位移\\" with lines, \\"osc1.dat\\" title \\"速度\\" with lines\\n");\n  fprintf(pipe,"quit\\n");\n\n  fprintf(pipe,"quit\\n");\n  pclose(pipe);\n}\n \nvoid runge4(double x, double y[], double step){\n \n  double h=step/2.0, /* the midpoint */\n  t1[N], t2[N], t3[N], /* temporary storage arrays */\n  k1[N], k2[N], k3[N],k4[N]; /* for Runge-Kutta */\n  int i;\n \n  for (i=0;i<N;i++){\n \n    t1[i]=y[i]+0.5*(k1[i]=step*f(x,y,i));\n  }\n \n  for (i=0;i<N;i++){\n \n    t2[i]=y[i]+0.5*(k2[i]=step*f(x+h, t1, i));\n  }\n \n  for (i=0;i<N;i++){\n \n    t3[i]=y[i]+ (k3[i]=step*f(x+h, t2, i));\n  }\n \n  for (i=0;i<N;i++){\n \n    k4[i]= step*f(x+step, t3, i);\n  }\n \n  for (i=0;i<N;i++){\n \n    y[i]+=(k1[i]+2*k2[i]+2*k3[i]+k4[i])/6.0;\n  }\n}\n \ndouble f(double x, double y[], int i){\n \n  if (i==0)\n    x=y[1]; /* derivative of first equation */\n  if (i==1)\n    x=-y[0]-0.5*y[1];\n  return x;\n} \n Python: \n from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    print(vx, vy)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print("%4.1f %10.5f %+12.4e" % (x, y, y - (4 + x * x)**2 / 16)) \n 也是 Python: \n def rk4(x, v, a, dt):\n    """Returns final (position, velocity) tuple after\n    time dt has passed.\n\n    x: initial position (number-like object)\n    v: initial velocity (number-like object)\n    a: acceleration function a(x,v,dt) (must be callable)\n    dt: timestep (number)"""\n    x1 = x\n    v1 = v\n    a1 = a(x1, v1, 0)\n\n    x2 = x + 0.5*v1*dt\n    v2 = v + 0.5*a1*dt\n    a2 = a(x2, v2, dt/2.0)\n\n    x3 = x + 0.5*v2*dt\n    v3 = v + 0.5*a2*dt\n    a3 = a(x3, v3, dt/2.0)\n\n    x4 = x + v3*dt\n    v4 = v + a3*dt\n    a4 = a(x4, v4, dt)\n\n    xf = x + (dt/6.0)*(v1 + 2*v2 + 2*v3 + v4)\n    vf = v + (dt/6.0)*(a1 + 2*a2 + 2*a3 + a4)\n\n    return xf, vf\n    \ndef accel(x, v, dt):\n    """Determines acceleration from current position,\n    velocity, and timestep. This particular acceleration\n    function models a spring."""\n    stiffness = 1\n    damping = -0.005\n    return -stiffness*x - damping*v\n\nt = 0\ndt = 1.0/4000 # Timestep of 1/40 second\nstate = 50, 5 # Position, velocity\neuler = 50, 5 # For comparison with Euler integration\n\nprint("Initial    -position: %6.2f, velocity: %6.2f"%state)\n\n# Run for 100 seconds\nwhile t < 100:\n    t += dt\n    state = rk4(state[0], state[1], accel, dt)\n    #print(t, state)\n\n    # Integrate using Euler\'s method\n    euler = (\n        euler[0] + euler[1]*dt,\n        euler[1] + accel(euler[0],euler[1],dt)*dt\n    )\n\nprint("Final RK4  -position: %6.2f, velocity: %6.2f"%state)\nprint("Final Euler-position: %6.2f, velocity: %6.2f"%euler) \n 練習步驟: \n \n 請說明何謂微分方程式? \n 微分方程式用在機械設計的哪個領域? \n 何謂微分方程式的解析解與數值分析解? \n 請說明何謂 Euler\'s Method? 如何用來解微分方程式? \n 請說明何謂 Runge-Kutta Method? 如何用 C 與 Python 編寫 Runge-Kutta 數值分析程式? \n 請將上述 ANSI C 的程式, 改為 Python, 用  gnuplot  繪出位移與速度圖. \n \n SWIG C++ 與 Python 實際操作練習 \n SWIG C++ 與 Python 實際操作練習二 \n SWIG 練習三 \n SWIG 練習四 -  Python Solvespace \n 利用  Differential Evolution  algorithm 解題: \n ANSI C 版本: \n // 必須在演算過程中, 設法限制各變數的上下限!\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <memory.h>\n#include <time.h>\n \n// 最大族群數, NP\n#define MAXPOP  5000\n// 最大向量維度, D\n#define MAXDIM  35\n// MAXIMAPROBLEM =1 最大化 0 最小化\n#define MAXIMAPROBLEM 1\n// 最大化時 PENALITY 必須為負值, 否則為正值\n#define PENALITY -1000\n/*\n#define MAXIMAPROBLEM 0\n#define PENALITY 1000\n*/\n \n/*------Constants for rnd_uni()--------------------------------------------*/\n \n#define IM1 2147483563\n#define IM2 2147483399\n#define AM (1.0/IM1)\n#define IMM1 (IM1-1)\n#define IA1 40014\n#define IA2 40692\n#define IQ1 53668\n#define IQ2 52774\n#define IR1 12211\n#define IR2 3791\n#define NTAB 32\n#define NDIV (1+IMM1/NTAB)\n#define EPS 1.2e-7\n#define RNMX (1.0-EPS)\n \n/*------------------------Globals---------------------------------------*/\n \nlong  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */\ndouble c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];\ndouble (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];\n \n/*---------Function declarations----------------------------------------*/\n \nvoid  assignd(int D, double a[], double b[]);\ndouble rnd_uni(long *idum);    /* uniform pseudo random number generator */\ndouble extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */\n \n/*---------Function definitions-----------------------------------------*/\n// 指定向量 b 為 a\nvoid  assignd(int D, double a[], double b[])\n{\n   int j;\n   for (j=0; j<D; j++)\n   {\n      a[j] = b[j];\n   }\n}\n \n// 產生 0 ~ 1 間的亂數\ndouble rnd_uni(long *idum)\n{\n  long j;\n  long k;\n  static long idum2=123456789;\n  static long iy=0;\n  static long iv[NTAB];\n  double temp;\n \n  if (*idum <= 0)\n  {\n    if (-(*idum) < 1) *idum=1;\n    else *idum = -(*idum);\n    idum2=(*idum);\n    for (j=NTAB+7;j>=0;j--)\n    {\n      k=(*idum)/IQ1;\n      *idum=IA1*(*idum-k*IQ1)-k*IR1;\n      if (*idum < 0) *idum += IM1;\n      if (j < NTAB) iv[j] = *idum;\n    }\n    iy=iv[0];\n  }\n  k=(*idum)/IQ1;\n  *idum=IA1*(*idum-k*IQ1)-k*IR1;\n  if (*idum < 0) *idum += IM1;\n  k=idum2/IQ2;\n  idum2=IA2*(idum2-k*IQ2)-k*IR2;\n  if (idum2 < 0) idum2 += IM2;\n  j=iy/NDIV;\n  iy=iv[j]-idum2;\n  iv[j] = *idum;\n  if (iy < 1) iy += IMM1;\n  if ((temp=AM*iy) > RNMX) return RNMX;\n  else return temp;\n \n}/*------End of rnd_uni()--------------------------*/\n \n// 將上下限轉為全域變數\ndouble inibound_h;      /* upper parameter bound              */\ndouble inibound_l;      /* lower parameter bound              */\n// 與機構合成相關的全域變數\n// 宣告一個座標結構\nstruct Coord {\n    double x;\n    double y;\n  // 這裡保留 double z;\n};\n \nmain(int argc, char *argv[])\n{\n   char  chr;             /* y/n choice variable                */\n   char  *strat[] =       /* strategy-indicator                 */\n   {\n            "",\n            "DE/best/1/exp",\n            "DE/rand/1/exp",\n            "DE/rand-to-best/1/exp",\n            "DE/best/2/exp",\n            "DE/rand/2/exp",\n            "DE/best/1/bin",\n            "DE/rand/1/bin",\n            "DE/rand-to-best/1/bin",\n            "DE/best/2/bin",\n            "DE/rand/2/bin"\n   };\n \n   int   i, j, L, n;      /* counting variables                 */\n   int   r1, r2, r3, r4;  /* placeholders for random indexes    */\n   int   r5;              /* placeholders for random indexes    */\n   int   D;               /* Dimension of parameter vector      */\n   int   NP;              /* number of population members       */\n   int   imin;            /* index to member with lowest energy */\n   int   refresh;         /* refresh rate of screen output      */\n   int   strategy;        /* choice parameter for screen output */\n   int   gen, genmax, seed;   \n \n   long  nfeval;          /* number of function evaluations     */\n \n   double trial_cost;      /* buffer variable                    */\n   // 將上下限轉為全域變數, 可能要根據各變數加以設定\n   //double inibound_h;      /* upper parameter bound              */\n   //double inibound_l;      /* lower parameter bound              */\n   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */\n   double cost[MAXPOP];    /* obj. funct. values                 */\n   double cvar;            /* computes the cost variance         */\n   double cmean;           /* mean cost                          */\n   double F,CR;            /* control variables of DE            */\n   double cmin;            /* help variables                     */\n \n   FILE  *fpin_ptr;\n   FILE  *fpout_ptr;\n \n// 計算執行過程所需時間起點, 需要導入 time.h\n  clock_t start = clock();\n \n/*------Initializations----------------------------*/\n \n// 將結果寫入 out.dat\n fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */\n// 目前已經採用 strategy 3 可以得到最佳結果\n  strategy = 3;\n  genmax = 2000;\n  refresh = 100;\n  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值\n  D = 2;\n  NP = 200;\n  inibound_h = 50.;\n  inibound_l = 0.;\n/*得到最佳解\n  F = 0.85;\nCR 必須介於 0 to 1. 之間\n  CR = 1.;\n*/\n  F = 0.85;\n  CR = 1.;\n  seed = 3;\n \n //fclose(fpin_ptr);\n \n/*-----Checking input variables for proper range----------------------------*/\n \n  if (D > MAXDIM)\n  {\n     printf("\\nError! D=%d > MAXDIM=%d\\n",D,MAXDIM);\n     exit(1);\n  }\n  if (D <= 0)\n  {\n     printf("\\nError! D=%d, should be > 0\\n",D);\n     exit(1);\n  }\n  if (NP > MAXPOP)\n  {\n     printf("\\nError! NP=%d > MAXPOP=%d\\n",NP,MAXPOP);\n     exit(1);\n  }\n  if (NP <= 0)\n  {\n     printf("\\nError! NP=%d, should be > 0\\n",NP);\n     exit(1);\n  }\n  if ((CR < 0) || (CR > 1.0))\n  {\n     printf("\\nError! CR=%f, should be ex [0,1]\\n",CR);\n     exit(1);\n  }\n  if (seed <= 0)\n  {\n     printf("\\nError! seed=%d, should be > 0\\n",seed);\n     exit(1);\n  }\n  if (refresh <= 0)\n  {\n     printf("\\nError! refresh=%d, should be > 0\\n",refresh);\n     exit(1);\n  }\n  if (genmax <= 0)\n  {\n     printf("\\nError! genmax=%d, should be > 0\\n",genmax);\n     exit(1);\n  }\n  if ((strategy < 0) || (strategy > 10))\n  {\n     printf("\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n",strategy);\n     exit(1);\n  }\n  if (inibound_h < inibound_l)\n  {\n     printf("\\nError! inibound_h=%f < inibound_l=%f\\n",inibound_h, inibound_l);\n     exit(1);\n  }\n \n/*-----Initialize random number generator-----------------------------*/\n \n rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */\n nfeval       =  0;  /* reset number of function evaluations */\n \n/*------Initialization------------------------------------------------*/\n/*------Right now this part is kept fairly simple and just generates--*/\n/*------random numbers in the range [-initfac, +initfac]. You might---*/\n/*------want to extend the init part such that you can initialize-----*/\n/*------each parameter separately.------------------------------------*/\n \n   for (i=0; i<NP; i++)\n   {\n      for (j=0; j<D; j++) /* spread initial population members */\n      {\n        c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l);\n      }\n      cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */\n   }\n   cmin = cost[0];\n   imin = 0;\n   for (i=1; i<NP; i++)\n   {\n     if(MAXIMAPROBLEM == 1)\n     {\n       // 改為最大化\n        if (cost[i]>cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n      else\n      {\n        // 最小化問題\n        if (cost[i]<cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n   }\n \n   assignd(D,best,c[imin]);            /* save best member ever          */\n   assignd(D,bestit,c[imin]);          /* save best member of generation */\n \n   pold = &c; /* old population (generation G)   */\n   pnew = &d; /* new population (generation G+1) */\n \n/*=======================================================================*/\n/*=========Iteration loop================================================*/\n/*=======================================================================*/\n \n   gen = 0;                          /* generation counter reset */\n   while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */\n   {                                            /* is accepted by compiler    */\n      gen++;\n      imin = 0;\n \n      for (i=0; i<NP; i++)         /* Start of loop through ensemble  */\n      {\n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 2 !!!     */\n       r1 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while(r1==i);            \n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 3 !!!     */\n       r2 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r2==i) || (r2==r1));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 4 !!!     */\n       r3 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r3==i) || (r3==r1) || (r3==r2));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 5 !!!     */\n       r4 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 6 !!!     */\n       r5 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));\n \n/*=======EXPONENTIAL CROSSOVER============================================================*/\n \n/*-------DE/best/1/exp--------------------------------------------------------------------*/\n/*-------Our oldest strategy but still not bad. However, we have found several------------*/\n/*-------optimization problems where misconvergence occurs.-------------------------------*/\n     if (strategy == 1) /* strategy DE0 (not in our paper) */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/1/exp-------------------------------------------------------------------*/\n/*-------This is one of my favourite strategies. It works especially well when the-------*/\n/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/\n/*-------as a first guess.---------------------------------------------------------------*/\n     else if (strategy == 2) /* strategy DE1 in the techreport */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/\n/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/\n/*-------If you get misconvergence try to increase NP. If this doesn\'t help you----------*/\n/*-------should play around with all three control variables.----------------------------*/\n     else if (strategy == 3) /* similiar to DE2 but generally better */\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                       \n         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/\n     else if (strategy == 4)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/\n     else if (strategy == 5)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n \n/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/\n \n/*-------DE/best/1/bin--------------------------------------------------------------------*/\n     else if (strategy == 6) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/1/bin-------------------------------------------------------------------*/\n     else if (strategy == 7) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/\n     else if (strategy == 8) \n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/best/2/bin--------------------------------------------------------------------*/\n     else if (strategy == 9)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/2/bin--------------------------------------------------------------------*/\n     else\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n \n \n/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/\n \n     trial_cost = evaluate(D,tmp,&nfeval);  /* Evaluate new vector in tmp[] */\n   if(MAXIMAPROBLEM == 1)\n   {\n    // 改為最大化\n       if (trial_cost >= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost>cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n    else\n    {\n          // 最小化問題\n       if (trial_cost <= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost<cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n \n      }   /* End mutation loop through pop. */\n \n      assignd(D,bestit,best);  /* Save best population member of current iteration */\n \n      /* swap population arrays. New generation becomes old one */\n \n      pswap = pold;\n      pold  = pnew;\n      pnew  = pswap;\n \n/*----Compute the energy variance (just for monitoring purposes)-----------*/\n \n      cmean = 0.;          /* compute the mean value first */\n      for (j=0; j<NP; j++)\n      {\n         cmean += cost[j];\n      }\n      cmean = cmean/NP;\n \n      cvar = 0.;           /* now the variance              */\n      for (j=0; j<NP; j++)\n      {\n         cvar += (cost[j] - cmean)*(cost[j] - cmean);\n      }\n      cvar = cvar/(NP-1);\n \n \n/*----Output part----------------------------------------------------------*/\n \n      if (gen%refresh==1)   /* display after every refresh generations */\n      { /* ABORT works only if conio.h is accepted by your compiler */\n    printf("\\n\\n                         PRESS ANY KEY TO ABORT"); \n    printf("\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n",cmin);\n \n    for (j=0;j<D;j++)\n    {\n      printf("\\n best[%d]=%-15.10g",j,best[j]);\n    }\n    printf("\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n    printf("\\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\\n",\n               NP,F,CR,cvar);\n      }\n \n      fprintf(fpout_ptr,"%ld   %-15.10g\\n",nfeval,cmin);\n   }\n/*=======================================================================*/\n/*=========End of iteration loop=========================================*/\n/*=======================================================================*/\n \n/*-------Final output in file-------------------------------------------*/\n \n \n   fprintf(fpout_ptr,"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n",cmin);\n \n   for (j=0;j<D;j++)\n   {\n     fprintf(fpout_ptr,"\\n best[%d]=%-15.10g",j,best[j]);\n   }\n   fprintf(fpout_ptr,"\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n   fprintf(fpout_ptr,"\\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\\n",\n           NP,F,CR,cvar); \n \n  fclose(fpout_ptr);\n \n  /* Code you want timed here */\n  printf("Time elapsed: %f\\n", ((double)clock() - start) / CLOCKS_PER_SEC);\n   return(0);\n}\n \n/*-----------End of main()------------------------------------------*/\n \n// 適應函式 fittness function (cost function)\ndouble evaluate(int D, double tmp[], long *nfeval)\n{\n   double result=0, surface = 80.0, z, volume, penality;\n   (*nfeval)++;\n   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));\n   volume = tmp[0]*tmp[1]*z;\n \n  if(volume <= 0){\n    return PENALITY;\n  }\n// 只限制長度與寬度必須大於 0\n  if(tmp[0] <= inibound_l){\n    return PENALITY;\n  }\n \n  if(tmp[1] <= inibound_l){\n    return PENALITY;\n  }\n/*\n  if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){\n    return PENALITY;\n  }\n \n  if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){\n    return PENALITY;\n  }\n  */\n  // volume must >0 and max volume\n  // 目前為最小化問題\n   //return 1+1/(volume*volume);\n  return volume;\n}\n  \n Python 版本: \n import random\n\nclass Chromosome(object):\n\n    """\n    just copy the idea of genetic algorithm, pretty similar..\n    """\n    def __init__(self, n):\n        """\n        int n, dimension of question\n        """\n        # dimension\n        self.n = n\n        # the gene\n        self.v = [0] * n\n        # the fitness value\n        self.f = 0\n\n    def assign(self, obj):\n        """\n        Chromosome obj\n\n        copy all attribute from obj to itself\n        """\n        self.n = obj.n\n        self.v = obj.v[:]\n        self.f = obj.f\n\n\nclass DiffertialEvolution(object):\n\n    def __init__(self,Func, pType, strategy, D, NP, F, CR, lower, upper, maxGen, report):\n        # if pType = 1 it is maximization  otherwise is minimization problem\n        self.pType = pType\n        # strategy 1~10, choice what strategy to generate new member in temporary\n        self.strategy = strategy\n        # dimesion of quesiton\n        self.D = D\n        # population size\n        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence\n        self.NP = NP\n        # weight factor\n        # F is usually between 0.5 and 1 (in rare cases > 1)\n        self.F = F\n        # crossover possible\n        # CR in [0,1]\n        self.CR = CR\n        # lower bound array\n        self.lb = lower[:]\n        # upper bound array\n        self.ub = upper[:]\n        # maximum generation\n        self.maxGen = maxGen\n        # how many generation report once\n        self.rpt = report\n        # object function, or enviorment\n        self.f = Func\n        # check parameter is set properly\n        self.checkParameter()\n\n        # generation pool, depend on population size\n        self.pop = [Chromosome(D) for i in range(NP)]\n        # last generation best member\n        self.lastgenbest = Chromosome(D)\n        # current best member\n        self.currentbest = Chromosome(D)\n        # the generation count\n        self.gen = 0\n        # the vector\n        self.r1 = 0\n        self.r2 = 0\n        self.r3 = 0\n        self.r4 = 0\n        self.r5 = 0\n\n    def checkParameter(self):\n        """\n        check parameter is set properly\n        """\n        if (type(self.D) is not int) and self.D <= 0:\n            raise Exception(\'D shoud be integer and larger than 0\')\n        if (type(self.NP) is not int) and self.NP <= 0:\n            raise Exception(\'NP shoud be integer and larger than 0\')\n        if self.CR < 0 or self.CR > 1:\n            raise Exception(\'CR should be [0,1]\')\n        if self.maxGen <= 0:\n            raise Exception(\'generation should larger than 0\')\n        if self.rpt <= 0 or self.rpt > self.maxGen:\n            raise Exception(\'report should be larger than 0 and less than max genration\')\n        if self.strategy < 1 or self.strategy > 10:\n            raise Exception(\'strategy should be [1,10]\')\n        for lower, upper in zip(self.lb, self.ub):\n            if lower > upper:\n                raise Exception(\'upper bound should be larger than lower bound\')\n\n    def init(self):\n        """\n        init population\n        """\n        for i in range(self.NP):\n            for j in range(self.D):\n                self.pop[i].v[j] = self.lb[j] + random.random()*(self.ub[j] - self.lb[j])\n            self.pop[i].f = self.evalute(self.pop[i])\n\n    def evalute(self, p):\n        """\n        evalute the member in enviorment\n        """\n        return self.f(p.v)\n\n    def findBest(self):\n        """\n        find member that have minimum fitness value from pool\n        """\n        if self.pType == 1:\n            return max(self.pop, key=lambda chrom:chrom.f)\n        else:\n            return min(self.pop, key=lambda chrom:chrom.f)\n\n    def generateRandomVector(self, i):\n        """\n        generate new vector\n        """\n        while True:\n            self.r1 = int(random.random() * self.NP)\n            if not (self.r1 == i):\n                break\n\n        while True:\n            self.r2 = int(random.random() * self.NP)\n            if not ((self.r2 == i) or (self.r2 == self.r1)):\n                break\n\n        while True:\n            self.r3 = int(random.random() * self.NP)\n            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):\n                break\n\n        while True:\n            self.r4 = int(random.random() * self.NP)\n            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):\n                break\n\n        while True:\n            self.r5 = int(random.random() * self.NP)\n            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):\n                break\n\n    def recombination(self, i):\n        """\n        use new vector, recombination the new one member to tmp\n        """\n        tmp = Chromosome(self.D)\n\n        if self.strategy == 1:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif self.strategy == 2:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 3):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 4):\n            tmp.assign(self.pop[i])\n\n            n = int(random.random() * self.D)\n\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 5):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 6):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 7):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 8):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 9):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n\n                n = (n + 1) % self.D\n\n        else:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n        return tmp\n\n    def report(self):\n        """\n        report current generation status\n        """\n        if self.gen == 0:\n            print("DiffertialEvolution results - init pop")\n        elif self.gen == self.maxGen:\n            print("Final DiffertialEvolution results at", self.gen, "generations")\n        else:\n            print("DiffertialEvolution results after", self.gen, "generations")\n        print("Function : %.6f" % (self.currentbest.f))\n        for i, v in enumerate(self.currentbest.v, start=1):\n            print("Var", i, ":", v)\n\n    def overbound(self, member):\n        """\n        check the member\'s chromosome that is out of bound?\n        """\n        for i in range(self.D):\n            if member.v[i] > self.ub[i] or member.v[i] < self.lb[i]:\n                return True\n        return False\n\n    def run(self):\n        """\n        run the algorithm...\n        """\n        # initial step\n        # generation 0\n        self.gen = 0\n        # init the member\'s chromsome\n        self.init()\n        # find the best one(smallest fitness value)\n        tmp = self.findBest()\n        # copy to lastgenbest\n        self.lastgenbest.assign(tmp)\n        # copy to currentbest\n        self.currentbest.assign(tmp)\n        # report status\n        self.report()\n        # end initial step\n\n        # the evolution journey is beggin...\n        for self.gen in range(1, self.maxGen + 1):\n            for i in range(self.NP):\n                # generate new vector\n                self.generateRandomVector(i)\n                # use the vector recombine the member to temporary\n                tmp = self.recombination(i)\n                # check the one is out of bound?\n                if self.overbound(tmp):\n                    # if it is, then ignore\n                    continue\n                # is not out of bound, that mean it\'s quilify of enviorment\n                # then evalute the one\n                tmp.f = self.evalute(tmp)\n                # if temporary one is better than origin(fitness value is larger or smaller)\n                # pType is 1, the problem is maximization type\n                if self.pType == 1:\n                    if tmp.f >= self.pop[i].f:\n                        # copy the temporary one to origin member\n                        self.pop[i].assign(tmp)\n                        # check the temporary one is better than the currentbest\n                        if tmp.f > self.currentbest.f:\n                            # copy the temporary one to currentbest\n                            self.currentbest.assign(tmp)\n                else:\n                    if tmp.f <= self.pop[i].f:\n                        # copy the temporary one to origin member\n                        self.pop[i].assign(tmp)\n                        # check the temporary one is better than the currentbest\n                        if tmp.f < self.currentbest.f:\n                            # copy the temporary one to currentbest\n                            self.currentbest.assign(tmp)\n            # copy the currentbest to lastgenbest\n            self.lastgenbest.assign(self.currentbest)\n            # if report generation is set, report\n            if self.rpt != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        # the evolution journey is done, report the final status\n        self.report()\n\n#fittness function (cost function)\ndef evaluate(designVariablel):\n    surface = 80.0\n    # if pType is 1, the penality is negative (maximization problem)\n    # if pType is 0, the penality is positive (minimization problem)\n    penality = -1000\n\n    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\\\n         +designVariablel[1]))\n    volume = designVariablel[0]*designVariablel[1]*z\n  \n    if(volume <= 0):\n        return penality\n\n    # box length and width need to be larger than 0\n    if(designVariablel[0] <= 0):\n        return penality\n\n    if(designVariablel[1] <= 0):\n        return penality\n    return volume\n#volume = DiffertialEvolution((self,Func, max, strategy, D, NP, F, CR, lower, upper, maxGen, report)\nvolume = DiffertialEvolution(evaluate, 1, 3, 2, 100, 0.6, 0.85, [0, 0], [50, 50], 100, 10)\nvolume.run()\n \n 將上述 Python 轉為 Cython 格式: \n #import random\nfrom cpython cimport bool\n#from array import array\nimport numpy as np\ncimport numpy as np\nfrom libc.stdlib cimport rand, RAND_MAX, srand\nfrom libc.time cimport time\n\n# make true it is random everytime\nsrand(time(NULL))\n\ncdef double randV():\n    return rand()*1.0 / RAND_MAX\n\ncdef class Chromosome(object):\n    """\n    just copy the idea of genetic algorithm, pretty similar..\n    """\n    cdef public int n\n    cdef public double f\n    cdef public np.ndarray v\n\n    def __cinit__(self, int n):\n        """\n        int n, dimension of question\n        """\n        # dimension\n        self.n = n\n        # the gene\n        self.v = np.zeros(n)\n        # the fitness value\n        self.f = 0\n\n    def assign(self, Chromosome obj):\n        """\n        Chromosome obj\n        copy all attribute from obj to itself\n        """\n        self.n = obj.n\n        self.v[:] = obj.v\n        self.f = obj.f\n\n\ncdef class DiffertialEvolution(object):\n\n    cdef:\n        int strategy, D, NP, maxGen, rpt, gen, r1, r2, r3, r4, r5\n        double F, CR\n        np.ndarray lb, ub, pop\n        object f\n        Chromosome lastgenbest, currentbest\n\n    def __cinit__(self, object Func, int strategy, int D, int NP, double F, double CR, object lower, object upper, int maxGen, int report):\n        # strategy 1~10, choice what strategy to generate new member in temporary\n        self.strategy = strategy\n        # dimesion of quesiton\n        self.D = D\n        # population size\n        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence\n        self.NP = NP\n        # weight factor\n        # F is usually between 0.5 and 1 (in rare cases > 1)\n        self.F = F\n        # crossover possible\n        # CR in [0,1]\n        self.CR = CR\n        # low bound\n        self.lb = np.array(lower[:])\n        # up bound\n        self.ub = np.array(upper[:])\n        # maximum generation\n        self.maxGen = maxGen\n        # how many generation report once\n        self.rpt = report\n        # object function, or enviorment\n        self.f = Func\n        # check parameter is set properly\n        self.checkParameter()\n\n        # generation pool, depend on population size\n        #self.pop = [Chromosome(self.D) for i in range(self.NP)]\n        self.pop = np.ndarray((NP,),dtype=np.object)\n        for i in range(NP):\n            self.pop[i] = Chromosome(self.D)\n        # last generation best member\n        self.lastgenbest = Chromosome(D)\n        # current best member\n        self.currentbest = Chromosome(D)\n        # the generation count\n        self.gen = 0\n        # the vector\n        self.r1 = 0\n        self.r2 = 0\n        self.r3 = 0\n        self.r4 = 0\n        self.r5 = 0\n\n    cdef void checkParameter(self):\n        """\n        check parameter is set properly\n        """\n        if (type(self.D) is not int) and self.D <= 0:\n            raise Exception(\'D shoud be integer and larger than 0\')\n        if (type(self.NP) is not int) and self.NP <= 0:\n            raise Exception(\'NP shoud be integer and larger than 0\')\n        if self.CR < 0 or self.CR > 1:\n            raise Exception(\'CR should be [0,1]\')\n        if self.maxGen <= 0:\n            raise Exception(\'generation should larger than 0\')\n        if self.rpt <= 0 or self.rpt > self.maxGen:\n            raise Exception(\'report should be larger than 0 and less than max genration\')\n        if self.strategy < 1 or self.strategy > 10:\n            raise Exception(\'strategy should be [1,10]\')\n        for lower, upper in zip(self.lb, self.ub):\n            if lower > upper:\n                raise Exception(\'upper bound should be larger than lower bound\')\n\n    cdef void init(self):\n        """\n        init population\n        """\n        cdef int i, j\n\n        for i in range(self.NP):\n            for j in range(self.D):\n                self.pop[i].v[j] = self.lb[j] + randV()*(self.ub[j] - self.lb[j])\n            self.pop[i].f = self.evalute(self.pop[i])\n\n    cdef double evalute(self, Chromosome member):\n        """\n        evalute the member in enviorment\n        """\n        return self.f(member.v)\n\n    cdef Chromosome findBest(self):\n        """\n        find member that have minimum fitness value from pool\n        """\n        return min(self.pop, key=lambda chrom:chrom.f)\n\n    cdef void generateRandomVector(self, i):\n        """\n        generate new vector\n        """\n        while True:\n            self.r1 = int(randV() * self.NP)\n            if not (self.r1 == i):\n                break\n\n        while True:\n            self.r2 = int(randV() * self.NP)\n            if not ((self.r2 == i) or (self.r2 == self.r1)):\n                break\n\n        while True:\n            self.r3 = int(randV() * self.NP)\n            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):\n                break\n\n        while True:\n            self.r4 = int(randV() * self.NP)\n            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):\n                break\n\n        while True:\n            self.r5 = int(randV() * self.NP)\n            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):\n                break\n\n    cdef Chromosome recombination(self, int i):\n        """\n        use new vector, recombination the new one member to tmp\n        """\n        cdef Chromosome tmp\n        cdef int n, L\n\n        tmp = Chromosome(self.D)\n\n        if self.strategy == 1:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif self.strategy == 2:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 3):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 4):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 5):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 6):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 7):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 8):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 9):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n\n        else:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n        return tmp\n\n    cdef void report(self):\n        """\n        report current generation status\n        """\n        cdef int i\n        cdef double v\n\n        if self.gen == 0:\n            print("DiffertialEvolution results - init pop")\n        elif self.gen == self.maxGen:\n            print("Final DiffertialEvolution results at %d generations"%(self.gen,))\n        else:\n            print("DiffertialEvolution results after %d generations"%(self.gen,))\n        print("Function : %.6f" % (self.currentbest.f))\n        for i, v in enumerate(self.currentbest.v.flat, start=1):\n            print("Var %d : %.4f"%(i, v))\n\n    cdef bool overbound(self, Chromosome member):\n        """\n        check the member\'s chromosome that is out of bound?\n        """\n        cdef int i\n\n        for i in range(self.D):\n            if member.v[i] > self.ub[i] or member.v[i] < self.lb[i]:\n                return True\n        return False\n\n    cdef void run(self):\n        """\n        run the algorithm...\n        """\n        cdef Chromosome tmp\n        cdef int i\n\n        # initial step\n        # generation 0\n        self.gen = 0\n        # init the member\'s chromsome\n        self.init()\n        # find the best one(smallest fitness value)\n        tmp = self.findBest()\n        # copy to lastgenbest\n        self.lastgenbest.assign(tmp)\n        # copy to currentbest\n        self.currentbest.assign(tmp)\n        # report status\n        self.report()\n        # end initial step\n\n        # the evolution journey is beggin...\n        for self.gen in range(1, self.maxGen + 1):\n            for i in range(self.NP):\n                # generate new vector\n                self.generateRandomVector(i)\n                # use the vector recombine the member to temporary\n                tmp = self.recombination(i)\n                # check the one is out of bound?\n                if self.overbound(tmp):\n                    # if it is, then abandon it\n                    continue\n                # is not out of bound, that mean it\'s quilify of enviorment\n                # then evalute the one\n                tmp.f = self.evalute(tmp)\n                # if temporary one is better than origin(fitness value is smaller)\n                if tmp.f <= self.pop[i].f:\n                    # copy the temporary one to origin member\n                    self.pop[i].assign(tmp)\n                    # check the temporary one is better than the currentbest\n                    if tmp.f < self.currentbest.f:\n                        # copy the temporary one to currentbest\n                        self.currentbest.assign(tmp)\n            # copy the currentbest to lastgenbest\n            self.lastgenbest.assign(self.currentbest)\n            # if report generation is set, report\n            if self.rpt != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        # the evolution journey is done, report the final status\n        self.report() \n 使用 Real-coded Genetic algorithm 解題: \n import time\nimport math\n\n\nclass Chromosome(object):\n\n    def __init__(self, n=None):\n        self.np = n if n > 0 else 2\n        self.f = 0.0\n        self.v = [0.0] * n\n\n    def cp(self, obj):\n        """\n        copy all atribute from another chromsome object\n        """\n        self.np = obj.np\n        self.f = obj.f\n        self.v = obj.v[:]\n\n    def get_v(self, i):\n        return self.v[i]\n\n    def is_self(self, obj):\n        """\n        check the object is self?\n        """\n        return obj is self\n\n    def assign(self, obj):\n        if not self.is_self(obj):\n            self.cp(obj)\n\n\nclass Genetic(object):\n\n    def __init__(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):\n        """\n        init(function func)\n        """\n        self.func=func\n        self.pType = pType\n        self.nParm=nParm\n        self.nPop=nPop\n        self.pCross=pCross\n        self.pMute=pMute\n        self.pWin=pWin\n        self.bDelta=bDelta\n\n        self.chrom = [Chromosome(nParm) for i in range(nPop)]\n        self.newChrom = [Chromosome(nParm) for i in range(nPop)]\n        self.babyChrom = [Chromosome(nParm) for i in range(3)]\n        self.chromElite = [Chromosome(nParm)]\n        self.chromBest = [Chromosome(nParm)]\n        self.maxLimit = upper[:]\n        self.minLimit = lower[:]\n\n        self.maxGen = None\n        self.gen = None\n\n        self.seed = 0.0\n        self.iseed = 470211272.0\n        self.mask = 2147483647\n\n    def check(self, i, v):\n        """\n        If a variable is out of bound,\n        replace it with a random value\n        """\n        if (v > self.maxLimit[i]) or (v < self.minLimit[i]):\n            return self.randVal(self.minLimit[i], self.maxLimit[i])\n        return v\n\n    def crossOver(self):\n        for i in range(0, self.nPop-1, 2):\n            # crossover\n            if(self.rnd() < self.pCross):\n                for s in range(self.nParm):\n                    # first baby, half father half mother\n                    self.babyChrom[0].v[s] = 0.5 * self.chrom[i].v[s] + 0.5*self.chrom[i+1].v[s];\n                    # second baby, three quaters of fater and quater of mother\n                    self.babyChrom[1].v[s] = self.check(s, 1.5 * self.chrom[i].v[s] - 0.5*self.chrom[i+1].v[s])\n                    # third baby, quater of fater and three quaters of mother\n                    self.babyChrom[2].v[s] = self.check(s,-0.5 * self.chrom[i].v[s] + 1.5*self.chrom[i+1].v[s]);\n\n                for j in range(3):\n                    self.babyChrom[j].f = self.func(self.babyChrom[j].v)\n                # maximization\n                if self.pType == 1:\n                    \n                    if self.babyChrom[1].f > self.babyChrom[0].f:\n                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]\n\n                    if self.babyChrom[2].f > self.babyChrom[0].f:\n                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]\n\n                    if self.babyChrom[2].f > self.babyChrom[1].f:\n                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]\n\n                else:\n                    \n                    if self.babyChrom[1].f < self.babyChrom[0].f:\n                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]\n\n                    if self.babyChrom[2].f < self.babyChrom[0].f:\n                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]\n\n                    if self.babyChrom[2].f < self.babyChrom[1].f:\n                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]\n\n                # replace first two baby to parent, another one will be\n                self.chrom[i].assign(self.babyChrom[0])\n                self.chrom[i+1].assign(self.babyChrom[1])\n\n    def delta(self, y):\n        r = float(self.gen) / self.maxGen;\n        return y*self.rnd()*math.pow(1.0-r, self.bDelta)\n\n    def fitness(self):\n        for j in range(self.nPop):\n            self.chrom[j].f = self.func(self.chrom[j].v)\n\n        self.chromBest[0].assign(self.chrom[0])\n\n        for j in range(self.nPop):\n            if self.pType == 1:\n                if(self.chrom[j].f > self.chromBest[0].f):\n                    self.chromBest[0].assign(self.chrom[j])\n            else:\n                if(self.chrom[j].f < self.chromBest[0].f):\n                    self.chromBest[0].assign(self.chrom[j])\n        if self.pType == 1:\n            if(self.chromBest[0].f > self.chromElite[0].f):\n                self.chromElite[0].assign(self.chromBest[0])\n        else:\n            if(self.chromBest[0].f < self.chromElite[0].f):\n                self.chromElite[0].assign(self.chromBest[0])\n\n    def initialPop(self):\n        for j in range(self.nPop):\n            for i in range(self.nParm):\n                self.chrom[j].v[i] = self.randVal(self.minLimit[i], self.maxLimit[i])\n\n    def mutate(self):\n        for i in range(self.nPop):\n            if self.rnd() < self.pMute:\n                s = self.random(self.nParm)\n                if (self.random(2) == 0):\n                    self.chrom[i].v[s] += self.delta(self.maxLimit[s]-self.chrom[i].v[s])\n                else:\n                    self.chrom[i].v[s] -= self.delta(self.chrom[i].v[s]-self.minLimit[s])\n\n    def report(self):\n        if self.gen == 0:\n            print("Genetik results - Initial population")\n        elif self.gen == self.maxGen:\n            print("Final Genetik results at", self.gen, "generations")\n        else:\n            print("Genetik results after", self.gen, "generations")\n\n        print("Function : %.6f" % (self.chromElite[0].f))\n        for i, p in enumerate(self.chromElite[0].v):\n            print("Var", i+1, ":", p)\n\n    def select(self):\n        """\n        roulette wheel selection\n        """\n        for i in range(self.nPop):\n            j = self.random(self.nPop)\n            k = self.random(self.nPop)\n            self.newChrom[i].assign(self.chrom[j])\n            if self.pType == 1:\n                if(self.chrom[k].f > self.chrom[j].f) and (self.rnd() > self.pWin):\n                    self.newChrom[i].assign(self.chrom[k])\n            else:\n                if(self.chrom[k].f < self.chrom[j].f) and (self.rnd() < self.pWin):\n                    self.newChrom[i].assign(self.chrom[k])\n        # in this stage, newChrom is select finish\n        # now replace origin chrom\n        for i in range(self.nPop):\n            self.chrom[i].assign(self.newChrom[i])\n\n        # select random one chrom to be best chrom, make best chrom still exist\n        j = self.random(self.nPop);\n        self.chrom[j].assign(self.chromElite[0])\n\n    def run(self, mxg, rp):\n        """\n        // **** Init and run GA for maxGen times\n        // **** mxg : maximum generation\n        // **** rp  : report cycle, 0 for final report or\n        // ****       report each mxg modulo rp\n        """\n        self.maxGen = mxg\n        self.rpt = rp\n\n        self.randomize()\n        self.initialPop()\n        self.chrom[0].f = self.func(self.chrom[0].v)\n        self.chromElite[0].assign(self.chrom[0])\n\n        self.gen = 0\n        self.fitness()\n        self.report()\n\n        for self.gen in range(1, self.maxGen + 1):\n            self.select()\n            self.crossOver()\n            self.mutate()\n            self.fitness()\n            if rp != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        self.report()\n\n    def newSeed(self):\n        if(self.seed == 0.0):\n            self.seed=self.iseed\n        else:\n            self.seed *= 16807.0\n            self.seed = math.fmod(self.seed, self.mask)\n\n    def rnd(self):\n        self.newSeed()\n        return self.seed/self.mask\n\n    def randomize(self):\n        self.seed = time.time()\n\n    def random(self, k):\n        return int(self.rnd()*k)\n\n    def randVal(self, low, high):\n        number_types = (int, float)\n        if isinstance(low, number_types) and isinstance(high, number_types):\n            return self.rnd()*(high-low)+low\n        raise ValueError\n        \n#fittness function (cost function)\ndef evaluate(designVariablel):\n    surface = 80.0\n    # if pType is 1, the penality is negative (maximization problem)\n    # if pType is 0, the penality is positive (minimization problem)\n    penality = -1000\n\n    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\\\n         +designVariablel[1]))\n    volume = designVariablel[0]*designVariablel[1]*z\n  \n    if(volume <= 0):\n        return penality\n\n    # box length and width need to be larger than 0\n    if(designVariablel[0] <= 0):\n        return penality\n\n    if(designVariablel[1] <= 0):\n        return penality\n    #return 1+1/(volume*volume)\n    return volume\n\n#volume = Genetic(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):\nvolume = Genetic(evaluate, 1, 2, 1000, 0.95, 0.05, 0.95, 5, [0, 0], [50, 50])\nvolume.run(1000, 50)\n \n 參考資料 \n Genetic Algorithm Essentials \n https://link.springer.com/book/10.1007/978-3-319-52156-5   \n Differential Evolution in Electromagnetics \n https://link.springer.com/book/10.1007/978-3-642-12869-1   \n', 'tags': '', 'url': '數值分析.html'}, {'title': 'Qt C++ 計算器程式', 'text': 'Ｑt5 Calculator project.7z \n \n calculator.pro \n #-------------------------------------------------\n#\n# Project created by QtCreator 2018-07-07T23:49:39\n#\n#-------------------------------------------------\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets\n\nTARGET = calculator\nTEMPLATE = app\n\n# The following define makes your compiler emit warnings if you use\n# any feature of Qt which has been marked as deprecated (the exact warnings\n# depend on your compiler). Please consult the documentation of the\n# deprecated API in order to know how to port your code away from it.\nDEFINES += QT_DEPRECATED_WARNINGS\n\n# You can also make your code fail to compile if you use deprecated APIs.\n# In order to do so, uncomment the following line.\n# You can also select to disable deprecated APIs only up to a certain version of Qt.\n#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0\n\n\nSOURCES += \\\n        main.cpp \\\n    button.cpp \\\n    calculator.cpp\n\nHEADERS += \\\n    button.h \\\n    calculator.h \n main.cpp \n #include "calculator.h"\n#include <QApplication>\n\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n    Calculator w;\n    w.show();\n\n    return a.exec();\n} \n button.h \n #ifndef BUTTON_H\n#define BUTTON_H\n\n#include <QToolButton>\n\nclass Button : public QToolButton\n{\n    Q_OBJECT\n\npublic:\n    explicit Button(const QString &text, QWidget *parent = 0);\n\n    QSize sizeHint() const override;\n};\n\n#endif \n calculator.h \n #ifndef CALCULATOR_H\n#define CALCULATOR_H\n\n#include <QWidget>\n\nclass QLineEdit;\n\nclass Button;\n\nclass Calculator : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    Calculator(QWidget *parent = 0);\n\nprivate slots:\n    void digitClicked();\n    void unaryOperatorClicked();\n    void additiveOperatorClicked();\n    void multiplicativeOperatorClicked();\n    void equalClicked();\n    void pointClicked();\n    void changeSignClicked();\n    void backspaceClicked();\n    void clear();\n    void clearAll();\n    void clearMemory();\n    void readMemory();\n    void setMemory();\n    void addToMemory();\n\nprivate:\n    Button *createButton(const QString &text, const char *member);\n    void abortOperation();\n    bool calculate(double rightOperand, const QString &pendingOperator);\n\n    double sumInMemory;\n    double sumSoFar;\n    double factorSoFar;\n    QString pendingAdditiveOperator;\n    QString pendingMultiplicativeOperator;\n    bool waitingForOperand;\n\n    QLineEdit *display;\n\n    enum { NumDigitButtons = 10 };\n    Button *digitButtons[NumDigitButtons];\n};\n\n#endif \n button.cpp \n #include <QtWidgets>\n\n#include "button.h"\n\nButton::Button(const QString &text, QWidget *parent)\n    : QToolButton(parent)\n{\n    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);\n    setText(text);\n}\n\nQSize Button::sizeHint() const\n{\n    QSize size = QToolButton::sizeHint();\n    size.rheight() += 20;\n    size.rwidth() = qMax(size.width(), size.height());\n    return size;\n} \n calculator.cpp \n #include <QtWidgets>\n\n#include <cmath>\n\n#include "button.h"\n#include "calculator.h"\n\nCalculator::Calculator(QWidget *parent)\n    : QWidget(parent)\n{\n    sumInMemory = 0.0;\n    sumSoFar = 0.0;\n    factorSoFar = 0.0;\n    waitingForOperand = true;\n\n    display = new QLineEdit("0");\n    display->setReadOnly(true);\n    display->setAlignment(Qt::AlignRight);\n    display->setMaxLength(15);\n\n    QFont font = display->font();\n    font.setPointSize(font.pointSize() + 8);\n    display->setFont(font);\n\n    for (int i = 0; i < NumDigitButtons; ++i) {\n        digitButtons[i] = createButton(QString::number(i), SLOT(digitClicked()));\n    }\n\n    Button *pointButton = createButton(tr("."), SLOT(pointClicked()));\n    Button *changeSignButton = createButton(tr("\\302\\261"), SLOT(changeSignClicked()));\n\n    Button *backspaceButton = createButton(tr("Backspace"), SLOT(backspaceClicked()));\n    Button *clearButton = createButton(tr("Clear"), SLOT(clear()));\n    Button *clearAllButton = createButton(tr("Clear All"), SLOT(clearAll()));\n\n    Button *clearMemoryButton = createButton(tr("MC"), SLOT(clearMemory()));\n    Button *readMemoryButton = createButton(tr("MR"), SLOT(readMemory()));\n    Button *setMemoryButton = createButton(tr("MS"), SLOT(setMemory()));\n    Button *addToMemoryButton = createButton(tr("M+"), SLOT(addToMemory()));\n\n    Button *divisionButton = createButton(tr("\\303\\267"), SLOT(multiplicativeOperatorClicked()));\n    Button *timesButton = createButton(tr("\\303\\227"), SLOT(multiplicativeOperatorClicked()));\n    Button *minusButton = createButton(tr("-"), SLOT(additiveOperatorClicked()));\n    Button *plusButton = createButton(tr("+"), SLOT(additiveOperatorClicked()));\n\n    Button *squareRootButton = createButton(tr("Sqrt"), SLOT(unaryOperatorClicked()));\n    Button *powerButton = createButton(tr("x\\302\\262"), SLOT(unaryOperatorClicked()));\n    Button *reciprocalButton = createButton(tr("1/x"), SLOT(unaryOperatorClicked()));\n    Button *equalButton = createButton(tr("="), SLOT(equalClicked()));\n\n    QGridLayout *mainLayout = new QGridLayout;\n    mainLayout->setSizeConstraint(QLayout::SetFixedSize);\n    mainLayout->addWidget(display, 0, 0, 1, 6);\n    mainLayout->addWidget(backspaceButton, 1, 0, 1, 2);\n    mainLayout->addWidget(clearButton, 1, 2, 1, 2);\n    mainLayout->addWidget(clearAllButton, 1, 4, 1, 2);\n\n    mainLayout->addWidget(clearMemoryButton, 2, 0);\n    mainLayout->addWidget(readMemoryButton, 3, 0);\n    mainLayout->addWidget(setMemoryButton, 4, 0);\n    mainLayout->addWidget(addToMemoryButton, 5, 0);\n\n    for (int i = 1; i < NumDigitButtons; ++i) {\n        int row = ((9 - i) / 3) + 2;\n        int column = ((i - 1) % 3) + 1;\n        mainLayout->addWidget(digitButtons[i], row, column);\n    }\n\n    mainLayout->addWidget(digitButtons[0], 5, 1);\n    mainLayout->addWidget(pointButton, 5, 2);\n    mainLayout->addWidget(changeSignButton, 5, 3);\n\n    mainLayout->addWidget(divisionButton, 2, 4);\n    mainLayout->addWidget(timesButton, 3, 4);\n    mainLayout->addWidget(minusButton, 4, 4);\n    mainLayout->addWidget(plusButton, 5, 4);\n\n    mainLayout->addWidget(squareRootButton, 2, 5);\n    mainLayout->addWidget(powerButton, 3, 5);\n    mainLayout->addWidget(reciprocalButton, 4, 5);\n    mainLayout->addWidget(equalButton, 5, 5);\n    setLayout(mainLayout);\n\n    setWindowTitle(tr("Calculator"));\n}\n\nvoid Calculator::digitClicked()\n{\n    Button *clickedButton = qobject_cast<Button *>(sender());\n    int digitValue = clickedButton->text().toInt();\n    if (display->text() == "0" && digitValue == 0.0)\n        return;\n\n    if (waitingForOperand) {\n        display->clear();\n        waitingForOperand = false;\n    }\n    display->setText(display->text() + QString::number(digitValue));\n}\n\nvoid Calculator::unaryOperatorClicked()\n{\n    Button *clickedButton = qobject_cast<Button *>(sender());\n    QString clickedOperator = clickedButton->text();\n    double operand = display->text().toDouble();\n    double result = 0.0;\n\n    if (clickedOperator == tr("Sqrt")) {\n        if (operand < 0.0) {\n            abortOperation();\n            return;\n        }\n        result = std::sqrt(operand);\n    } else if (clickedOperator == tr("x\\302\\262")) {\n        result = std::pow(operand, 2.0);\n    } else if (clickedOperator == tr("1/x")) {\n        if (operand == 0.0) {\n            abortOperation();\n            return;\n        }\n        result = 1.0 / operand;\n    }\n    display->setText(QString::number(result));\n    waitingForOperand = true;\n}\n\nvoid Calculator::additiveOperatorClicked()\n{\n    Button *clickedButton = qobject_cast<Button *>(sender());\n    QString clickedOperator = clickedButton->text();\n    double operand = display->text().toDouble();\n\n    if (!pendingMultiplicativeOperator.isEmpty()) {\n        if (!calculate(operand, pendingMultiplicativeOperator)) {\n            abortOperation();\n            return;\n        }\n        display->setText(QString::number(factorSoFar));\n        operand = factorSoFar;\n        factorSoFar = 0.0;\n        pendingMultiplicativeOperator.clear();\n    }\n\n    if (!pendingAdditiveOperator.isEmpty()) {\n        if (!calculate(operand, pendingAdditiveOperator)) {\n            abortOperation();\n            return;\n        }\n        display->setText(QString::number(sumSoFar));\n    } else {\n        sumSoFar = operand;\n    }\n\n    pendingAdditiveOperator = clickedOperator;\n    waitingForOperand = true;\n}\n\nvoid Calculator::multiplicativeOperatorClicked()\n{\n    Button *clickedButton = qobject_cast<Button *>(sender());\n    QString clickedOperator = clickedButton->text();\n    double operand = display->text().toDouble();\n\n    if (!pendingMultiplicativeOperator.isEmpty()) {\n        if (!calculate(operand, pendingMultiplicativeOperator)) {\n            abortOperation();\n            return;\n        }\n        display->setText(QString::number(factorSoFar));\n    } else {\n        factorSoFar = operand;\n    }\n\n    pendingMultiplicativeOperator = clickedOperator;\n    waitingForOperand = true;\n}\n\nvoid Calculator::equalClicked()\n{\n    double operand = display->text().toDouble();\n\n    if (!pendingMultiplicativeOperator.isEmpty()) {\n        if (!calculate(operand, pendingMultiplicativeOperator)) {\n            abortOperation();\n            return;\n        }\n        operand = factorSoFar;\n        factorSoFar = 0.0;\n        pendingMultiplicativeOperator.clear();\n    }\n    if (!pendingAdditiveOperator.isEmpty()) {\n        if (!calculate(operand, pendingAdditiveOperator)) {\n            abortOperation();\n            return;\n        }\n        pendingAdditiveOperator.clear();\n    } else {\n        sumSoFar = operand;\n    }\n\n    display->setText(QString::number(sumSoFar));\n    sumSoFar = 0.0;\n    waitingForOperand = true;\n}\n\nvoid Calculator::pointClicked()\n{\n    if (waitingForOperand)\n        display->setText("0");\n    if (!display->text().contains(\'.\'))\n        display->setText(display->text() + tr("."));\n    waitingForOperand = false;\n}\n\nvoid Calculator::changeSignClicked()\n{\n    QString text = display->text();\n    double value = text.toDouble();\n\n    if (value > 0.0) {\n        text.prepend(tr("-"));\n    } else if (value < 0.0) {\n        text.remove(0, 1);\n    }\n    display->setText(text);\n}\n\nvoid Calculator::backspaceClicked()\n{\n    if (waitingForOperand)\n        return;\n\n    QString text = display->text();\n    text.chop(1);\n    if (text.isEmpty()) {\n        text = "0";\n        waitingForOperand = true;\n    }\n    display->setText(text);\n}\n\nvoid Calculator::clear()\n{\n    if (waitingForOperand)\n        return;\n\n    display->setText("0");\n    waitingForOperand = true;\n}\n\nvoid Calculator::clearAll()\n{\n    sumSoFar = 0.0;\n    factorSoFar = 0.0;\n    pendingAdditiveOperator.clear();\n    pendingMultiplicativeOperator.clear();\n    display->setText("0");\n    waitingForOperand = true;\n}\n\nvoid Calculator::clearMemory()\n{\n    sumInMemory = 0.0;\n}\n\nvoid Calculator::readMemory()\n{\n    display->setText(QString::number(sumInMemory));\n    waitingForOperand = true;\n}\n\nvoid Calculator::setMemory()\n{\n    equalClicked();\n    sumInMemory = display->text().toDouble();\n}\n\nvoid Calculator::addToMemory()\n{\n    equalClicked();\n    sumInMemory += display->text().toDouble();\n}\nButton *Calculator::createButton(const QString &text, const char *member)\n{\n    Button *button = new Button(text);\n    connect(button, SIGNAL(clicked()), this, member);\n    return button;\n}\n\nvoid Calculator::abortOperation()\n{\n    clearAll();\n    display->setText(tr("####"));\n}\n\nbool Calculator::calculate(double rightOperand, const QString &pendingOperator)\n{\n    if (pendingOperator == tr("+")) {\n        sumSoFar += rightOperand;\n    } else if (pendingOperator == tr("-")) {\n        sumSoFar -= rightOperand;\n    } else if (pendingOperator == tr("\\303\\227")) {\n        factorSoFar *= rightOperand;\n    } else if (pendingOperator == tr("\\303\\267")) {\n        if (rightOperand == 0.0)\n            return false;\n        factorSoFar /= rightOperand;\n    }\n    return true;\n} \n', 'tags': '', 'url': 'Qt C++ 計算器程式.html'}, {'title': 'Qt5 Tutorial', 'text': 'http://www.bogotobogo.com/Qt/Qt5_Creating_QtQuick2_QML_Application_Animation_A.php   \n Qt5 編程指南:  https://qtguide.ustclug.org/ \n Qt5 PDF viewer:  https://github.com/yshurik/qpdfjs \n Qt5 瀏覽器:  https://otter-browser.org/   \n', 'tags': '', 'url': 'Qt5 Tutorial.html'}, {'title': 'PyQt 計算器程式', 'text': 'PyQt Version History \n 1994, Qt \n November 1998 SIP, and released PyQt 0.1 supporting Qt 1.41 \n 2000, PyQt 2.0 supported Qt 2.2 on both Linux and Windows \n 2001, Qt 3 support \n 2002, Mac OS X support \n June 2006, PyQt 4.0 with support for Qt 4 \n 2008, Trolltech acquired by Nokia \n August 2009, Nokia released PySide \n Sep 2009, PyQt 4.6 \n Jan 2010, PyQt 4.7 \n Nov 2010, PyQt 4.8.1 \n 2011, Qt Commercial business acquired by Digia \n 2012, Qt business acquired by Digia from Nokia \n Oct 2013, PyQt 5.1 \n July 2015, PyQt 5.5 \n Dec 2016, PyQt 5.7.1 \n March 30, 2017, PyQt 5.8.2 \n cpw10_calculator.7z \n 一甲第十週第三部分 \n \n 一乙第十週第二部分 \n \n 一甲第十二週第一部分 \n \n 一甲第十二週第二部分 \n \n 一乙第十二週第二部分 \n \n 參考資料: \n https://www.e-education.psu.edu/geog489/l2.html   \n', 'tags': '', 'url': 'PyQt 計算器程式.html'}, {'title': 'PyQt5 實際操作', 'text': 'Algorithmic Problem Solving with Python.pdf \n https://pythonprogramming.net/basic-gui-pyqt-tutorial/   (for PyQt4) \n https://github.com/kenwaldek/pythonprogramming   (PyQt5 examples) \n https://blog.csdn.net/c3060911030/article/category/6247011/1  (PyQt5 教程) \n pyqt5tutorial_201603.pdf  (PyQt5 Tutorial Documentation) \n https://pythonspot.com/pyqt5/   (Collection of PyQt5 articles) \n pyqt5_intro1.pdf  ( 法文原稿 ) \n pyqt5_intro2.pdf  ( 法文原稿 ) \n PyQt5 class reference \n 以 QWidget 建立視窗: \n import sys\nfrom PyQt5.QtWidgets import QApplication, QWidget\n\n# 利用 QApplication 類別建立案例\napp = QApplication(sys.argv)\n\n# 無 parent 的部件為視窗\nwindow = QWidget()\n# 設定視窗屬性\nwindow.setGeometry(50, 50, 500, 300)\nwindow.setWindowTitle(\'第一個 PyQt5 程式\')\n\n# 顯示視窗\nwindow.show()\n# 執行應用程式, 若按右上方 close 按鈕可以 exit\nsys.exit(app.exec()) \n 改寫為自建視窗類別物件: \n import sys\nfrom PyQt5.QtWidgets import QApplication, QWidget\n\nclass window(QWidget):\n\n    def __init__(self):\n        # 啟始時先執行父物件 (即 QWidget) 的建構子\n        super().__init__()\n        self.setGeometry(50, 50, 500, 300)\n        self.setWindowTitle(\'第一個 PyQt5 程式\')\n        # 案例建立時直接顯示, 也可以建立案例後再顯示\n        self.show()\n\napp = QApplication(sys.argv)\nGui = window()\nsys.exit(app.exec()) \n 以 QMainWindow  類別建立視窗: \n import sys\nfrom PyQt5.QtCore import QCoreApplication\nfrom PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QPushButton\n\n\nclass window(QMainWindow):\n\n    def __init__(self):\n        super().__init__()\n        self.setGeometry(50, 50, 500, 300)\n        self.setWindowTitle(\'第一個 PyQt5 程式\')\n        self.addExitButton()\n\n    def addExitButton(self):\n        btn = QPushButton(\'退出\', self)\n        btn.clicked.connect(QCoreApplication.instance().quit)\n        btn.resize(100, 100)\n        btn.move(100, 100)\n        # 顯示 window\n        self.show()\n\ndef run():\n    app = QApplication(sys.argv)\n    Gui = window()\n    sys.exit(app.exec())\n\nrun() \n 視窗關閉時列印訊息: \n import sys\nfrom PyQt5.QtCore import QCoreApplication\nfrom PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QPushButton\n\n\nclass window(QMainWindow):\n\n    def __init__(self):\n        super().__init__()\n        self.setGeometry(50, 50, 500, 300)\n        self.setWindowTitle(\'第一個 PyQt5 程式\')\n        self.addQuitButton()\n\n    def addQuitButton(self):\n        btn = QPushButton(\'退出\', self)\n        btn.clicked.connect(self.close_application)\n\n        btn.resize(btn.sizeHint())  #set to acceptable size automatic\n        btn.move(0, 0)\n        self.show()\n\n    def close_application(self):\n        print(\'關閉應用程式\')\n        sys.exit()\n\ndef run():\n    app = QApplication(sys.argv)\n    Gui = window()\n    sys.exit(app.exec())\n\nrun() \n http://zetcode.com/gui/pyqt5/   \n #!/usr/bin/python3\n\nimport sys\nfrom PyQt5.QtCore import QDateTime, Qt\n# stage 1\n#from PyQt5.QtWidgets import QApplication, QWidget\n# stage 2\n#from PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplication\n# stage 3\nfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplication, QMenu\nfrom PyQt5.QtGui import QIcon\n\nnow = QDateTime.currentDateTime()\n\nprint("Today:", now.toString(Qt.ISODate))\nprint("Adding 12 days: {0}".format(now.addDays(12).toString(Qt.ISODate)))\nprint("Subtracting 22 days: {0}".format(now.addDays(-22).toString(Qt.ISODate)))\n\nprint("Adding 50 seconds: {0}".format(now.addSecs(50).toString(Qt.ISODate)))\nprint("Adding 3 months: {0}".format(now.addMonths(3).toString(Qt.ISODate)))\nprint("Adding 12 years: {0}".format(now.addYears(12).toString(Qt.ISODate)))\n\nclass Example(QMainWindow):\n    \n    def __init__(self):\n        super().__init__()\n        self.initUI()\n        \n        \n    def initUI(self):               \n        \'\'\'\n        # stage 1\n        self.statusBar().showMessage(\'Ready\')\n        \n        self.setGeometry(300, 300, 250, 150)\n        self.setWindowTitle(\'Statusbar\')    \n        self.show()\n        \'\'\'\n        \n        \'\'\'\n        # stage 2\n        exitAct = QAction(QIcon(\'exit.png\'), \'&Exit\', self)        \n        exitAct.setShortcut(\'Ctrl+Q\')\n        exitAct.setStatusTip(\'Exit application\')\n        exitAct.triggered.connect(qApp.quit)\n\n        self.statusBar()\n\n        menubar = self.menuBar()\n        fileMenu = menubar.addMenu(\'&File\')\n        fileMenu.addAction(exitAct)\n        \n        self.setGeometry(300, 300, 300, 200)\n        self.setWindowTitle(\'Simple menu\')    \n        self.show()\n        \'\'\'\n        \n        menubar = self.menuBar()\n        fileMenu = menubar.addMenu(\'File\')\n        \n        impMenu = QMenu(\'Import\', self)\n        impAct = QAction(\'Import mail\', self) \n        impMenu.addAction(impAct)\n        \n        # 加入 QAction\n        newAct = QAction(\'New\', self)        \n        fileMenu.addAction(newAct)\n        \n        newAct1 = QAction(\'New1\', self)        \n        fileMenu.addAction(newAct1)\n        \n        # 加入 QMenu\n        fileMenu.addMenu(impMenu)\n        \n        self.setGeometry(300, 300, 300, 200)\n        self.setWindowTitle(\'Submenu\')    \n        self.show()\n\n\nif __name__ == \'__main__\':\n    \'\'\'\n    app = QApplication(sys.argv)\n\n    w = QWidget()\n    w.resize(250, 150)\n    w.move(300, 300)\n    w.setWindowTitle(\'Simple\')\n    w.show()\n    \'\'\'\n    app = QApplication(sys.argv)\n    ex = Example()\n    \n    sys.exit(app.exec()) \n \n 有關  if __name__ == \'__main__\': \n https://stackoverflow.com/questions/419163/what-does-if-name-main-do   \n 當 Python 解譯器讀取原始碼時, 會執行其中的所有程式碼. 而在執行這些程式碼之前, 會定義一些特殊變數的值, 例如: 當該程式碼執行時, 是以主程式的位階直接執行時, Python 就會將 __name__ 這個變數設為 __main__. \n 假如這個程式碼檔案並非以主程式的位階直接執行, 而是被導入其他程式中, 以模組的位階執行,  __name__ 變數就會被設為該模組的名稱. \n', 'tags': '', 'url': 'PyQt5 實際操作.html'}, {'title': 'Flask 網際程式', 'text': 'Flask Hello World 程式: \n # 導入 Flask 類別\nfrom flask import Flask\n\'\'\'\nIf you are using a single module (as in this\nexample), you should use __name__ because depending on if it’s started as application\nor imported as module the name will be different (\'__main__\' versus\nthe actual import name). This is needed so that Flask knows where to look for\ntemplates, static files, and so on. For more information have a look at the Flask\ndocumentation.\n\'\'\'\n# 利用 Flask 類別建立 app 案例\napp = Flask(__name__)\n\n\'\'\'\nThe route decorator is used to register a view function for a given URL rule.\nThis does the same thing as add_url_rule() but is intended for decorator.\n\'\'\'\n# 利用 decorator 設定 URL 連結\n@app.route(\'/\')\ndef hello_world():\n    # 傳回字串\n    return \'Hello, World!\'\n\n# app 在本機埠號 5000 執行, 且開啟 debug 模式\napp.run(host=\'127.0.0.1\', port=5000, debug=True) \n 有關 decorator:  \n https://realpython.com/primer-on-python-decorators/   \n 根據  https://blog.techbridge.cc/2018/06/15/python-decorator-introduction/  說明: \n @my_decorator\ndef my_func(stuff):\n    do_things() \n 等同 \n def my_func(stuff):\n    do_things()\nmy_func = my_decorator(my_func) \n 因此可以先編寫: \n from flask import abort\n# wraps 是一個製作 Decorator 好工具，也可以把參數傳入\nfrom functools import wraps\ndef check_login():\n    # 做一些檢查\ndef login_required(fun):\n    """\n    Required user to login\n    """\n    @wraps(fun)\n    # wraps 可協助傳入參數做操作\n    def wrapper(*args, **kwds):\n        if check_login() is None:\n            return abort(403)\n        return fun(*args, **kwds)\n    return wrapper \n 然後再透過 decorator 設計下列程式, 代表有驗證登入者才能看到該頁面: \n @payment_blueprint.route(\'/payment\')\n@login_required\ndef get_payment_page():\n    return render_template(\'payment/index.html\') \n oauth2 模組: \n https://github.com/requests/requests-oauthlib   ( doc ) \n or \n google-api-python-client \n google-auth \n google-auth-httplib2 \n google-auth-oauthlib 使用 requests-oauthlib 模組: \n 參考:  https://medium.com/@bittu/add-google-oauth2-login-in-your-flask-web-app-9f455695341e   \n import os\nimport json\nimport datetime\n\nfrom flask import Flask, url_for, redirect, \\\n    render_template, session, request\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.login import LoginManager, login_required, login_user, \\\n    logout_user, current_user, UserMixin\nfrom requests_oauthlib import OAuth2Session\nfrom requests.exceptions import HTTPError\n\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\n"""App Configuration"""\n\n\nclass Auth:\n    """Google Project Credentials"""\n    CLIENT_ID = (\'688061596571-3c13n0uho6qe34hjqj2apincmqk86ddj\'\n                 \'.apps.googleusercontent.com\')\n    CLIENT_SECRET = \'JXf7Ic_jfCam1S7lBJalDyPZ\'\n    REDIRECT_URI = \'https://localhost:5000/gCallback\'\n    AUTH_URI = \'https://accounts.google.com/o/oauth2/auth\'\n    TOKEN_URI = \'https://accounts.google.com/o/oauth2/token\'\n    USER_INFO = \'https://www.googleapis.com/userinfo/v2/me\'\n    SCOPE = [\'profile\', \'email\']\n\n\nclass Config:\n    """Base config"""\n    APP_NAME = "Test Google Login"\n    SECRET_KEY = os.environ.get("SECRET_KEY") or "somethingsecret"\n\n\nclass DevConfig(Config):\n    """Dev config"""\n    DEBUG = True\n    SQLALCHEMY_DATABASE_URI = \'sqlite:///\' + os.path.join(basedir, "test.db")\n\n\nclass ProdConfig(Config):\n    """Production config"""\n    DEBUG = False\n    SQLALCHEMY_DATABASE_URI = \'sqlite:///\' + os.path.join(basedir, "prod.db")\n\n\nconfig = {\n    "dev": DevConfig,\n    "prod": ProdConfig,\n    "default": DevConfig\n}\n\n"""APP creation and configuration"""\napp = Flask(__name__)\napp.config.from_object(config[\'dev\'])\ndb = SQLAlchemy(app)\nlogin_manager = LoginManager(app)\nlogin_manager.login_view = "login"\nlogin_manager.session_protection = "strong"\n\n""" DB Models """\n\n\nclass User(db.Model, UserMixin):\n    __tablename__ = "users"\n    id = db.Column(db.Integer, primary_key=True)\n    email = db.Column(db.String(100), unique=True, nullable=False)\n    name = db.Column(db.String(100), nullable=True)\n    avatar = db.Column(db.String(200))\n    tokens = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow())\n\n\n@login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))\n""" OAuth Session creation """\n\n\ndef get_google_auth(state=None, token=None):\n    if token:\n        return OAuth2Session(Auth.CLIENT_ID, token=token)\n    if state:\n        return OAuth2Session(\n            Auth.CLIENT_ID,\n            state=state,\n            redirect_uri=Auth.REDIRECT_URI)\n    oauth = OAuth2Session(\n        Auth.CLIENT_ID,\n        redirect_uri=Auth.REDIRECT_URI,\n        scope=Auth.SCOPE)\n    return oauth\n\n\n@app.route(\'/\')\n@login_required\ndef index():\n    return render_template(\'index.html\')\n\n\n@app.route(\'/login\')\ndef login():\n    if current_user.is_authenticated:\n        return redirect(url_for(\'index\'))\n    google = get_google_auth()\n    auth_url, state = google.authorization_url(\n        Auth.AUTH_URI, access_type=\'offline\')\n    session[\'oauth_state\'] = state\n    return render_template(\'login.html\', auth_url=auth_url)\n\n\n@app.route(\'/gCallback\')\ndef callback():\n    if current_user is not None and current_user.is_authenticated:\n        return redirect(url_for(\'index\'))\n    if \'error\' in request.args:\n        if request.args.get(\'error\') == \'access_denied\':\n            return \'You denied access.\'\n        return \'Error encountered.\'\n    if \'code\' not in request.args and \'state\' not in request.args:\n        return redirect(url_for(\'login\'))\n    else:\n        google = get_google_auth(state=session[\'oauth_state\'])\n        try:\n            token = google.fetch_token(\n                Auth.TOKEN_URI,\n                client_secret=Auth.CLIENT_SECRET,\n                authorization_response=request.url)\n        except HTTPError:\n            return \'HTTPError occurred.\'\n        google = get_google_auth(token=token)\n        resp = google.get(Auth.USER_INFO)\n        if resp.status_code == 200:\n            user_data = resp.json()\n            email = user_data[\'email\']\n            user = User.query.filter_by(email=email).first()\n            if user is None:\n                user = User()\n                user.email = email\n            user.name = user_data[\'name\']\n            print(token)\n            user.tokens = json.dumps(token)\n            user.avatar = user_data[\'picture\']\n            db.session.add(user)\n            db.session.commit()\n            login_user(user)\n            return redirect(url_for(\'index\'))\n        return \'Could not fetch your information.\'\n\n\n@app.route(\'/logout\')\n@login_required\ndef logout():\n    logout_user()\n    return redirect(url_for(\'index\')) \n 使用 google 相關模組, 擷取 google drive 資料: \n # -*- coding: utf-8 -*-\n\nimport os\nimport flask\nimport requests\n\nimport google.oauth2.credentials\nimport google_auth_oauthlib.flow\nimport googleapiclient.discovery\nimport ssl\n\n# 即使在近端仍希望以 https 模式下執行\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\ncontext.load_cert_chain(\'localhost.crt\', \'localhost.key\')\n\n# This variable specifies the name of a file that contains the OAuth 2.0\n# information for this application, including its client_id and client_secret.\nCLIENT_SECRETS_FILE = "client_secret.json"\n\n# This OAuth 2.0 access scope allows for full read/write access to the\n# authenticated user\'s account and requires requests to use an SSL connection.\nSCOPES = [\'https://www.googleapis.com/auth/drive.metadata.readonly\']\nAPI_SERVICE_NAME = \'drive\'\nAPI_VERSION = \'v2\'\n\napp = flask.Flask(__name__)\n# Note: A secret key is included in the sample so that it works.\n# If you use this code in your application, replace this with a truly secret\n# key. See http://flask.pocoo.org/docs/0.12/quickstart/#sessions.\napp.secret_key = \'A0Zr9@8j/3yX R~XHH!jmN]LWX/,?R@T\'\n\n\n@app.route(\'/\')\ndef index():\n  return print_index_table()\n\n@app.route(\'/test\')\ndef test_api_request():\n  if \'credentials\' not in flask.session:\n    return flask.redirect(\'authorize\')\n\n  # Load credentials from the session.\n  credentials = google.oauth2.credentials.Credentials(\n      **flask.session[\'credentials\'])\n\n  drive = googleapiclient.discovery.build(\n      API_SERVICE_NAME, API_VERSION, credentials=credentials)\n\n  files = drive.files().list().execute()\n\n  # Save credentials back to session in case access token was refreshed.\n  # ACTION ITEM: In a production app, you likely want to save these\n  #              credentials in a persistent database instead.\n  flask.session[\'credentials\'] = credentials_to_dict(credentials)\n\n  return flask.jsonify(**files)\n\n\n@app.route(\'/authorize\')\ndef authorize():\n  # Create flow instance to manage the OAuth 2.0 Authorization Grant Flow steps.\n  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n      CLIENT_SECRETS_FILE, scopes=SCOPES)\n\n  flow.redirect_uri = flask.url_for(\'callback\', _external=True)\n\n  authorization_url, state = flow.authorization_url(\n      # Enable offline access so that you can refresh an access token without\n      # re-prompting the user for permission. Recommended for web server apps.\n      access_type=\'offline\',\n      # Enable incremental authorization. Recommended as a best practice.\n      include_granted_scopes=\'true\')\n\n  # Store the state so the callback can verify the auth server response.\n  flask.session[\'state\'] = state\n\n  return flask.redirect(authorization_url)\n\n\n@app.route(\'/callback\')\ndef callback():\n  # Specify the state when creating the flow in the callback so that it can\n  # verified in the authorization server response.\n  state = flask.session[\'state\']\n\n  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n      CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)\n  flow.redirect_uri = flask.url_for(\'callback\', _external=True)\n\n  # Use the authorization server\'s response to fetch the OAuth 2.0 tokens.\n  authorization_response = flask.request.url\n  flow.fetch_token(authorization_response=authorization_response)\n\n  # Store credentials in the session.\n  # ACTION ITEM: In a production app, you likely want to save these\n  #              credentials in a persistent database instead.\n  credentials = flow.credentials\n  flask.session[\'credentials\'] = credentials_to_dict(credentials)\n\n  return flask.redirect(flask.url_for(\'test_api_request\'))\n\n\n@app.route(\'/revoke\')\ndef revoke():\n  if \'credentials\' not in flask.session:\n    return (\'You need to <a href="/authorize">authorize</a> before \' +\n            \'testing the code to revoke credentials.\')\n\n  credentials = google.oauth2.credentials.Credentials(\n    **flask.session[\'credentials\'])\n\n  revoke = requests.post(\'https://accounts.google.com/o/oauth2/revoke\',\n      params={\'token\': credentials.token},\n      headers = {\'content-type\': \'application/x-www-form-urlencoded\'})\n\n  status_code = getattr(revoke, \'status_code\')\n  if status_code == 200:\n    return(\'Credentials successfully revoked.\' + print_index_table())\n  else:\n    return(\'An error occurred.\' + print_index_table())\n\n\n@app.route(\'/clear\')\ndef clear_credentials():\n  if \'credentials\' in flask.session:\n    del flask.session[\'credentials\']\n  return (\'Credentials have been cleared.<br><br>\' +\n          print_index_table())\n\n\ndef credentials_to_dict(credentials):\n  return {\'token\': credentials.token,\n          \'refresh_token\': credentials.refresh_token,\n          \'token_uri\': credentials.token_uri,\n          \'client_id\': credentials.client_id,\n          \'client_secret\': credentials.client_secret,\n          \'scopes\': credentials.scopes}\n\ndef print_index_table():\n  return (\'<table>\' +\n          \'<tr><td><a href="/test">Test an API request</a></td>\' +\n          \'<td>Submit an API request and see a formatted JSON response. \' +\n          \'    Go through the authorization flow if there are no stored \' +\n          \'    credentials for the user.</td></tr>\' +\n          \'<tr><td><a href="/authorize">Test the auth flow directly</a></td>\' +\n          \'<td>Go directly to the authorization flow. If there are stored \' +\n          \'    credentials, you still might not be prompted to reauthorize \' +\n          \'    the application.</td></tr>\' +\n          \'<tr><td><a href="/revoke">Revoke current credentials</a></td>\' +\n          \'<td>Revoke the access token associated with the current user \' +\n          \'    session. After revoking credentials, if you go to the test \' +\n          \'    page, you should see an <code>invalid_grant</code> error.\' +\n          \'</td></tr>\' +\n          \'<tr><td><a href="/clear">Clear Flask session credentials</a></td>\' +\n          \'<td>Clear the access token currently stored in the user session. \' +\n          \'    After clearing the token, if you <a href="/test">test the \' +\n          \'    API request</a> again, you should go back to the auth flow.\' +\n          \'</td></tr></table>\')\n\n\nif __name__ == \'__main__\':\n  # When running locally, disable OAuthlib\'s HTTPs verification.\n  # ACTION ITEM for developers:\n  #     When running in production *do not* leave this option enabled.\n  os.environ[\'OAUTHLIB_INSECURE_TRANSPORT\'] = \'1\'\n\n  # Specify a hostname and port that are set as a valid redirect URI\n  # for your API project in the Google API Console.\n  app.run(\'localhost\', 7443, debug=True, ssl_context=context) \n 因為在此要使用 SQLite 資料庫, 可以使用  https://portableapps.com/apps/development/sqlite_database_browser_portable  開啟 SQLite 資料庫檔案. \n 利用 pybean 建立 user 資料表: \n import os\nfrom pybean import Store, SQLiteWriter\n# if no content.db, create database file with cms table\ndata_dir = "./"\nif not os.path.isfile(data_dir+"content.db"):\n    library = Store(SQLiteWriter(data_dir+"content.db", frozen=False))\n    # 資料表 user\n    user = library.new("user")\n    user.studid = "123"\n    user.password = "123"\n    user.memo = "user 123"\n    library.save(user)\n    library.commit() \n 操作步驟: \n https://console.developers.google.com/   \n  建立專案,   APIs and Auth -> Credentials,  Add Credentials and then select OAuth 2.0 client ID \n get client id and client secret. \n python -m pip install Flask-Login \n 之後可以使用: \n from flask_login import LoginManager, login_required, login_user, \\\n    logout_user, current_user, UserMixin \n \n', 'tags': '', 'url': 'Flask 網際程式.html'}, {'title': '應用範例', 'text': '學習計算機程式的目的在利用數位科技技術解決問題, 所謂數位科技技術包括程式套件、網路與資料庫等元件的組合. \n 基本流程為: \n \n 如何取得、傳輸並處理資料? \n 如何儲存資料? \n 如何呈現資料? \n \n 處理資料的過程依賴數學模型、演算法與資料結構 \n 取得與傳輸資料則依賴網路 \n 至於資料的呈現則涵蓋 2D/3D 動態與靜態格式處理 \n \n Tinkercad Circuit - Arduino 控制卡與電子致動與感測元件線路的模擬 \n 網頁資料解讀與任務派送 - 計算機程式對特定格式資料的分析後, 依照循環與亂數流程進行分配 \n V-rep - 利用各種程式介面與延伸程式的設計, 讓使用者設計、控制並模擬各種機器人模型 \n 輔助設計套件 - 利用計算機圖學與視窗介面, 讓使用者完成設想中的機械零組件設計, 並進行功能模擬 \n \n', 'tags': '', 'url': '應用範例.html'}, {'title': '計算器', 'text': 'PyQt5 計算機程式說明 \n 按鍵分類 \n \n 0 ~9 數字按建, 點按後由 digitClicked() 方法槽承接處理 \n 直接運算元, 包括 Sqrt, x^2 與 1/x, 點按後由 unaryOperatorClicked() 方法槽承接處理 \n 加或減運算元, 包括 + 與 - 運算, 點按後由 additiveOperatorClicked() 方法槽承接處理 \n 乘或除運算元, 包括 * 與 / 運算, 點按後由 multiplicativeOperatorClicked() 方法槽承接處理 \n 其餘按鍵則各自以特定的方法槽承接處理 \n \n 變數與運算流程考量 \n \n 數字按鍵以 zero, one, two, three, four, five, six, seven, eight, nine 命名 \n 顯示幕以 display 命名 \n 等號以 equalButton 命名 \n 與 MS, M+, 或 MC 按鍵相關的計算機記憶體數值, 存入 sumInMemory 變數對應的記憶空間 \n 以 sumSoFar 儲存累計數值, 使用者按下等號後, sumSoFar 重新計算結果, 並顯示在 display 幕, Clear All 按鍵則重置 sumSoFar 為 0 \n 以 factorSoFar 儲存乘或除運算子運算過程所得的暫存數值 \n 以 pendingAdditiveOperator 儲存使用者最後點按的加或減運算子字串 \n 以 pendingMultiplicativeOperator 儲存使用者最後點按的乘或除運算子字串 \n 以 waitingForOperand 界定使用者是否處理運算數輸入階段, 若 waitingForOperand 為 True, 表示計算機正在等待使用者"開始"輸入運算數 \n waitingForOperand 起始值為 True, 只有重新進入 digitClicked 方法, display 才會 clear(), 否則在顯示幕非為 0 的情況下, 將堆疊數字字串 \n 因為考量先乘除後加減運算順序, 將加減與乘除處理方法分開, 若使用者輸入加減運算子後, 緊接乘除運算子, 計算機會先乘除運算後再加減 \n 直接運算元可以在使用者按下按鍵後, 直接對 display 中的數值進行處理, 無需其他暫存需求 \n pendingAdditiveOperator, pendingMultiplicativeOperator, sumSoFar, factorSoFar 與 waitingForOperand, 在 Dialog 類別建構子中設定起始值 \n \n 數字按鍵點按處理 \n \n 使用者點按數字按鍵, 將會送出該按鍵的 clicked() 訊號 \n 按鍵的 clicked() 訊號將會根據設定, 觸發 digitClicked() 方法槽 \n 由於 PyQt5 的 Push Button 以 Qt5 中的 QObject::sender() 送出訊號, 此函式會傳回 sender 作為 QObject 的指標 \n 因為此一與 Push Button 配合的 sender 為 Button 物件, 因此可以在 digitClicked() 函式中, 利用 sender().text() 取得按鍵的 text 字串 \n 假如使用者點按 0, display 顯示字串 0, 但是若一開始輸入兩個以上的 0, digitClicked() 應該仍只顯示 0 字串 \n 但是若計算機處於等待新運算數輸入時 (以 waitingForOperand 判定), 新數字在顯示前, display 應該要清除先前所顯示的數字 \n 最後, 除了在顯示幕為 0 之後的 0 按鍵輸入, digitClicked() 方法槽不會繼續判定是否清除顯示幕或堆疊數字字串外, 所按的數字將會堆疊顯示 \n \n 直接運算按鍵處理 \n \n Sqrt, x^2 與 1/x 等按鍵的處理方法為 unaryOperatorClicked(), 與數字按鍵的點按回應相同, 透過 sender().text() 取得按鍵上的 text 字串 \n unaryOperatorClicked() 方法隨後根據 text 判定運算子後, 利用 display 上的運算數進行運算後, 再將結果顯示在 display 顯示幕 \n 若進行運算 Sqrt 求數值的平方根時, 顯示幕中為負值, 或 1/x 運算時, x 為 0, 都視為無法處理的情況, 以呼叫 abortOperation() 處理 \n abortOperation() 方法則重置所有起始變數, 並在 display 中顯示 "####" \n 直接運算子處理結束前, 運算結果會顯示在 display 中, 而且運算至此告一段落, 計算機狀態應該要回復到等待新運算數的階段, 因此 waitingForOperand 要重置為 True \n \n 加或減按鍵處理 \n \n 使用者按下加或減運算子按鍵時, 程式設定以 additiveOperatorClicked() 處理 \n 進入 additiveOperatorClicked() 後, 必須先查是否有尚未運算的乘或除運算子, 因為必須先乘除後才能加減 \n 先處理乘與除運算後, 再處理加或減運算後, 將 sumSoFar 顯示在 display 後, 必須重置 sumSoFar 為 0, 表示運算告一段落 \n \n 乘或除按鍵處理 \n \n 使用者按下乘或除運算子按鍵時, 程式設定以 multiplicativeOperatorClicked() 處理 \n 進入 multiplicativeOperatorClicked() 後, 無需檢查是否有尚未運算的加或減運算子, 因為乘除運算有優先權 \n 先處理乘與除運算後, 再處理加或減運算, 將 sumSoFar 顯示在 display 後, 必須重置 sumSoFar 為 0, 表示運算告一段落 \n \n 小數點按鍵處理 \n \n 使用者按下小數點按鍵後, 以 pointClicked() 方法處理, 直接在 display 字串中加上 "." 字串 \n \n 數值變號按鍵處理 \n \n 使用者按下變號按鍵後, 由 changeSignClicked() 處理, 若顯示幕上為正值, 則在 display 字串最前面, 疊上 "-" 字串 \n 假如顯示幕上為負值, 則設法移除 display 上字串最前方的 "-" 字元 \n \n 退格按鍵處理 \n \n 使用者按下退格按鍵後, 由 backspaceClicked() 處理, 這時可以利用 Python 字串數列中的 [:-1], 保留除了最後一個字元的字串 \n 離開 backspaceClicked() 前 ,將顯示幕中原有字串的 [:-1] 字串, 顯示在 display 上 \n 若退格後 display 上為空字串, 則顯示 0, 並且將 waitingForOperand 起始設為 True, 表示等待新運算數中 \n \n 清除按鍵處理 \n \n 使用者按下 Clear 按鍵後, 以 clear() 方法處理, 進入函式後, 將現有的運算數重置為 0 \n 離開 clear() 前, 將 waitingForOperand 起始設為 True, 表示等待新運算數中 \n ClearAll 按鍵, 則將所有變數全部重置為起始狀態 \n \n 記憶體按鍵處理 \n \n clearMemory() 方法與 "MC" 按鍵對應, 清除記憶體中所存 sumInMemory 設為 0 \n readMemory() 方法與 "MR" 按鍵對應, 功能為讀取記憶體中的數值, 因此將 sumInMemory 顯示在 display, 作為運算數 \n setMemory() 方法則與 "MS" 按鍵對應, 功能為設定記憶體中的數值，因此取 display 中的數字, 存入 sumInMemory \n addToMemory() 方法與 "M+" 按鍵對應, 功能為加上記憶體中的數值, 因此將 sumInMemory 加上 display 中的數值 \n 因為 setMemory() 與 addToMemory() 方法, 都需要取用 display 上的數值, 因此必須先呼叫 equalClicked(), 以更新 sumSoFar 與 display 上的數值 \n \n calculate() 方法 \n \n calculate() 方法中的運算, 以 rightOperand 為右運算數 \n 當執行加或減運算時, 左運算數為 sumSoFar \n 當執行乘或除運算時, 左運算數為 factorSoFar \n 若運算過程出現除與 0 時, 將會回傳 False \n \n \n Qt5 -   sender() \n sip -   sip: sender() \n PyQt5 計算機程式原始碼 \n Dialog.py \n # -*- coding: utf-8 -*-\n\n"""\nModule implementing Dialog.\n"""\n\nfrom PyQt5.QtCore import pyqtSlot\nfrom PyQt5.QtWidgets import QDialog\n\nfrom .Ui_Dialog import Ui_Dialog\n\n\n# Dialog 類別同時繼承 QDialog 與 Ui_Dialog 類別\nclass Dialog(QDialog, Ui_Dialog):\n    """\n    Class documentation goes here. (若有類別相關說明文件內容, 放在此處)\n    """\n    def __init__(self, parent=None):\n        """\n        Constructor (類別建構子)\n        \n        @param parent reference to the parent widget\n        @type QWidget\n        """\n        # 利用 super 類別調用 parent 類別中的建構子\n        super(Dialog, self).__init__(parent)\n        # 上一行在 Python3 可以寫為 super().__init__()\n        # 利用 Ui_Dialog 類別中的 setupUi 方法, 以 self 視窗部件建立使用者介面\n        self.setupUi(self)\n        # 以上程式碼由 Eric6 表單頁面中的滑鼠右鍵, Generate Dialog Code 指令產生\n        # 當多個 signal 同時指向同一個 slot 處理時, 採用 for loop\n        num_button = [self.one,  self.two,  \\\n        self.three,  self.four,  self.five,  self.six,  self.seven,  self.eight,  self.nine,  self.zero]\n        # 用於產生加號與減號 signals 與 slots 用的數列\n        plus_minus = [self.plus,  self.minus]\n        # 用於產生乘號與除號 signals 與 slots 用的數列\n        multiply_divide = [self.multiply,  self.divide]\n        #self.one.clicked.connect(self.number)\n        # 數字按鍵的 signals 與 slots 設定\n        for i in num_button:\n            i.clicked.connect(self.number)\n        \n        # 加減鍵的 signals 與 slogts 設定\n        for i in plus_minus:\n            i.clicked.connect(self.additiveOperatorClicked)\n        \n        # 等於按鍵的 signal 與 slot 設定\n        self.equal.clicked.connect(self.equalClicked)\n        \n        # 乘與除按建的 signals 與 slots 設定\n        for i in multiply_divide:\n            i.clicked.connect(self.multiplicativeOperatorClicked)\n        \n        # 等待運算的加或減\n        self.pendingAdditiveOperator = \'\'\n        \n        # sumSoFar 儲存運算流程中所累計的數值\n        # 當使用者按下 = 後, sumSoFar 重新計算並將數字顯示在 display 區\n        # 當使用者按下 Clear All, sumSoFar 將重置回 0\n        self.sumSoFar = 0.0\n        # 起始時, 等待使用者輸入運算數值變數為真\n        self.waitingForOperand = True\n        \n        # sumInMemory 儲存計算機記憶體中的值, 配合 MS, M+, 或 MC 按鈕使用\n        self.sumInMemory = 0.0\n        # factorSoFar 暫存按下乘或除運算時的數值\n        self.factorSoFar = 0.0\n        # 等待運算的乘或除\n        self.pendingMultiplicativeOperator = \'\'\n\n    def number(self):\n        # sender() 為使用者點擊按鈕時送出的按鈕指標類別, 在此利用此按鍵類別建立案例\n        # 所建立的 clickedButton 即為當下使用者所按下的按鈕物件\n        clickedButton = self.sender()\n        # text() 為利用按鈕物件的 text 方法取得該按鈕上所顯示的 text 字串\n        digitValue = int(clickedButton.text())\n        # when user clicks 0.0\n        if self.display.text() == \'0\' and digitValue == 0.0:\n            return\n        \n        # if under digit input process, clear display for the very first beginning\n        # waitingForOperand 為 True 已經點按運算數值按鈕\n        if self.waitingForOperand:\n            # 清除 display \n            self.display.clear()\n            # 將判斷是否已經點按運算數值按鈕的判斷變數重新設為  False\n            self.waitingForOperand = False\n        # 利用 setText() 設定 LineEdit 元件顯示字串, 利用 text() 取出目前所顯示的字串, 同時也可利用 text() 擷取按鈕物件上顯示的字串\n        #self.display.setText(self.display.text() + self.sender().text())\n        self.display.setText(self.display.text() + str(digitValue))\n        \n    def additiveOperatorClicked(self):\n        # 確定按下加或減\n        clickedButton = self.sender()\n        # 確定運算子, 為加或減\n        clickedOperator = clickedButton.text()\n        # 點按運算子之前在 display 上的數字, 為運算數\n        operand = float(self.display.text())\n        \n        # 納入乘與除之後的先乘除後加減運算邏輯, 且納入連續按下乘或除可累計運算\n        if self.pendingMultiplicativeOperator:\n            if not self.calculate(operand, self.pendingMultiplicativeOperator):\n                self.abortOperation()\n                return\n\n            self.display.setText(str(self.factorSoFar))\n            operand = self.factorSoFar\n            self.factorSoFar = 0.0\n            self.pendingMultiplicativeOperator = \'\'\n            \n            \n        # 假如有等待運算的加或減, 進入執行運算\n        # 且納入連續按下加或減時, 可以目前的運算數及運算子累計運算\n        if self.pendingAdditiveOperator:\n            if not self.calculate(operand, self.pendingAdditiveOperator):\n                self.abortOperation()\n                return\n            # 顯示目前的運算結果\n            self.display.setText(str(self.sumSoFar))\n        else:\n            # 假如 self.pendingAdditiveOperator 為 False, 則將運算數與 self.fumSoFar 對應\n            self.sumSoFar = operand\n            \n        # 能夠重複按下加或減, 以目前的運算數值執行重複運算\n        self.pendingAdditiveOperator = clickedOperator\n        # 進入等待另外一個運算數值的階段, 設為 True 才會清空 LineEdit\n        self.waitingForOperand = True\n\n    # 處理使用者按下乘或除按鍵時的 slot 方法\n    def multiplicativeOperatorClicked(self):\n        clickedButton = self.sender()\n        clickedOperator = clickedButton.text()\n        # 將按鈕顯示的 text 轉為浮點數\n        operand = float(self.display.text())\n\n        # 若連續按下乘或除, 則以目前的運算數與運算子執行運算\n        if self.pendingMultiplicativeOperator:\n            if not self.calculate(operand, self.pendingMultiplicativeOperator):\n                self.abortOperation()\n                return\n\n            # 將目前乘或除的累計運算數顯示在 display 上\n            self.display.setText(str(self.factorSoFar))\n        else:\n            self.factorSoFar = operand\n\n        # 能夠重複按下乘或除, 以目前的運算數值執行重複運算\n        self.pendingMultiplicativeOperator = clickedOperator\n        self.waitingForOperand = True\n    \n    def equalClicked(self):\n        # 從 display 取的運算數值\n        operand = float(self.display.text())\n        \n        # 先乘除的運算處理\n        if self.pendingMultiplicativeOperator:\n            if not self.calculate(operand, self.pendingMultiplicativeOperator):\n                self.abortOperation()\n                return\n            # factorSoFar 為乘或除運算所得之暫存數值\n            operand = self.factorSoFar\n            self.factorSoFar = 0.0\n            self.pendingMultiplicativeOperator = \'\'\n        \n        # 若有等待加或減的運算子, 執行運算\n        if self.pendingAdditiveOperator:\n            if not self.calculate(operand, self.pendingAdditiveOperator):\n                self.abortOperation()\n                return\n\n            self.pendingAdditiveOperator = \'\'\n        else:\n            self.sumSoFar = operand\n\n        self.display.setText(str(self.sumSoFar))\n        self.sumSoFar = 0.0\n        self.waitingForOperand = True\n\n    # 右運算數與等待運算子當作輸入\n    def calculate(self, rightOperand, pendingOperator):\n        # 進入計算流程時, 用目前輸入的運算數值與 self.sumSoFar 執行計算\n        if pendingOperator == "+":\n            self.sumSoFar += rightOperand\n        elif pendingOperator == "-":\n            self.sumSoFar -= rightOperand\n\n        elif pendingOperator == "*":\n            self.factorSoFar *= rightOperand\n        elif pendingOperator == "/":\n            if rightOperand == 0.0:\n                return False\n\n            self.factorSoFar /= rightOperand\n\n        return True \n run.py \n # 導入 sys 模組, 主要用於 sys.argv 成員變數\nimport sys\n# 從 PQt5 模組導入 QtWidgets 模組類別\nfrom PyQt5 import QtWidgets\n# 從 ui 目錄導入 Dialog.py, Python 程式檔案本身就是一個模組, 且文件名就是模組名\nfrom ui import Dialog\n \n# 每一個 Python 程式都可以直接被執行, 或者被導入其他程式中, 當成導入模組執行\n# 假如程式檔案直接被執行時, 全域變數 __name__ 就會等於 "__main__" 字串\n# 因此, 以下的判斷式的意思是, 若本檔案直接被執行時, 就會執行以下內縮程式區段\nif __name__ == "__main__":\n    # 利用 QtWidgets.QApplication 類別建立案例物件, 且以 sys.argv 作為輸入\n    app = QtWidgets.QApplication(sys.argv)\n    # 利用所導入的 Dialog 模組中的 Dialog 類別建立物件案例, 對應的變數名稱設為 win\n    win = Dialog.Dialog()\n    # 執行 win 物件中的 show() 方法, 因為所有 Qt5 部件內定為不顯示\n    win.show()\n    # 執行 app 物件的 exec() 方法, 表示進入視窗事件重複迴圈, 等待使用者滑鼠輸入\n    # 將 app.exec() 當作 sys.exit() 執行輸入, 表示使用者可以透過視窗的 x 按鈕結束執行\n    sys.exit(app.exec()) \n 上述完整的程式專案倉儲:  https://github.com/kmolab/pymcadp/tree/gh-pages/2017fall   \n 視窗計算機程式開發 \n PyQt5 視窗程式一 \n PyQt5 視窗程式二 \n 事件導向程式設計 \n 完整的視窗計算器程式碼: \n #!/usr/bin/env python\n\nimport math\n\nfrom PyQt5.QtCore import Qt\nfrom PyQt5.QtWidgets import (QApplication, QGridLayout, QLayout, QLineEdit,\n        QSizePolicy, QToolButton, QWidget)\n\n\nclass Button(QToolButton):\n    \'\'\'\n    def __init__(self, text, parent=None):\n        super(Button, self).__init__(parent)\n    \'\'\'\n    # for Python 3\n    def __init__(self, text):\n        super().__init__()\n\n        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n        self.setText(text)\n\n    def sizeHint(self):\n        size = super(Button, self).sizeHint()\n        size.setHeight(size.height() + 20)\n        size.setWidth(max(size.width(), size.height()))\n        return size\n\n\nclass Calculator(QWidget):\n    NumDigitButtons = 10\n    \n    \'\'\'    \n    def __init__(self, parent=None):\n        super(Calculator, self).__init__(parent)\n    \'\'\'\n    def __init__(self):\n        super().__init__()\n\n        self.pendingAdditiveOperator = \'\'\n        self.pendingMultiplicativeOperator = \'\'\n\n        self.sumInMemory = 0.0\n        self.sumSoFar = 0.0\n        self.factorSoFar = 0.0\n        self.waitingForOperand = True\n\n        self.display = QLineEdit(\'0\')\n        self.display.setReadOnly(True)\n        self.display.setAlignment(Qt.AlignRight)\n        self.display.setMaxLength(15)\n\n        font = self.display.font()\n        font.setPointSize(font.pointSize() + 8)\n        self.display.setFont(font)\n\n        self.digitButtons = []\n        \n        for i in range(Calculator.NumDigitButtons):\n            self.digitButtons.append(self.createButton(str(i),\n                    self.digitClicked))\n\n        self.pointButton = self.createButton(".", self.pointClicked)\n        self.changeSignButton = self.createButton(u"\\N{PLUS-MINUS SIGN}",\n                self.changeSignClicked)\n\n        self.backspaceButton = self.createButton("Backspace",\n                self.backspaceClicked)\n        self.clearButton = self.createButton("Clear", self.clear)\n        self.clearAllButton = self.createButton("Clear All", self.clearAll)\n\n        self.clearMemoryButton = self.createButton("MC", self.clearMemory)\n        self.readMemoryButton = self.createButton("MR", self.readMemory)\n        self.setMemoryButton = self.createButton("MS", self.setMemory)\n        self.addToMemoryButton = self.createButton("M+", self.addToMemory)\n\n        self.divisionButton = self.createButton(u"\\N{DIVISION SIGN}",\n                self.multiplicativeOperatorClicked)\n        self.timesButton = self.createButton(u"\\N{MULTIPLICATION SIGN}",\n                self.multiplicativeOperatorClicked)\n        self.minusButton = self.createButton("-", self.additiveOperatorClicked)\n        self.plusButton = self.createButton("+", self.additiveOperatorClicked)\n\n        self.squareRootButton = self.createButton("Sqrt",\n                self.unaryOperatorClicked)\n        self.powerButton = self.createButton(u"x\\N{SUPERSCRIPT TWO}",\n                self.unaryOperatorClicked)\n        self.reciprocalButton = self.createButton("1/x",\n                self.unaryOperatorClicked)\n        self.equalButton = self.createButton("=", self.equalClicked)\n\n        mainLayout = QGridLayout()\n        mainLayout.setSizeConstraint(QLayout.SetFixedSize)\n\n        mainLayout.addWidget(self.display, 0, 0, 1, 6)\n        mainLayout.addWidget(self.backspaceButton, 1, 0, 1, 2)\n        mainLayout.addWidget(self.clearButton, 1, 2, 1, 2)\n        mainLayout.addWidget(self.clearAllButton, 1, 4, 1, 2)\n\n        mainLayout.addWidget(self.clearMemoryButton, 2, 0)\n        mainLayout.addWidget(self.readMemoryButton, 3, 0)\n        mainLayout.addWidget(self.setMemoryButton, 4, 0)\n        mainLayout.addWidget(self.addToMemoryButton, 5, 0)\n\n        for i in range(1, Calculator.NumDigitButtons):\n            row = ((9 - i) / 3) + 2\n            column = ((i - 1) % 3) + 1\n            mainLayout.addWidget(self.digitButtons[i], row, column)\n\n        mainLayout.addWidget(self.digitButtons[0], 5, 1)\n        mainLayout.addWidget(self.pointButton, 5, 2)\n        mainLayout.addWidget(self.changeSignButton, 5, 3)\n\n        mainLayout.addWidget(self.divisionButton, 2, 4)\n        mainLayout.addWidget(self.timesButton, 3, 4)\n        mainLayout.addWidget(self.minusButton, 4, 4)\n        mainLayout.addWidget(self.plusButton, 5, 4)\n\n        mainLayout.addWidget(self.squareRootButton, 2, 5)\n        mainLayout.addWidget(self.powerButton, 3, 5)\n        mainLayout.addWidget(self.reciprocalButton, 4, 5)\n        mainLayout.addWidget(self.equalButton, 5, 5)\n        self.setLayout(mainLayout)\n\n        self.setWindowTitle("Calculator")\n\n    def digitClicked(self):\n        clickedButton = self.sender()\n        digitValue = int(clickedButton.text())\n\n        if self.display.text() == \'0\' and digitValue == 0.0:\n            return\n\n        if self.waitingForOperand:\n            self.display.clear()\n            self.waitingForOperand = False\n\n        self.display.setText(self.display.text() + str(digitValue))\n\n    def unaryOperatorClicked(self):\n        clickedButton = self.sender()\n        clickedOperator = clickedButton.text()\n        operand = float(self.display.text())\n\n        if clickedOperator == "Sqrt":\n            if operand < 0.0:\n                self.abortOperation()\n                return\n\n            result = math.sqrt(operand)\n        elif clickedOperator == u"x\\N{SUPERSCRIPT TWO}":\n            result = math.pow(operand, 2.0)\n        elif clickedOperator == "1/x":\n            if operand == 0.0:\n                self.abortOperation()\n                return\n\n            result = 1.0 / operand\n\n        self.display.setText(str(result))\n        self.waitingForOperand = True\n\n    def additiveOperatorClicked(self):\n        clickedButton = self.sender()\n        clickedOperator = clickedButton.text()\n        operand = float(self.display.text())\n\n        if self.pendingMultiplicativeOperator:\n            if not self.calculate(operand, self.pendingMultiplicativeOperator):\n                self.abortOperation()\n                return\n\n            self.display.setText(str(self.factorSoFar))\n            operand = self.factorSoFar\n            self.factorSoFar = 0.0\n            self.pendingMultiplicativeOperator = \'\'\n\n        if self.pendingAdditiveOperator:\n            if not self.calculate(operand, self.pendingAdditiveOperator):\n                self.abortOperation()\n                return\n\n            self.display.setText(str(self.sumSoFar))\n        else:\n            self.sumSoFar = operand\n\n        self.pendingAdditiveOperator = clickedOperator\n        self.waitingForOperand = True\n\n    def multiplicativeOperatorClicked(self):\n        clickedButton = self.sender()\n        clickedOperator = clickedButton.text()\n        operand = float(self.display.text())\n\n        if self.pendingMultiplicativeOperator:\n            if not self.calculate(operand, self.pendingMultiplicativeOperator):\n                self.abortOperation()\n                return\n\n            self.display.setText(str(self.factorSoFar))\n        else:\n            self.factorSoFar = operand\n\n        self.pendingMultiplicativeOperator = clickedOperator\n        self.waitingForOperand = True\n\n    def equalClicked(self):\n        operand = float(self.display.text())\n\n        if self.pendingMultiplicativeOperator:\n            if not self.calculate(operand, self.pendingMultiplicativeOperator):\n                self.abortOperation()\n                return\n\n            operand = self.factorSoFar\n            self.factorSoFar = 0.0\n            self.pendingMultiplicativeOperator = \'\'\n\n        if self.pendingAdditiveOperator:\n            if not self.calculate(operand, self.pendingAdditiveOperator):\n                self.abortOperation()\n                return\n\n            self.pendingAdditiveOperator = \'\'\n        else:\n            self.sumSoFar = operand\n\n        self.display.setText(str(self.sumSoFar))\n        self.sumSoFar = 0.0\n        self.waitingForOperand = True\n\n    def pointClicked(self):\n        if self.waitingForOperand:\n            self.display.setText(\'0\')\n\n        if "." not in self.display.text():\n            self.display.setText(self.display.text() + ".")\n\n        self.waitingForOperand = False\n\n    def changeSignClicked(self):\n        text = self.display.text()\n        value = float(text)\n\n        if value > 0.0:\n            text = "-" + text\n        elif value < 0.0:\n            text = text[1:]\n\n        self.display.setText(text)\n\n    def backspaceClicked(self):\n        if self.waitingForOperand:\n            return\n\n        text = self.display.text()[:-1]\n        if not text:\n            text = \'0\'\n            self.waitingForOperand = True\n\n        self.display.setText(text)\n\n    def clear(self):\n        if self.waitingForOperand:\n            return\n\n        self.display.setText(\'0\')\n        self.waitingForOperand = True\n\n    def clearAll(self):\n        self.sumSoFar = 0.0\n        self.factorSoFar = 0.0\n        self.pendingAdditiveOperator = \'\'\n        self.pendingMultiplicativeOperator = \'\'\n        self.display.setText(\'0\')\n        self.waitingForOperand = True\n\n    def clearMemory(self):\n        self.sumInMemory = 0.0\n\n    def readMemory(self):\n        self.display.setText(str(self.sumInMemory))\n        self.waitingForOperand = True\n\n    def setMemory(self):\n        self.equalClicked()\n        self.sumInMemory = float(self.display.text())\n\n    def addToMemory(self):\n        self.equalClicked()\n        self.sumInMemory += float(self.display.text())\n\n    def createButton(self, text, member):\n        button = Button(text)\n        button.clicked.connect(member)\n        return button\n\n    def abortOperation(self):\n        self.clearAll()\n        self.display.setText("####")\n\n    def calculate(self, rightOperand, pendingOperator):\n        if pendingOperator == "+":\n            self.sumSoFar += rightOperand\n        elif pendingOperator == "-":\n            self.sumSoFar -= rightOperand\n        elif pendingOperator == u"\\N{MULTIPLICATION SIGN}":\n            self.factorSoFar *= rightOperand\n        elif pendingOperator == u"\\N{DIVISION SIGN}":\n            if rightOperand == 0.0:\n                return False\n\n            self.factorSoFar /= rightOperand\n\n        return True\n\n\nif __name__ == \'__main__\':\n\n    import sys\n\n    app = QApplication(sys.argv)\n    calc = Calculator()\n    calc.show()\n    sys.exit(app.exec_()) \n 參考資料: \n QApplication \n QtWidgets \n QDialog \n PyQt5 Signals and Slots \n Qt 視窗計算器程式  (以 C++ 編寫) \n', 'tags': '', 'url': '計算器.html'}, {'title': 'Tinkercad', 'text': "註冊 AutoDesk TinkerCAD 帳號 \n 為了在實體 Arduino Uno 控制板連線操作之前, 可以利用網際 Auduino 控制板與電子元件系統進行模擬, 請各學員至   https://www.tinkercad.com   登記帳號, 登入後選擇左上角的 TinkerCAD 標誌連結後, 選擇 Circuits 進入電路設計與模擬, 操作畫面如下圖所示: \n \n 接著選擇 Arudino Uno 控制板與 Servo Motor, 然後接上電源與地線, 並將控制訊號接到 Auduino Uno 控制板的 PWM pin 9, 利用 Code Editor 納入下列 Arduino 程式, 再利用 upload and run 將程式編譯後上傳到虛擬的 Arduino Uno 控制板上執行, 就可以模擬 Servo Motor 持續左右各旋轉 180 度. 操作畫面如下圖所示:  \n \n 實體 Arduino Servo Motor Control \n 完成上述以 TinkerCAD 模擬伺服馬達的接線與程式執行之後, 接著操作實體 Arduino 控制板與 Servo Motor 的控制, 首先利用電腦驅動 Arduino 控制板, 然後再利用板子上的脈衝寬度調變 (PWM, Pulse Width Modulation) 訊號控制伺服馬達, 之後再利用傳動機構與資訊控制介面, 製作所需的機電資整合系統. 電子電機系統除了可以方便感測各種物理化學量外, 還能夠快速傳遞感測與命令訊號, 而機械系統則透過機構元件的組合, 扮演傳遞功率致動或抵抗外力撞擊與疲勞破壞的角色, 至於資訊系統則用來整合各種資訊, 用更友善的人機介面, 讓使用者更有效能地運用機電資系統產品. \n arduino-1.8.4-windows.zip   下載 (或直至   https://www.arduino.cc/en/Main/Software   下載) \n 控制台 - 硬體與音效 - 裝置管理員 利用解開的 arduino driver 程式驅動 Arduino Uno 控制板, 並取得 COM 對應號碼, 例如: COM7, 之後的 Arduino 編譯後可以透過此 COM 埠號將程式上傳到控制板上執行. \n MG996R 伺服馬達 \n 棕色線 GND \n 紅色線 V+5V \n 橘色線 PWM \n 控制程式: \n #include <Servo.h>\nServo myservo;  // 建立一個 servo 物件，最多可建立 12個 servo\n\nint pos = 0;    // 設定 Servo 位置的變數\n\nvoid setup() {\n  myservo.attach(9);  // 將 servo 物件連接到 pin 9\n}\n\nvoid loop() {\n  // 正轉 180度\n  for (pos = 0; pos <= 180; pos += 1) // 從 0 度旋轉到 180 度，每次 1 度 \n  {     \n    myservo.write(pos);               // 告訴 servo 走到 'pos' 的位置\n    delay(15);                        // 等待 15ms 讓 servo 走到指定位置\n  }\n\n// 反轉 180度\n  for (pos = 180; pos >= 0; pos -= 1) // 從 180 度旋轉到 0 度，每次 1 度 \n  { \n    myservo.write(pos);               // 告訴 servo 走到 'pos' 的位置\n\ndelay(15);                        // 等待 15ms 讓 servo 走到指定位置\n  }\n} \n 參考資料: \n Beginning Arduino \n Beginning Arduino Programming \n http://www.playrobot.com/20kgf-cm/1150-standard-servo-mg996r.html \n http://www.playrobot.com/freedownload/Arduino_Happy%20Learning_DEMO.pdf \n http://atceiling.blogspot.tw/2017/03/arduino.html \n Python, Arduino and VPython: \n http://www.toptechboy.com/arduino-lessons/ \n Arduino Magnetic Levitation System \n http://www.instructables.com/id/Magnetic-Levitation/   ( 電磁鐵1 ,   電磁鐵2 ) \n Arduino and PyQt5 \n http://embeddedlaboratory.blogspot.tw/search/label/Arduino \n Arduino and Matplotlib \n", 'tags': '', 'url': 'Tinkercad.html'}, {'title': '讀寫網頁內容', 'text': 'Onshape 教學影片 \n https://www.onshape.com/video   為 Onshpae 官方網站所提供的教學影片區, 請各班以每人兩個影片的方式進行分配, 分別以中文說明影片內容操作過程, 並上傳到個人的 Vimeo 與 Youtube 影片區. \n 預計分配的影片: \n https://www.onshape.com/videos/topic/tech-tips \n https://www.onshape.com/videos/topic/intro-to-cad \n https://www.onshape.com/videos/topic/tutorials \n https://www.onshape.com/videos/topic/essential-training \n https://www.onshape.com/videos/topic/drawings \n 請各組討論: \n 如何分配影片?如何集合管理各學員所上傳的教學操作影片? \n 利用 Python3, urllib 與 bs4 解讀上述網頁內容, 取出各影片的連結, 然後放入數列中: \n from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\n\nfile = urlopen("https://www.onshape.com/videos/topic/intro-to-cad")\n#print(file.read().decode())\n\nsoup = BeautifulSoup(file, \'html.parser\')\n\nlinks = []\nfor link in soup.find_all(\'a\', href=True):\n    if \'videos\' in link[\'href\']:\n        if \'https\' in link[\'href\']:\n            #print(link[\'href\'])\n            links.append(link[\'href\'])\nresult = list(set(links))\nfor i in range(len(result)):\n    print(i+1, result[i]) \n 納入上述所有影片網頁連結, 利用程式取出各影片的連結字串: \n # 從 urllib 模組中導入 urlopen\nfrom urllib.request import urlopen\n# 從 bs4 模組中導入 BeautirulSoup\nfrom bs4 import BeautifulSoup\n\n# 將要取出影片連結的網站 url,  放入數列中, 取名為 sources\nsources = [\'https://www.onshape.com/videos/topic/tech-tips\', \'https://www.onshape.com/videos/topic/intro-to-cad\', \'https://www.onshape.com/videos/topic/tutorials\', \'https://www.onshape.com/videos/topic/essential-training\', \'https://www.onshape.com/videos/topic/drawings\']\n\n#tech-tips (60)\n#intro-to-cad (26)\n#tutorials (14)\n#essential-training (6)\n#drawings (5)\n\n# 按照網頁中的影片數計算, 共有 111 部影片, 但分類中可能重複\nprint(60+26+14+6+5)\n\n# 設 links 變數與空數列對應\nlinks = []\n# 利用 for 迴圈一一取出各網頁的 html 後, 進行解讀\n# 只取出有 videos 與 https 連結的資料, 但避開 all 與 topic 類別連結\nfor url in sources:\n    file = urlopen(url)\n    # 因為 urlopen 出來的資料為二位元檔案, 若要讀出列印\n    # 必須要先 decode() 為字串\n    #print(file.read().decode())\n    # 使用 html 解讀各連結的網頁內容\n    soup = BeautifulSoup(file, \'html.parser\')\n    # 利用 Beautifulsoup 物件中的 find_all 方法尋找 anchor\n    for link in soup.find_all(\'a\', href=True):\n        # 從各 anchor 資料篩選所需的影片連結\n        if (\'videos\' or \'https\') in link[\'href\']:\n            if \'all\' not in link[\'href\']:\n                if \'topic\' not in link[\'href\']:\n                    links.append(link[\'href\'])\n                    \n# 為避免列出重複資料, 將數列轉為集合後, 再轉回數列\nresult = list(set(links))\n# 逐一列出所取得的影片連結\nfor i in range(len(result)):\n    print(i+1, result[i]) \n 從   IPV6 相關 RFCs 查詢 得到的資料中, 如何在各組的網誌中整理一份能夠連結到各個未過時 (non-obsolete) 的 RFC 文件? \n 參考程式碼: \n data = open("midterm_list.txt").read()\nline_list = data.splitlines()\ncount = 0\nfor line in line_list:\n    each_line_list = line.split("\\t")\n    try:\n        if "Obsoleted" in each_line_list[5]:\n            count = count + 1\n            print(each_line_list[0])\n    except:\n        pass\nprint(count) \n 若以 Brython 改寫, 可以直接將結果列在網頁上: \n <div id="container"></div>\n \n<script type="text/python3" id="script1">\nfrom browser import document, html\ncontainer = document[\'container\']\ndata = open("./../midterm_list.txt").read()\nline_list = data.splitlines()\ncount = 0\noutput = ""\nfor line in line_list:\n    each_line_list = line.split("\\t")\n    try:\n        if "Obsoleted" not in each_line_list[5]:\n            count = count + 1\n            output += html.A(each_line_list[0], href="http://www.rfc-editor.org/info/"+ each_line_list[0].lower().replace(" ", "")) + " | "\n            if count%10 == 0:\n                output += html.BR()\n    except:\n        pass\noutput += html.BR() + html.BR()  + "共有 " + str(count)+ " 份文件尚未失效!"\ncontainer <= output\n</script> \n 以下則利用 Brython 讀取網站上的資料檔, 進行處理後, 將結果插入網頁: \n <!-- 導入 Brython 標準程式庫 -->\n<script type="text/javascript" src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js">\n</script>\n \n<!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython(1);\n}\n</script>\n \n<!-- 以下利用 Brython 程式執行檔案讀取與比對流程 -->\n<!-- 假如需要用圖型表示數字, 則利用 canvas 繪圖 -->\n<!-- <canvas id="plotarea" width="600" height="400"></canvas> -->\n \n甲班學員投影片:\n \n<div id="container1"></div>\n \n<script type="text/python3" id="script1">\nfrom browser import document, html\ncontainer1 = document[\'container1\']\nadata = open("./../users/a.txt").read()\nalist = adata.splitlines()\nn = 0\nfor stud_num in alist:\n    if stud_num == "40523148":\n        mlink = html.A(stud_num, href="http://ss"+str(stud_num)+".github.io/2016fallcp_hw")\n    else:\n        mlink = html.A(stud_num, href="http://s"+str(stud_num)+".github.io/2016fallcp_hw")\n    mlink += " | "\n    n = n +1\n    if n%8 == 0:\n        mlink += html.BR()\n    container1 <= mlink\n</script>\n \n<br>\n甲班學員網誌:\n \n<div id="container2"></div>\n \n<script type="text/python3" id="script2">\nfrom browser import document, html\n# 學員選課名單直接從 id 為 script1 的程式段中導入\nfrom script1 import alist\ncontainer2 = document[\'container2\']\nn = 0\nfor stud_num in alist:\n    if stud_num == "40523148":\n        mlink = html.A(stud_num, href="http://ss"+str(stud_num)+".github.io/2016fallcp_hw/blog")\n    else:\n        mlink = html.A(stud_num, href="http://s"+str(stud_num)+".github.io/2016fallcp_hw/blog")\n    mlink += " | "\n    n = n +1\n    if n%8 == 0:\n        mlink += html.BR()\n    container2 <= mlink\n</script> \n 參考資料: \n 網頁選色:  http://paletton.com   \n 顏色轉換:  https://www.w3schools.com/colors/colors_converter.asp   \n', 'tags': '', 'url': '讀寫網頁內容.html'}, {'title': '查英文單字', 'text': '利用 Python 程式協助查英文單字 \n 查單字程式碼: \n import urllib.request\nfrom bs4 import BeautifulSoup\nimport sys, codecs\n# 將系統輸出語系編碼設為 utf8\nsys.stdout = codecs.getwriter("utf8")(sys.stdout.detach())\n# 表示要讀入的文章檔名為 wed.txt\nfilename = "wed"\n\n"""\n Project: Concordancer Jr.\n File name: concordance.py\n Description:  Counts up the number of each unique word in a block of plain text.\n\n Copyright (C) 2010 Steve Osborne, srosborne (at) gmail.com\n http://yakinikuman.wordpress.com/\n *******\n This program is free software; you can redistribute it and/or modify \n it under the terms of the GNU General Public License as published by \n the Free Software Foundation; either version 2 of the License, or \n (at your option) any later version.\n\n This program is distributed in the hope that it will be useful, but \n WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License \n for more details.\n\n You should have received a copy of the GNU General Public License\n along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n *******\n Version history:\n 1.0   Oct 27 2010\n 2.0      Nov 11, 2010 - put into a class.  Can now be called with any block of text.\n\n"""\n\nclass Concordancer:\n    def __init__(self):\n        #from http://www.duboislc.org/EducationWatch/First100Words.html\n        #some common words a little fishy... "water"? "oil"??  But no "am"???\n        self.common = [\'the\',\'of\',\'and\',\'a\',\'to\',\'in\',\'is\',\'you\',\'that\',\'it\',\n            \'he\',\'was\',\'for\',\'on\',\'are\',\'as\',\'with\',\'his\',\'they\',\'i\',\n            \'at\',\'be\',\'this\',\'have\',\'from\',\'or\',\'one\',\'had\',\'by\',\'word\',\n            \'but\',\'not\',\'what\',\'all\',\'were\',\'we\',\'when\',\'your\',\'can\',\'said\',\n            \'there\',\'use\',\'an\',\'each\',\'which\',\'she\',\'do\',\'how\',\'their\',\'if\',\n            \'will\',\'up\',\'other\',\'about\',\'out\',\'many\',\'then\',\'them\',\'these\',\'so\',\n            \'some\',\'her\',\'would\',\'make\',\'like\',\'him\',\'into\',\'time\',\'has\',\'look\',\n            \'two\',\'more\',\'write\',\'go\',\'see\',\'number\',\'no\',\'way\',\'could\',\'people\',\n            \'my\',\'than\',\'first\',\'water\',\'been\',\'call\',\'who\',\'oil\',\'its\',\'now\',\n            \'find\',\'long\',\'down\',\'day\',\'did\',\'get\',\'come\',\'made\',\'may\',\'part\']\n\n        self.wordIndex = dict() #will be a count of each word in the input text\n        self.total = 0 #total words\n        self.unique = 0 #unique words\n\n    def getCommon(self):\n        return self.common\n\n    def updateCommon(self,newCommon):\n        #newCommon is a list of words to be used on future calls to topWordsNotCommon\n        self.common = newCommon\n\n    def extendCommon(self,newCommon):\n        #newCommon is a list of words to be added to self.common\n        self.common.extend(newCommon)\n\n    def populateIndex(self,data):\n        #data is a block of text\n        #splits up data and adds each word to the index\n        #repeated calls to populateIndex will NOT clear the index - will just keep adding up words in new block of text\n        for word in data.split():#splits at and removes whitespace\n            self.addword(word)\n        self.calculateUniqueWords()\n        self.calculateTotalWords()\n\n    def addword(self,word):\n        word = word.translate("0123456789.!?,;:*\\)\\(\\[\\]\\\\\\n/\'\\"")#remove punctuation, numbers, and newlines\n\n        if len(word) > 5 and word.isalpha():\n            word = word.lower()#convert to lower case\n            #special case of dashes "--": separate into two words\n            if "--" in word:\n                words = word.replace(\'--\',\' \')\n                for w in words.split():\n                    self.addword(w)\n            elif word in self.wordIndex:\n                self.wordIndex[word] = self.wordIndex[word] + 1\n            else:\n                self.wordIndex[word] = 1\n\n    def getSortedIndex(self):\n        #note - sorted returns a list of tuples, not a dictionary\n        s1 = sorted(list(self.wordIndex.items()),key=lambda item:item[0]) #secondary key: sort alphabetically\n        s2 = sorted(s1,key=lambda item:item[1], reverse=True) #primary key: sort by count\n        return s2\n\n    def calculateUniqueWords(self):\n        self.unique = len(self.wordIndex)\n\n    def calculateTotalWords(self):\n        total = 0\n        for word in list(self.wordIndex.keys()):\n            total = total + self.wordIndex[word]\n        self.total = total\n\n    def topWords(self,n,fExcludeCommon=1):\n        #run only after "populateIndex" for meaningful output\n        #returns list of top min(n,unique) words in the index\n        #fExcludeCommon: if 1 [default], excludes any words in self.common.  Set to 0 to include all words.\n        #returns list of (word,count) pairs for the top n words.  \'count\' is the count of that word.\n        s2 = self.getSortedIndex()\n        lwords = []\n        i = 0\n        while len(lwords) < n and i < self.unique:\n            key = s2[i][0]\n            value = s2[i][1]\n            item = (key,value)\n            if fExcludeCommon:\n                if key not in self.common:\n                    lwords.append(item)\n            else:\n                lwords.append(item)\n            i = i + 1\n        return lwords\n\n# 以上為統計文章中單字出現次數的類別\n\ndef chk_dict(單字):\n    url = \'http://dictionary.sina.com.tw/word/ec/\'\n    response = urllib.request.urlopen(url+單字)\n    text = response.read()\n    try:\n        html_doc = text.decode("utf-8")\n    except:\n        html_doc = text.decode("latin-1")\n    return html_doc\n\ndef parse_doc(網頁超文件):\n    all_text = ""\n    soup = BeautifulSoup(網頁超文件)\n    div_tag = soup.findAll(\'div\',{\'class\',"word_text1"})\n    for i in range(len(div_tag)):\n        all_text += div_tag[i].get_text()\n    return all_text+"\\n"\n\n# 用來統計單字次序的全域變數\nword_count = 0\n\ndef 查單字(單字):\n    global word_count\n    html_doc = chk_dict(單字)\n    our_text = parse_doc(html_doc)\n    if our_text == "\\n":\n        word_def = "查不到與 "+單字+" 有關的資料\\n"\n    else:\n        word_count += 1\n        word_def = str(word_count)+". "+單字+":\\n"\n        word_def += our_text\n    word_def += "_"*50+"\\n"\n    return word_def\n\n# 檔案是要將結果存檔用的 handle\n檔案 = open("words_"+filename+".txt", "w", encoding="UTF-8")\n\n# 以下為統計文章單字用的程式呼叫\nconcord = Concordancer()\nfile = filename+\'.txt\'\nf = open(file,\'rt\',encoding="utf-8")\ndata = f.read()#the whole file as one big string\nconcord.populateIndex(data)\n\nn = concord.unique\nprint("Top %s words:" % n)\ntop = concord.topWords(n)\n\n# 隨後的 key 就是單字\norder = 0\nall_text = ""\nfor item in top:\n    order += 1\n    key = item[0]\n    value = item[1]\n    #print(order,"%s:%s" % (key,value))\n    print(order,key,value)\n    all_text += 查單字(key)\n\n檔案.write(all_text)\nprint("done") \n 英文字典檔案處理 \n WebsterUnabridgedDictionary.txt \n #coding: utf-8\n# 檔案內容讀取範例\n檔案 = open("WebsterUnabridgedDictionary.txt",encoding="UTF-8")\ncount = 0\n所有資料 = 檔案.readlines()\nprint("這個檔案共有:"+str(len(所有資料))+"行")\n\nfor 行數 in range(len(所有資料)):\n    # 若該行的所有字母都是大寫, 表示為單字開頭\n    行資料 = 所有資料[行數].rstrip()\n    if(行資料.isupper()):\n        # 列出單字\n        #print(行資料.encode("UTF-8"))\n        count += 1\n    else:\n        # 列出單字的所屬解釋\n        #print("解釋", end="")\n        #print(行資料.encode("UTF-8"))\n        continue\n\nprint("單字數共有:"+str(count)+"個")\n檔案.close() # 關閉檔案\n \n \n', 'tags': '', 'url': '查英文單字.html'}, {'title': 'docx 轉 pdf', 'text': '用來學習 Onshape 的教學檔案格式為 docx, 以下使用 Windows 環境下的 Python3 程式, 自動進入各教學檔案目錄, 將 docx 轉為 pdf \n 首先必須以 pip install comtypes 安裝 comtypes 模組, 然後以 SciTE, 在教學檔案目錄中, 利用以下程式碼建立 docx2pdf.py 後執行, 即可將所有 56 個 docx 轉出 pdf 檔案. 之後, 可以再設法利用  https://github.com/coolwanglu/pdf2htmlEX  以程式方法, 直接將 pdf 轉為 html.  \n import sys\nimport os\nimport comtypes.client\n \nwdFormatPDF = 17\n \n#in_file = input("input docx")\n#out_file = input("output filename")\n \ndef docx2pdf(in_file, out_file):\n    word = comtypes.client.CreateObject(\'Word.Application\')\n    doc = word.Documents.Open(in_file)\n    doc.SaveAs(out_file, FileFormat=wdFormatPDF)\n    doc.Close()\n    word.Quit()\n \ncount = 0\n# traverse root directory, and list directories as dirs and files as files\nfor root, dirs, files in os.walk(os.getcwd()):\n    #print(root)\n    path = root.split(\'/\')\n    #print(path)\n    #print((len(path) - 1) * \'---\', os.path.basename(root))\n    #print(files)\n    for file in files:\n        #print(len(path) * \'---\', file)\n        file_ext = file.split(".")[1]\n        file_name = file.split(".")[0]\n        #print(file_ext)\n        if file_ext == "docx":\n            count = count + 1\n            in_file = path[0] + "/" + file\n            #print(count,":", in_file)\n            out_file = path[0] + "/" + file_name + ".pdf"\n            #print(out_file)\n            docx2pdf(in_file, out_file)\n \n#print(count)\n#docx2pdf(in_file, out_file)\nprint("done") \n \n', 'tags': '', 'url': 'docx 轉 pdf.html'}, {'title': '網際繪圖', 'text': '網頁中有三種基本元素 HTML5, CSS 與 Javascript, 透過  Brython  或  Fengari-web , 使用者可以使用 Python 及 Lua 替代 Javascript. \n Canvas 程式庫: \n https://github.com/konvajs/konva \n https://konvajs.github.io/docs/ \n https://www.arc.id.au/CanvasGraphics.html \n 參考資料:  \n Pro HTML5 with CSS, JavaScript, and Multimedia.pdf \n web technology.pdf \n http://worrydream.com/#!/LearnableProgramming   \n  啟動 brython() 暫時不用\n<p>\n<script>\nwindow.onload=function(){\nbrython(1);\n}\n</script>\n  以下利用 Brython 程式執行繪圖 暫時不用\n<p><canvas id="taiwan_flag" width="300" height="200"></canvas></p>\n<p>\n<script type="text/python3">\n# 導入 doc\nfrom browser import document as doc\nimport math\n\n# 準備繪圖畫布\ncanvas = doc["taiwan_flag"]\nctx = canvas.getContext("2d")\n# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點\n# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)\n# 以下採用 canvas 原始座標繪圖\nflag_w = canvas.width\nflag_h = canvas.height\ncircle_x = flag_w/4\ncircle_y = flag_h/4\n# 先畫滿地紅\nctx.fillStyle=\'rgb(255, 0, 0)\'\nctx.fillRect(0,0,flag_w,flag_h)\n# 再畫青天\nctx.fillStyle=\'rgb(0, 0, 150)\'\nctx.fillRect(0,0,flag_w/2,flag_h/2)\n# 畫十二道光芒白日\nctx.beginPath()\nstar_radius = flag_w/8\nangle = 0\nfor i in range(24):\n    angle += 5*math.pi*2/12\n    toX = circle_x + math.cos(angle)*star_radius\n    toY = circle_y + math.sin(angle)*star_radius\n    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo\n    if (i):\n        ctx.lineTo(toX, toY)\n    else:\n        ctx.moveTo(toX, toY)\nctx.closePath()\n# 將填色設為白色\nctx.fillStyle = \'#fff\'\nctx.fill()\n# 白日:藍圈\nctx.beginPath()\nctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)\nctx.closePath()\n# 填色設為藍色\nctx.fillStyle = \'rgb(0, 0, 149)\'\nctx.fill()\n# 白日:白心\nctx.beginPath()\nctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)\nctx.closePath()\n# 填色設為白色\nctx.fillStyle = \'#fff\'\nctx.fill()\n</script>\n \n \n 上圖原始碼: \n <!-- for Brython -->\n<script src="https://scrum-3.github.io/web/brython/brython.js"></script>\n<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>\n<!-- 啟動 brython() -->\n<p>\n<script>\nwindow.onload=function(){\nbrython(1);\n}\n</script>\n</p>\n<!-- 以下利用 Brython 程式執行繪圖 -->\n<p><canvas id="taiwan_flag" width="300" height="200"></canvas></p>\n<p>\n<script type="text/python3">\n# 導入 doc\nfrom browser import document as doc\nimport math\n\n# 準備繪圖畫布\ncanvas = doc["taiwan_flag"]\nctx = canvas.getContext("2d")\n# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點\n# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)\n# 以下採用 canvas 原始座標繪圖\nflag_w = canvas.width\nflag_h = canvas.height\ncircle_x = flag_w/4\ncircle_y = flag_h/4\n# 先畫滿地紅\nctx.fillStyle=\'rgb(255, 0, 0)\'\nctx.fillRect(0,0,flag_w,flag_h)\n# 再畫青天\nctx.fillStyle=\'rgb(0, 0, 150)\'\nctx.fillRect(0,0,flag_w/2,flag_h/2)\n# 畫十二道光芒白日\nctx.beginPath()\nstar_radius = flag_w/8\nangle = 0\nfor i in range(24):\n    angle += 5*math.pi*2/12\n    toX = circle_x + math.cos(angle)*star_radius\n    toY = circle_y + math.sin(angle)*star_radius\n    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo\n    if (i):\n        ctx.lineTo(toX, toY)\n    else:\n        ctx.moveTo(toX, toY)\nctx.closePath()\n# 將填色設為白色\nctx.fillStyle = \'#fff\'\nctx.fill()\n# 白日:藍圈\nctx.beginPath()\nctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)\nctx.closePath()\n# 填色設為藍色\nctx.fillStyle = \'rgb(0, 0, 149)\'\nctx.fill()\n# 白日:白心\nctx.beginPath()\nctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)\nctx.closePath()\n# 填色設為白色\nctx.fillStyle = \'#fff\'\nctx.fill()\n</script>\n</p> \n 擷取網際資料: \n https://www.e-education.psu.edu/geog489/node/2331   \n import requests \nfrom bs4 import BeautifulSoup \n \nurl = "https://mdecourse.github.io/cp2018/content/index.html"\nresponse = requests.get(url) \nsoup = BeautifulSoup(response.text, \'html.parser\') \n \nprint(soup.find(\'title\')) \n Brython 日期列印程式: \n <script src="https://scrum-3.github.io/web/brython/brython.js"></script>\n<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>\n</p>\n<div id="cal2"></div>\n<p>\n<script>\nwindow.onload=function(){\nbrython(1);\n}\n</script>\n<script type="text/python3">\nfrom browser import document, html\nimport calendar\nimport locale\n \ncal2 = document["cal2"]\n \ndef getClassdate(year=2018, startM=9, startD=10, w=0, note=""):\n    # w=0 表示課程排在星期一\n    # startM 表示開學月份, startD 表示開學日\n    # note 為課程初始告示\n    # default calendar MONDAY is the first day of the week\n    # 每學期共有 18 週\n    totalW = 18\n    count = 0\n    # output = "2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: "\n    output = note + html.BR()\n    # 若必須全年搜尋則 7 改為 12, 但是因為只有 18 週, 因此邏輯要修改讓程式較快結束\n    for month in range(startM, 13):\n        monthArray = calendar.monthcalendar(2018, month)\n        for week in range(len(monthArray)):\n            weekArray = monthArray[week]\n            # 只需要列出星期 (w+1)\n            if weekArray[w] != 0:\n                if month == startM:\n                    if weekArray[w] > startD:\n                        count += 1\n                        if count <= totalW:\n                            if month == 3 and weekArray[w] == 31:\n                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "\n                            else:\n                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "\n                else:\n                    count += 1\n                    if count <=  totalW:\n                        if month == 3 and weekArray[w] == 31:\n                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "\n                        else:\n                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "\n    cal2 <= output\n \n# 2b 電腦輔助設計實習 (一 w=0)\ngetClassdate(year=2018, startM=9, startD=9, w=0, note="2018 Fall 2bCADP (一) 09:10-12:00 各週上課日期: ")\ncal2 <= html.BR() + html.BR()\n# 1b 計算機程式 (一 w=0)\ngetClassdate(year=2018, startM=9, startD=9, w=0, note="2018 Fall 1bCP (一) 13:20-16:10 各週上課日期: ")\ncal2 <= html.BR() + html.BR()\n# 2a 電腦輔助設計實習 (五 w=4)\ngetClassdate(year=2018, startM=9, startD=9, w=4, note="2018 Fall 2aCADP (五) 09:10-12:00 各週上課日期: ")\ncal2 <= html.BR() + html.BR()\n# 1a 計算機程式 (五 w=4)\ngetClassdate(year=2018, startM=9, startD=9, w=4, note="2018 Fall 1aCP (五) 13:20-16:10 各週上課日期: ")\ncal2 <= html.BR() + html.BR()\n# ve1a 計算機程式 (五 w=4)\ngetClassdate(year=2018, startM=9, startD=9, w=4, note="2018 Fall ve1aCP (五) 18:30-20:00 各週上課日期: ")\ncal2 <= html.BR() + html.BR()\n</script> \n \n \n \n 列印結果: \n \n \n 2018 Fall 2bCADP (一) 09:10-12:00 各週上課日期:  w1-9/10, w2-9/17, w3-9/24, w4-10/1, w5-10/8, w6-10/15, w7-10/22, w8-10/29, w9-11/5, w10-11/12, w11-11/19, w12-11/26, w13-12/3, w14-12/10, w15-12/17, w16-12/24, w17-12/31, \n 2018 Fall 1bCP (一) 13:20-16:10 各週上課日期:  w1-9/10, w2-9/17, w3-9/24, w4-10/1, w5-10/8, w6-10/15, w7-10/22, w8-10/29, w9-11/5, w10-11/12, w11-11/19, w12-11/26, w13-12/3, w14-12/10, w15-12/17, w16-12/24, w17-12/31, \n 2018 Fall 2aCADP (五) 09:10-12:00 各週上課日期:  w1-9/14, w2-9/21, w3-9/28, w4-10/5, w5-10/12, w6-10/19, w7-10/26, w8-11/2, w9-11/9, w10-11/16, w11-11/23, w12-11/30, w13-12/7, w14-12/14, w15-12/21, w16-12/28, \n 2018 Fall 1aCP (五) 13:20-16:10 各週上課日期:  w1-9/14, w2-9/21, w3-9/28, w4-10/5, w5-10/12, w6-10/19, w7-10/26, w8-11/2, w9-11/9, w10-11/16, w11-11/23, w12-11/30, w13-12/7, w14-12/14, w15-12/21, w16-12/28, \n 2018 Fall ve1aCP (五) 18:30-20:00 各週上課日期:  w1-9/14, w2-9/21, w3-9/28, w4-10/5, w5-10/12, w6-10/19, w7-10/26, w8-11/2, w9-11/9, w10-11/16, w11-11/23, w12-11/30, w13-12/7, w14-12/14, w15-12/21, w16-12/28, \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': '網際繪圖.html'}, {'title': 'GUI 繪圖', 'text': 'PyQt5 與 matplotlib: \n #!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\nimport random\n\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg\nfrom matplotlib.figure import Figure\n\nfrom PyQt5 import QtCore #conda install pyqt\nfrom PyQt5 import QtWidgets\n\nclass MatplotlibWidget(QtWidgets.QWidget):\n    def __init__(self, parent=None):\n        super().__init__()\n\n        self.figure = Figure()\n        self.canvas = FigureCanvasQTAgg(self.figure)\n\n        self.axis = self.figure.add_subplot(111)\n\n        self.layoutVertical = QtWidgets.QVBoxLayout(self)#QVBoxLayout\n        self.layoutVertical.addWidget(self.canvas)\n\nclass ThreadSample(QtCore.QThread):\n    newSample = QtCore.pyqtSignal(list)\n\n    def __init__(self, parent=None):\n        super(ThreadSample, self).__init__(parent)\n\n    def run(self):\n        randomSample = random.sample(range(0, 10), 10)\n\n        self.newSample.emit(randomSample)\n\nclass MyWindow(QtWidgets.QWidget):\n    def __init__(self, parent=None):\n        super().__init__()\n\n        self.pushButtonPlot = QtWidgets.QPushButton(self)\n        self.pushButtonPlot.setText("Plot")\n        self.pushButtonPlot.clicked.connect(self.on_pushButtonPlot_clicked)\n\n        self.matplotlibWidget = MatplotlibWidget(self)\n\n        self.layoutVertical = QtWidgets.QVBoxLayout(self)\n        self.layoutVertical.addWidget(self.pushButtonPlot)\n        self.layoutVertical.addWidget(self.matplotlibWidget)\n\n        self.threadSample = ThreadSample(self)\n        self.threadSample.newSample.connect(self.on_threadSample_newSample)\n        self.threadSample.finished.connect(self.on_threadSample_finished)\n\n    @QtCore.pyqtSlot()\n    def on_pushButtonPlot_clicked(self):\n        self.samples = 0\n        self.matplotlibWidget.axis.clear()\n        self.threadSample.start()\n\n    @QtCore.pyqtSlot(list)\n    def on_threadSample_newSample(self, sample):\n        self.matplotlibWidget.axis.plot(sample)\n        self.matplotlibWidget.canvas.draw()\n\n    @QtCore.pyqtSlot()\n    def on_threadSample_finished(self):\n        self.samples += 1\n        if self.samples <= 2:\n            self.threadSample.start()\n\nif __name__ == "__main__":\n    import sys\n\n    app = QtWidgets.QApplication(sys.argv)\n    app.setApplicationName(\'MyWindow\')\n\n    main = MyWindow()\n    main.resize(666, 333)\n    main.show()\n\n    sys.exit(app.exec()) \n', 'tags': '', 'url': 'GUI 繪圖.html'}, {'title': 'QPainter', 'text': 'PyQt5 共有三種不同的繪圖 API, 即透過 QPaintDevice 子類別 QWidget 繪圖, QGraphicsScene Canvas 繪圖以及 QtQuick 繪圖. \n QWidget 用來繪製典型的 GUI 方形元件, 例如: 按鈕, 查核表單, 下拉式表單等. 因為 QWidget 部件為 QObject 衍生物件, 因此可以直接使用 signals/slots 進行配置. \n QGraphicsScene 則為繪圖場景, 提供場景的上下左右捲動, 縮放與旋轉功能. 而視圖為獨立物件, 因為 QGraphicsItem 並非從 QObject 所衍生, 因此無法直接透過 signals/slots 進行配置, 而必須透過 QGraphicsObject 間接配置. \n QGraphicsScene 繪圖除了使用內建的 lines, rectangles 等外, 若需要執行客製化繪圖, 可利用 QGraphicsItem 物件中的 paint 方法, 以 QPainter 繪圖. \n QtQuick 則是最新加入的繪圖 API, 自 Qt5 版本才納入, 採用 Javascript 技術, 繪圖效率比前兩項更高.採用 QML 而非 C++, 因此可以簡單快速完成所需繪圖內容. QtQuick 除了使用 QML 場景繪圖外, 也可以採 QPainter 繪圖. \n QWidget \n Since QWidget is a subclass of QPaintDevice, subclasses can be used to display custom content that is composed using a series of painting operations with an instance of the QPainter class. This approach contrasts with the canvas-style approach used by the Graphics View Framework where items are added to a scene by the application and are rendered by the framework itself. \n Each widget performs all painting operations from within its paintEvent() function. This is called whenever the widget needs to be redrawn, either as a result of some external change or when requested by the application. \n The QPainter class performs low-level painting on widgets and other paint devices. \n QPainter provides highly optimized functions to do most of the drawing GUI programs require. It can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a "natural" coordinate system, but it can also do view and world transformation. QPainter can operate on any object that inherits the QPaintDevice class. \n The common use of QPainter is inside a widget\'s paint event: Construct and customize (e.g. set the pen or the brush) the painter. Then draw. Remember to destroy the QPainter object after drawing. \n Every widget in QT5 has a method called paintEvent(…) that is called when the widget needs to be drawn (for instance, when its drawn for the first time or when the size of the widget has changed). The only parameter passed to this method is an event object that can be used to get the current dimensions of the content area that we can draw on by calling its rect() method. That means when we want to use a widget for drawing something on it, we derive a new class from the respective widget class and overwrite the paintEvent(…) method with our own implementation that takes care of the drawing. To do the actual drawing, we need to create an object of the class QPainter and then use the drawing methods it provides. Here is a simple example; the details will be explained below: \n Let’s look at the coarse structure first: We are defining a new class derived from QWidget and only overwrite the   paintEvent(…)   method, meaning in all other aspects this widget will behave like an instance of QWidget. In the main code, we simply create an instance of our new widget class and make it show up on the screen. Now, let’s look at the body of method   paintEvent(…) : The first thing to note here is that all drawing needs to be preceded by the creation of the QPainter object (line 31) and the call of its   begin(…) method using “self” as the parameter standing for the widget object itself because that is what we want to draw on (line 32). To conclude the drawing, we need to call the   end()   method of the QPainter object (line 40). \n Next, let us look at the methods of the QPainter object we are invoking that all start with “draw…”. These are the methods provided by QPainter to draw different kinds of entities like text, circles or ellipses, rectangles, images, etc. We here use the method   drawText(…)   twice to produce the two different lines of text (lines 34 and 35). The difference between the two calls is that in the first one we use absolute coordinates, so the text will be drawn at pixel coordinates 20, 20 counting from the top left corner of the widget’s content area. The second call takes a rectangle (class QRectF) as the first parameter and then draws the text within this rectangle based on the additional text options given as the second parameter which here ask for the text to be centered within the rectangle. This is an example where a class provides several methods with the same name but different parameters, something that is called   overloading . If you check out the   documentation of QPainter , you will see that most methods come in different versions. Now go ahead and resize the window a bit and see how the text produced by the first call always remains at the same absolute position, while that from the second call always stays centered within the available area. \n In line 37, we use the method   drawEllipse(…)   to produce the circle. There is no special circle drawing method, so we use this one and then provide the same number for the two radii. To draw the rectangle, we use the method   drawRect(…)   in the version that takes the coordinates of the corner plus width and height values as parameters. \n The remaining calls of methods of the QPainter object are there to affect the way the objects are drawn, e.g. their color. Colors inPyQt5 are represented by instances of the class QColor. In line 33, we create a new QColor object by providing values between 0 and 255 for the color’s red, green, and blue values. Since the red value is 200 and both green and blue are zero, the overall color will be the kind of red that the text appears in. QT5 also has a number of predefined colors that we are using in lines 36 (Qt.darkGreen) and 38 (Qt.blue). \n QPainter uses objects of class   QPen   and   QBrush   to draw the boundary and inside of a shape. In line 33, it is stated that a pen with red color should be used for the following drawing operations. As a result, both text lines appear in red. In line 36, we create a new QPen object to be used by the QPainter and specify that the color should be dark green, and the line width should be 4. This is used for drawing the circle. In line 38, we do the same with color blue and line width 2, and, in addition, we say that sharp corners should be used for the connection between to adjacent line segments of the shape’s border. This is used for drawing the rectangle. We won’t go further into the details of the different pen and brush properties here but the documentation of the QPen and QBrush classes provide some more examples and explanation. In addition, you will see more use cases in the walkthrough in the next section. \n 直接繪圖: \n from PyQt5.QtWidgets import (QGraphicsView,\n    QGraphicsScene,QApplication)\nfrom PyQt5.QtCore import (QLineF)\n    \nif __name__ == \'__main__\':\n    import sys\n    # 建立應用程式\n    app = QApplication(sys.argv)\n    # 建立場景\n    scene = QGraphicsScene()\n    # 在場景中加入字串\n    scene.addText("場景中的字串!")\n    scene.addLine(QLineF(0, 0, 100, 100))\n    scene.addLine(QLineF(100, 0, 0, 100))\n    # 將場景放入視圖案例中\n    view = QGraphicsView(scene)\n    #顯示視圖\n    view.show()\n    # 執行應用程式\n    sys.exit(app.exec()) \n 在 QWidget 中以 QPainter 繪圖 (必須採 paintEvent 方法) \n 比較採用 Canvas based 的 QGraphicsScene 放入 QGraphicsView 繪圖差異. \n from PyQt5.QtWidgets import (QGraphicsView,\n    QGraphicsScene,QApplication, QWidget)\nfrom PyQt5.QtCore import (Qt, QLineF, QPoint)\nfrom PyQt5.QtGui import (QPainter, QPen, QColor)\n     \nif __name__ == \'__main__\':\n    import sys\n    # 建立應用程式\n    app = QApplication(sys.argv)\n    # 以 canvas 繪圖模式建立場景\n    scene = QGraphicsScene()\n    # 在場景中加入字串\n    scene.addText("場景中的字串!")\n    scene.addLine(QLineF(0, 0, 100, 100))\n    scene.addLine(QLineF(100, 0, 0, 100))\n    # 將場景放入視圖案例中-方法一\n    # view = QGraphicsView(scene)\n    # 將場景放入視圖案例中-方法二, 先建 view 後, \n    # 以 setScene() 將 scene 置入\n    view = QGraphicsView()\n    view.setScene(scene)\n    \n    # 因 QWidget 為 QPaintDevice subclass, \n    # 可以直接在 QWidget 上以 QPainter 繪圖\n    # 建立 QWidget 物件, 以 paintEvent 繪圖\n    class window(QWidget):\n        def __init__(self):\n            super().__init__()\n\n        def paintEvent(self, event): \n            qp = QPainter() \n            qp.begin(self) \n            qp.setPen(QColor(200,0,0)) \n            qp.drawText(20,20, "在固定座標繪字串") \n            qp.drawText(event.rect(), Qt.AlignCenter, "在繪圖區正中央繪字串") \n            qp.setPen(QPen(Qt.darkGreen, 4)) \n            qp.drawEllipse(QPoint(50,60),30,30) \n            qp.setPen(QPen(Qt.blue, 2, join = Qt.MiterJoin)) \n            qp.drawRect(20,60,50,80) \n            qp.end() \n    # 以 window 類別案例建立 win 物件\n    win = window()\n    # 顯示 win 物件內容\n    win.show()\n    # 以 QGraphicsView 作為視窗, 將視圖內容於視窗中央顯示\n    #view.show()\n    # 執行應用程式\n    sys.exit(app.exec()) \n 以 QPainter 繪圖 \n import sys\nfrom PyQt5.QtWidgets import QWidget, QApplication\nfrom PyQt5.QtGui import QPainter, QColor, QFont\nfrom PyQt5.QtCore import Qt\n\nclass Example(QWidget):\n    \n    def __init__(self):\n        super().__init__()\n        \n        self.initUI()\n        \n        \n    def initUI(self):      \n        \n        self.text = "Author"\n\n        self.setGeometry(300, 300, 280, 170)\n        self.setWindowTitle(\'Drawing text\')\n        self.show()\n        \n\n    def paintEvent(self, event):\n\n        qp = QPainter()\n        qp.begin(self)\n        self.drawText(event, qp)\n        qp.end()\n        \n        \n    def drawText(self, event, qp):\n      \n        qp.setPen(QColor(168, 34, 3))\n        qp.setFont(QFont(\'Decorative\', 10))\n        qp.drawText(event.rect(), Qt.AlignCenter, self.text)        \n                \n        \nif __name__ == \'__main__\':\n    \n    app = QApplication(sys.argv)\n    ex = Example()\n    sys.exit(app.exec()) \n Draw points: \n from PyQt5.QtWidgets import QWidget, QApplication\nfrom PyQt5.QtGui import QPainter\nfrom PyQt5.QtCore import Qt\nimport sys, random\n\nclass Example(QWidget):\n    \n    def __init__(self):\n        super().__init__()\n        \n        self.initUI()\n        \n        \n    def initUI(self):      \n\n        self.setGeometry(300, 300, 300, 190)\n        self.setWindowTitle(\'Points\')\n        self.show()\n        \n\n    def paintEvent(self, e):\n\n        qp = QPainter()\n        qp.begin(self)\n        self.drawPoints(qp)\n        qp.end()\n        \n        \n    def drawPoints(self, qp):\n      \n        qp.setPen(Qt.red)\n        size = self.size()\n        \n        for i in range(1000):\n            x = random.randint(1, size.width()-1)\n            y = random.randint(1, size.height()-1)\n            qp.drawPoint(x, y)     \n                \n        \nif __name__ == \'__main__\':\n    \n    app = QApplication(sys.argv)\n    ex = Example()\n    sys.exit(app.exec()) \n Colors: \n from PyQt5.QtWidgets import QWidget, QApplication\nfrom PyQt5.QtGui import QPainter, QColor, QBrush\nimport sys\n\nclass Example(QWidget):\n    \n    def __init__(self):\n        super().__init__()\n        \n        self.initUI()\n        \n        \n    def initUI(self):      \n\n        self.setGeometry(300, 300, 350, 100)\n        self.setWindowTitle(\'Colours\')\n        self.show()\n\n\n    def paintEvent(self, e):\n\n        qp = QPainter()\n        qp.begin(self)\n        self.drawRectangles(qp)\n        qp.end()\n\n        \n    def drawRectangles(self, qp):\n      \n        col = QColor(0, 0, 0)\n        col.setNamedColor(\'#d4d4d4\')\n        qp.setPen(col)\n\n        qp.setBrush(QColor(200, 0, 0))\n        qp.drawRect(10, 15, 90, 60)\n\n        qp.setBrush(QColor(255, 80, 0, 160))\n        qp.drawRect(130, 15, 90, 60)\n\n        qp.setBrush(QColor(25, 0, 90, 200))\n        qp.drawRect(250, 15, 90, 60)\n              \n        \nif __name__ == \'__main__\':\n    \n    app = QApplication(sys.argv)\n    ex = Example()\n    sys.exit(app.exec()) \n QPen: \n from PyQt5.QtWidgets import QWidget, QApplication\nfrom PyQt5.QtGui import QPainter, QPen\nfrom PyQt5.QtCore import Qt\nimport sys\n\nclass Example(QWidget):\n    \n    def __init__(self):\n        super().__init__()\n        \n        self.initUI()\n        \n        \n    def initUI(self):      \n\n        self.setGeometry(300, 300, 280, 270)\n        self.setWindowTitle(\'Pen styles\')\n        self.show()\n        \n\n    def paintEvent(self, e):\n\n        qp = QPainter()\n        qp.begin(self)\n        self.drawLines(qp)\n        qp.end()\n        \n        \n    def drawLines(self, qp):\n      \n        pen = QPen(Qt.black, 2, Qt.SolidLine)\n\n        qp.setPen(pen)\n        qp.drawLine(20, 40, 250, 40)\n\n        pen.setStyle(Qt.DashLine)\n        qp.setPen(pen)\n        qp.drawLine(20, 80, 250, 80)\n\n        pen.setStyle(Qt.DashDotLine)\n        qp.setPen(pen)\n        qp.drawLine(20, 120, 250, 120)\n\n        pen.setStyle(Qt.DotLine)\n        qp.setPen(pen)\n        qp.drawLine(20, 160, 250, 160)\n\n        pen.setStyle(Qt.DashDotDotLine)\n        qp.setPen(pen)\n        qp.drawLine(20, 200, 250, 200)\n\n        pen.setStyle(Qt.CustomDashLine)\n        pen.setDashPattern([1, 4, 5, 4])\n        qp.setPen(pen)\n        qp.drawLine(20, 240, 250, 240)\n              \n        \nif __name__ == \'__main__\':\n    \n    app = QApplication(sys.argv)\n    ex = Example()\n    sys.exit(app.exec()) \n Brush: \n from PyQt5.QtWidgets import QWidget, QApplication\nfrom PyQt5.QtGui import QPainter, QBrush\nfrom PyQt5.QtCore import Qt\nimport sys\n\nclass Example(QWidget):\n    \n    def __init__(self):\n        super().__init__()\n        \n        self.initUI()\n        \n        \n    def initUI(self):      \n\n        self.setGeometry(300, 300, 355, 280)\n        self.setWindowTitle(\'Brushes\')\n        self.show()\n        \n\n    def paintEvent(self, e):\n\n        qp = QPainter()\n        qp.begin(self)\n        self.drawBrushes(qp)\n        qp.end()\n        \n        \n    def drawBrushes(self, qp):\n      \n        brush = QBrush(Qt.SolidPattern)\n        qp.setBrush(brush)\n        qp.drawRect(10, 15, 90, 60)\n\n        brush.setStyle(Qt.Dense1Pattern)\n        qp.setBrush(brush)\n        qp.drawRect(130, 15, 90, 60)\n\n        brush.setStyle(Qt.Dense2Pattern)\n        qp.setBrush(brush)\n        qp.drawRect(250, 15, 90, 60)\n\n        brush.setStyle(Qt.DiagCrossPattern)\n        qp.setBrush(brush)\n        qp.drawRect(10, 105, 90, 60)\n\n        brush.setStyle(Qt.Dense5Pattern)\n        qp.setBrush(brush)\n        qp.drawRect(130, 105, 90, 60)\n\n        brush.setStyle(Qt.Dense6Pattern)\n        qp.setBrush(brush)\n        qp.drawRect(250, 105, 90, 60)\n\n        brush.setStyle(Qt.HorPattern)\n        qp.setBrush(brush)\n        qp.drawRect(10, 195, 90, 60)\n\n        brush.setStyle(Qt.VerPattern)\n        qp.setBrush(brush)\n        qp.drawRect(130, 195, 90, 60)\n\n        brush.setStyle(Qt.BDiagPattern)\n        qp.setBrush(brush)\n        qp.drawRect(250, 195, 90, 60)\n              \n        \nif __name__ == \'__main__\':\n    \n    app = QApplication(sys.argv)\n    ex = Example()\n    sys.exit(app.exec()) \n Bezier curve: \n from PyQt5.QtWidgets import QWidget, QApplication\nfrom PyQt5.QtGui import QPainter, QPainterPath\nfrom PyQt5.QtCore import Qt\nimport sys\n\nclass Example(QWidget):\n    \n    def __init__(self):\n        super().__init__()\n        \n        self.initUI()\n        \n        \n    def initUI(self):      \n\n        self.setGeometry(300, 300, 380, 250)\n        self.setWindowTitle(\'Bézier curve\')\n        self.show()\n        \n\n    def paintEvent(self, e):\n\n        qp = QPainter()\n        qp.begin(self)\n        qp.setRenderHint(QPainter.Antialiasing)\n        self.drawBezierCurve(qp)\n        qp.end()\n        \n        \n    def drawBezierCurve(self, qp):\n      \n        path = QPainterPath()\n        path.moveTo(30, 30)\n        path.cubicTo(30, 30, 200, 350, 350, 30)\n        \n        qp.drawPath(path)\n              \n        \nif __name__ == \'__main__\':\n    \n    app = QApplication(sys.argv)\n    ex = Example()\n    sys.exit(app.exec()) \n QPainter: \n import sys\nfrom PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QLabel\nfrom PyQt5.QtGui import QPainter, QColor, QPen\nfrom PyQt5.QtGui import QIcon\nfrom PyQt5.QtCore import Qt\nimport random\n \nclass App(QMainWindow):\n \n    def __init__(self):\n        super().__init__()\n        self.title = \'PyQt paint example\'\n        self.left = 10\n        self.top = 10\n        self.width = 440\n        self.height = 280\n        self.initUI()\n \n    def initUI(self):\n        self.setWindowTitle(self.title)\n        self.setGeometry(self.left, self.top, self.width, self.height)\n \n        # Set window background color\n        self.setAutoFillBackground(True)\n        p = self.palette()\n        p.setColor(self.backgroundRole(), Qt.white)\n        self.setPalette(p)\n \n        # Add paint widget and paint\n        self.m = PaintWidget(self)\n        self.m.move(0,0)\n        self.m.resize(self.width,self.height)\n \n        self.show()\n \n \nclass PaintWidget(QWidget):\n   def paintEvent(self, event):\n      qp = QPainter(self)\n \n      qp.setPen(Qt.black)\n      size = self.size()\n \n      for i in range(1024):\n          x = random.randint(1, size.width()-1)\n          y = random.randint(1, size.height()-1)\n          qp.drawPoint(x, y)\n \n \nif __name__ == \'__main__\':\n    app = QApplication(sys.argv)\n    ex = App()\n    sys.exit(app.exec()) \n Screen Shot: \n """Screenshot and that kind of stuff."""\nimport io\nfrom PyQt5.QtCore import QUrl, QIODevice, QBuffer, QByteArray\nfrom PyQt5.QtWidgets import QApplication\nfrom PyQt5.QtGui import QImage, QPainter\nfrom PyQt5.QtWebEngineWidgets import QWebEngineView\n\nclass Screenshot(QWebEngineView):\n    def __init__(self):\n        self.app = QApplication([])\n        QWebEngineView.__init__(self)\n        self._loaded = False\n        self.loadFinished.connect(self._load_finished)\n        print(\'--finish init\')\n\n    def capture(self, url):\n        print(\'--load\')\n        self.load(QUrl(url))\n        self.wait_load()\n        self.show()\n        size = self.page().contentsSize()\n        self.page().view().resize(*[int(s) for s in [size.width(), size.height()]])\n        print(\'--take image\')\n        image = QImage(800, 800, QImage.Format_ARGB32)\n        painter = QPainter(image)\n        print(\'--render\')\n        self.page().view().render(painter)\n        painter.end()\n        print(\'Saving QImage\')\n        img_bytes = QByteArray()\n        bio = QBuffer(img_bytes)\n        bio.open(QIODevice.WriteOnly)\n        image.save(bio, \'PNG\')\n        return img_bytes\n\n    def wait_load(self):\n        while not self._loaded:\n            self.app.processEvents()\n        self._loaded = False\n\n    def _load_finished(self, result):\n        self._loaded = True \n Reference: \n https://github.com/pyqt/examples   \n https://github.com/mfitzp/15-minute-apps   \n', 'tags': '', 'url': 'QPainter.html'}, {'title': '靜態繪圖', 'text': 'Canvas based 繪圖 \n 參考:  http://doc.qt.io/qt-5/graphicsview.html   \n QtWidgets.QGraphicsScene (場景) \n QtWidgets.QGraphicsView (顯示區) \n QtWidgets.QGraphicsItem (場景中的元件) -  客製化 需要建立 boundingRect() 與 paint() \n Qt 內建採  Binary Space Partitioning Tree   方式管理場景中的元件, 可以即時顯示非常多的場景元件. \n 同一場景可以透過多個不同的 View 加以顯示, 而座標系統則分為: 以 Item 中心為原點的 Item 座標系統、Scene 座標系統, 以及 View 座標系統等三種.  View 座標系統可以透過 mapToScene() 方法轉為 Scene 座標系統. \n 繪圖片段: \n super(Dialog, self).__init__(parent)\nself.setupUi(self)\nscene = QtWidgets.QGraphicsScene()\nself.graphicsView.setScene(scene)\npen = QtGui.QPen(QtCore.Qt.blue)\n\nside = 20\n\nfor i in range(16):\n    for j in range(16):\n        r = QtCore.QRectF(QtCore.QPointF(i*side, j*side), QtCore.QSizeF(side, side))\n        scene.addRect(r, pen) \n 動態繪圖 \n http://doc.qt.io/qt-5/animation-overview.html   \n ball.png \n \n #!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\n\'\'\'\nZetCode Advanced PyQt5 tutorial\n\nThis programs animates a ball object \nalong a curve.\n\nAuthor: Jan Bodnar\nWebsite: zetcode.com\nLast edited: August 2017\n\'\'\'\n\nfrom PyQt5.QtWidgets import QApplication, QWidget, QLabel\nfrom PyQt5.QtGui import QPainter, QPixmap, QPainterPath\nfrom PyQt5.QtCore import QObject, QPointF, QPropertyAnimation, pyqtProperty\nimport sys\n\n                              \nclass Ball(QLabel):\n    \n    def __init__(self, parent):\n        super().__init__(parent)\n        \n        pix = QPixmap("ball.png")\n        self.h = pix.height()\n        self.w = pix.width()\n        \n        self.setPixmap(pix)\n        \n    def _set_pos(self, pos):\n        \n        self.move(pos.x() - self.w/2, pos.y() - self.h/2)\n\n    pos = pyqtProperty(QPointF, fset=_set_pos)   \n       \n    \nclass Example(QWidget):\n    \n    def __init__(self):\n        super().__init__()\n\n        self.initView()\n        self.initAnimation()\n        \n        \n    def initView(self):    \n        \n        self.path = QPainterPath()\n        self.path.moveTo(30, 30)\n        self.path.cubicTo(30, 30, 200, 350, 350, 30)        \n        \n        self.ball = Ball(self)\n\n        self.ball.pos = QPointF(30, 30)\n        \n        self.setWindowTitle("Animation along curve")\n        self.setGeometry(300, 300, 400, 300)\n        self.show()\n        \n        \n    def paintEvent(self, e):    \n        \n        qp = QPainter()\n        qp.begin(self)\n        qp.setRenderHint(QPainter.Antialiasing)   \n        qp.drawPath(self.path)\n        qp.end()             \n\n        \n    def initAnimation(self):\n        \n        self.anim = QPropertyAnimation(self.ball, b\'pos\')\n        self.anim.setDuration(7000)\n        \n        self.anim.setStartValue(QPointF(30, 30))\n        \n        vals = [p/100 for p in range(0, 101)]\n\n        for i in vals:\n            self.anim.setKeyValueAt(i, self.path.pointAtPercent(i))  \n                \n        self.anim.setEndValue(QPointF(350, 30))        \n        self.anim.start()\n        \n                  \nif __name__ == \'__main__\':\n    \n    app = QApplication(sys.argv)\n    ex = Example()\n    sys.exit(app.exec()) \n \n', 'tags': '', 'url': '靜態繪圖.html'}, {'title': 'Moveblocks', 'text': 'from PyQt5.QtCore import (QAbstractTransition, QEasingCurve, QEvent,\n        QParallelAnimationGroup, QPropertyAnimation, qrand, QRect,\n        QSequentialAnimationGroup, qsrand, QState, QStateMachine, Qt, QTime,\n        QTimer)\nfrom PyQt5.QtWidgets import (QApplication, QGraphicsScene, QGraphicsView,\n        QGraphicsWidget)\n\n\nclass StateSwitchEvent(QEvent):\n    StateSwitchType = QEvent.User + 256\n\n    def __init__(self, rand=0):\n        super().__init__(StateSwitchEvent.StateSwitchType)\n\n        self.m_rand = rand\n\n    def rand(self):\n        return self.m_rand\n\n\nclass QGraphicsRectWidget(QGraphicsWidget):\n    def paint(self, painter, option, widget):\n        painter.fillRect(self.rect(), Qt.blue)\n\n\nclass StateSwitchTransition(QAbstractTransition):\n    def __init__(self, rand):\n        super().__init__()\n\n        self.m_rand = rand\n\n    def eventTest(self, event):\n        return (event.type() == StateSwitchEvent.StateSwitchType and\n                event.rand() == self.m_rand)\n\n    def onTransition(self, event):\n        pass\n\n\nclass StateSwitcher(QState):\n    def __init__(self, machine):\n        super().__init__(machine)\n\n        self.m_stateCount = 0\n        self.m_lastIndex = 0\n\n    def onEntry(self, event):\n        n = qrand() % self.m_stateCount + 1\n        while n == self.m_lastIndex:\n            n = qrand() % self.m_stateCount + 1\n\n        self.m_lastIndex = n\n        self.machine().postEvent(StateSwitchEvent(n))\n\n    def onExit(self, event):\n        pass\n\n    def addState(self, state, animation):\n        self.m_stateCount += 1\n        trans = StateSwitchTransition(self.m_stateCount)\n        trans.setTargetState(state)\n        self.addTransition(trans)\n        trans.addAnimation(animation)\n\n\ndef createGeometryState(w1, rect1, w2, rect2, w3, rect3, w4, rect4, parent):\n    result = QState(parent)\n\n    result.assignProperty(w1, \'geometry\', rect1)\n    result.assignProperty(w1, \'geometry\', rect1)\n    result.assignProperty(w2, \'geometry\', rect2)\n    result.assignProperty(w3, \'geometry\', rect3)\n    result.assignProperty(w4, \'geometry\', rect4)\n\n    return result\n\n\nif __name__ == \'__main__\':\n\n    import sys\n\n    app = QApplication(sys.argv)\n\n    button1 = QGraphicsRectWidget()\n    button2 = QGraphicsRectWidget()\n    button3 = QGraphicsRectWidget()\n    button4 = QGraphicsRectWidget()\n    button2.setZValue(1)\n    button3.setZValue(2)\n    button4.setZValue(3)\n\n    scene = QGraphicsScene(0, 0, 300, 300)\n    scene.setBackgroundBrush(Qt.black)\n    scene.addItem(button1)\n    scene.addItem(button2)\n    scene.addItem(button3)\n    scene.addItem(button4)\n\n    window = QGraphicsView(scene)\n    window.setFrameStyle(0)\n    window.setAlignment(Qt.AlignLeft | Qt.AlignTop)\n    window.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n    window.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\n    machine = QStateMachine()\n\n    group = QState()\n    timer = QTimer()\n    timer.setInterval(1250)\n    timer.setSingleShot(True)\n    group.entered.connect(timer.start)\n\n    state1 = createGeometryState(button1, QRect(100, 0, 50, 50), button2,\n            QRect(150, 0, 50, 50), button3, QRect(200, 0, 50, 50), button4,\n            QRect(250, 0, 50, 50), group)\n\n    state2 = createGeometryState(button1, QRect(250, 100, 50, 50), button2,\n            QRect(250, 150, 50, 50), button3, QRect(250, 200, 50, 50), button4,\n            QRect(250, 250, 50, 50), group)\n\n    state3 = createGeometryState(button1, QRect(150, 250, 50, 50), button2,\n            QRect(100, 250, 50, 50), button3, QRect(50, 250, 50, 50), button4,\n            QRect(0, 250, 50, 50), group)\n\n    state4 = createGeometryState(button1, QRect(0, 150, 50, 50), button2,\n            QRect(0, 100, 50, 50), button3, QRect(0, 50, 50, 50), button4,\n            QRect(0, 0, 50, 50), group)\n\n    state5 = createGeometryState(button1, QRect(100, 100, 50, 50), button2,\n            QRect(150, 100, 50, 50), button3, QRect(100, 150, 50, 50), button4,\n            QRect(150, 150, 50, 50), group)\n\n    state6 = createGeometryState(button1, QRect(50, 50, 50, 50), button2,\n            QRect(200, 50, 50, 50), button3, QRect(50, 200, 50, 50), button4,\n            QRect(200, 200, 50, 50), group)\n\n    state7 = createGeometryState(button1, QRect(0, 0, 50, 50), button2,\n            QRect(250, 0, 50, 50), button3, QRect(0, 250, 50, 50), button4,\n            QRect(250, 250, 50, 50), group)\n\n    group.setInitialState(state1)\n\n    animationGroup = QParallelAnimationGroup()\n    anim = QPropertyAnimation(button4, b\'geometry\')\n    anim.setDuration(1000)\n    anim.setEasingCurve(QEasingCurve.OutElastic)\n    animationGroup.addAnimation(anim)\n\n    subGroup = QSequentialAnimationGroup(animationGroup)\n    subGroup.addPause(100)\n    anim = QPropertyAnimation(button3, b\'geometry\')\n    anim.setDuration(1000)\n    anim.setEasingCurve(QEasingCurve.OutElastic)\n    subGroup.addAnimation(anim)\n\n    subGroup = QSequentialAnimationGroup(animationGroup)\n    subGroup.addPause(150)\n    anim = QPropertyAnimation(button2, b\'geometry\')\n    anim.setDuration(1000)\n    anim.setEasingCurve(QEasingCurve.OutElastic)\n    subGroup.addAnimation(anim)\n\n    subGroup = QSequentialAnimationGroup(animationGroup)\n    subGroup.addPause(200)\n    anim = QPropertyAnimation(button1, b\'geometry\')\n    anim.setDuration(1000)\n    anim.setEasingCurve(QEasingCurve.OutElastic)\n    subGroup.addAnimation(anim)\n\n    stateSwitcher = StateSwitcher(machine)\n    group.addTransition(timer.timeout, stateSwitcher)\n    stateSwitcher.addState(state1, animationGroup)\n    stateSwitcher.addState(state2, animationGroup)\n    stateSwitcher.addState(state3, animationGroup)\n    stateSwitcher.addState(state4, animationGroup)\n    stateSwitcher.addState(state5, animationGroup)\n    stateSwitcher.addState(state6, animationGroup)\n    stateSwitcher.addState(state7, animationGroup)\n\n    machine.addState(group)\n    machine.setInitialState(group)\n    machine.start()\n\n    window.resize(300, 300)\n    window.show()\n\n    qsrand(QTime(0, 0, 0).secsTo(QTime.currentTime()))\n\n    sys.exit(app.exec()) \n Coloe animation \n from PyQt5.QtWidgets import (QWidget, QApplication, QPushButton, \n        QLabel, QHBoxLayout, QSizePolicy)\nfrom PyQt5.QtGui import QColor\nfrom PyQt5.QtCore import QPropertyAnimation, pyqtProperty\nimport sys\n\n\nclass MyLabel(QLabel):\n    \n    def __init__(self, text):\n        super().__init__(text)\n\n    def _set_color(self, col):\n        \n        palette = self.palette()\n        palette.setColor(self.foregroundRole(), col)\n        self.setPalette(palette)\n\n    color = pyqtProperty(QColor, fset=_set_color)\n\n\nclass Example(QWidget):\n\n    def __init__(self):\n        super().__init__()\n\n\n        self.initUI()\n        \n        \n    def initUI(self):     \n\n        hbox = QHBoxLayout(self)\n        \n        self.button = QPushButton("Start", self)\n        self.button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n        hbox.addWidget(self.button)\n        \n        hbox.addSpacing(40)\n\n        self.label = MyLabel("Summer")\n        font = self.label.font()\n        font.setPointSize(35)\n        self.label.setFont(font)\n        hbox.addWidget(self.label)\n\n        self.anim = QPropertyAnimation(self.label, b"color")\n        self.anim.setDuration(2500)\n        self.anim.setLoopCount(2)\n        self.anim.setStartValue(QColor(0, 0, 0))\n        self.anim.setEndValue(QColor(255, 255, 255))\n\n        self.button.clicked.connect(self.anim.start)\n        \n        self.setGeometry(300, 300, 380, 250)\n        self.setWindowTitle(\'Color anim\')\n        self.show()    \n        \nif __name__ == "__main__":\n    \n    app = QApplication([])\n    ex = Example()\n    ex.show()\n    app.exec() \n \n', 'tags': '', 'url': 'Moveblocks.html'}, {'title': 'PyQt5 範例', 'text': '參考:  https://www.e-education.psu.edu/geog489/node/2292   \n 利用 PyQt5 建立程式, 都需要透過 QApplication 類別建立應用程式物件, 並且以 exec() 進入主事件迴圈, 完成所需的初始化與後台事物管理.  \n 此一透過 QApplication 建立的 PyQt5 應用程式物件, 對應至一變數名稱 app 後,  接著設置所需的 GUI 元件, 並在程式最後, 調用此應用程式物件的 exec() 方法執行, 以及處理用戶輸入. \n QApplication  與 QWidget 類別隸屬於 PyQt5.QtWidgets 模組. \n app.exec() 執行後的傳回值 0, 用於從 Python 標準程式庫調用 sys.exit() 函式正常退出 Python 程式. \n QApplication::exec() 說明文件 \n sys.exit() 說明文件 \n Label, push button, line edit, layout, signal and slot: \n https://docs.python.org/3/tutorial/classes.html   \n PyQt5 程式流程: \n \n 建立 QApplication 物件 \n  建立主應用程式視窗 \n 設定主視窗參數, 建立或新增子部件 \n 顯示主視窗 \n 啟動 QApplication 物件 \n \n PyQt5 主要模組: \n \n QtCore – 核心非 GUI 工具 \n QtGui – 視窗系統整合, 事件處理, 2D 繪圖, 影像處理與字型 \n QtWidgets – 基本 UI 元件, 包含標籤, 按鈕, 文字輸入, 數列, 表格, 表單與工具箱 \n \n from PyQt5.QtCore import *\nfrom PyQt5.QtWidgets import *\n\n# 繼承 QWidget 部件, 建立 Form 類別\nclass Form(QWidget):\n    # 類別建構子, 建立案例時會自動執行\n    # 無 parent 的 widget 為 window\n    def __init__(self, parent=None):\n        # 執行父物件的建構子\n        super().__init__()\n\n        # 建立 Label 物件\n        nameLabel = QLabel("Name:")\n        # 建立 Line Edit 物件\n        # instance variable\n        self.nameLine = QLineEdit()\n        self.submitButton = QPushButton("&Submit")\n\n        buttonLayout1 = QVBoxLayout()\n        buttonLayout1.addWidget(nameLabel)\n        buttonLayout1.addWidget(self.nameLine)\n        buttonLayout1.addWidget(self.submitButton)\n\n        self.submitButton.clicked.connect(self.submitContact)\n\n        mainLayout = QGridLayout()\n        # mainLayout.addWidget(nameLabel, 0, 0)\n        mainLayout.addLayout(buttonLayout1, 0, 1)\n\n        self.setLayout(mainLayout)\n        self.setWindowTitle("Hello Qt")\n\n    def submitContact(self):\n        name = self.nameLine.text()\n\n        if name == "":\n            QMessageBox.information(self, "Empty Field",\n                                    "Please enter a name and address.")\n            return\n        else:\n            QMessageBox.information(self, "Success!",\n                                    "Hello %s!" % name)\n\nif __name__ == \'__main__\':\n    import sys\n\n    app = QApplication(sys.argv)\n\n    screen = Form()\n    screen.show()\n\n    sys.exit(app.exec()) \n Simple address book : \n from PyQt5.QtCore import Qt\nfrom PyQt5.QtWidgets import (QGridLayout, QHBoxLayout, QLabel, QLineEdit,\n        QMessageBox, QPushButton, QTextEdit, QVBoxLayout, QWidget)\n\nclass SortedDict(dict):\n    class Iterator(object):\n        def __init__(self, sorted_dict):\n            self._dict = sorted_dict\n            self._keys = sorted(self._dict.keys())\n            self._nr_items = len(self._keys)\n            self._idx = 0\n\n        def __iter__(self):\n            return self\n\n        def next(self):\n            if self._idx >= self._nr_items:\n                raise StopIteration\n\n            key = self._keys[self._idx]\n            value = self._dict[key]\n            self._idx += 1\n\n            return key, value\n\n        __next__ = next\n\n    def __iter__(self):\n        return SortedDict.Iterator(self)\n\n    iterkeys = __iter__\n\nclass AddressBook(QWidget):\n    def __init__(self, parent=None):\n        super(AddressBook, self).__init__(parent)\n\n        self.contacts = SortedDict()\n        self.oldName = \'\'\n        self.oldAddress = \'\'\n\n        nameLabel = QLabel("Name:")\n        self.nameLine = QLineEdit()\n        self.nameLine.setReadOnly(True)\n\n        addressLabel = QLabel("Address:")\n        self.addressText = QTextEdit()\n        self.addressText.setReadOnly(True)\n\n        self.addButton = QPushButton("&Add")\n        self.addButton.show()\n        self.submitButton = QPushButton("&Submit")\n        self.submitButton.hide()\n        self.cancelButton = QPushButton("&Cancel")\n        self.cancelButton.hide()\n        self.nextButton = QPushButton("&Next")\n        self.nextButton.setEnabled(False)\n        self.previousButton = QPushButton("&Previous")\n        self.previousButton.setEnabled(False)\n\n        self.addButton.clicked.connect(self.addContact)\n        self.submitButton.clicked.connect(self.submitContact)\n        self.cancelButton.clicked.connect(self.cancel)\n        self.nextButton.clicked.connect(self.next)\n        self.previousButton.clicked.connect(self.previous)\n\n        buttonLayout1 = QVBoxLayout()\n        buttonLayout1.addWidget(self.addButton, Qt.AlignTop)\n        buttonLayout1.addWidget(self.submitButton)\n        buttonLayout1.addWidget(self.cancelButton)\n        buttonLayout1.addStretch()\n\n        buttonLayout2 = QHBoxLayout()\n        buttonLayout2.addWidget(self.previousButton)\n        buttonLayout2.addWidget(self.nextButton)\n\n        mainLayout = QGridLayout()\n        mainLayout.addWidget(nameLabel, 0, 0)\n        mainLayout.addWidget(self.nameLine, 0, 1)\n        mainLayout.addWidget(addressLabel, 1, 0, Qt.AlignTop)\n        mainLayout.addWidget(self.addressText, 1, 1)\n        mainLayout.addLayout(buttonLayout1, 1, 2)\n        mainLayout.addLayout(buttonLayout2, 3, 1)\n\n        self.setLayout(mainLayout)\n        self.setWindowTitle("Simple Address Book")\n\n    def addContact(self):\n        self.oldName = self.nameLine.text()\n        self.oldAddress = self.addressText.toPlainText()\n\n        self.nameLine.clear()\n        self.addressText.clear()\n\n        self.nameLine.setReadOnly(False)\n        self.nameLine.setFocus(Qt.OtherFocusReason)\n        self.addressText.setReadOnly(False)\n\n        self.addButton.setEnabled(False)\n        self.nextButton.setEnabled(False)\n        self.previousButton.setEnabled(False)\n        self.submitButton.show()\n        self.cancelButton.show()\n\n    def submitContact(self):\n        name = self.nameLine.text()\n        address = self.addressText.toPlainText()\n\n        if name == "" or address == "":\n            QMessageBox.information(self, "Empty Field",\n                    "Please enter a name and address.")\n            return\n\n        if name not in self.contacts:\n            self.contacts[name] = address\n            QMessageBox.information(self, "Add Successful",\n                    "\\"%s\\" has been added to your address book." % name)\n        else:\n            QMessageBox.information(self, "Add Unsuccessful",\n                    "Sorry, \\"%s\\" is already in your address book." % name)\n            return\n\n        if not self.contacts:\n            self.nameLine.clear()\n            self.addressText.clear()\n\n        self.nameLine.setReadOnly(True)\n        self.addressText.setReadOnly(True)\n        self.addButton.setEnabled(True)\n\n        number = len(self.contacts)\n        self.nextButton.setEnabled(number > 1)\n        self.previousButton.setEnabled(number > 1)\n\n        self.submitButton.hide()\n        self.cancelButton.hide()\n\n    def cancel(self):\n        self.nameLine.setText(self.oldName)\n        self.addressText.setText(self.oldAddress)\n\n        if not self.contacts:\n            self.nameLine.clear()\n            self.addressText.clear()\n\n        self.nameLine.setReadOnly(True)\n        self.addressText.setReadOnly(True)\n        self.addButton.setEnabled(True)\n\n        number = len(self.contacts)\n        self.nextButton.setEnabled(number > 1)\n        self.previousButton.setEnabled(number > 1)\n\n        self.submitButton.hide()\n        self.cancelButton.hide()\n\n    def next(self):\n        name = self.nameLine.text()\n        it = iter(self.contacts)\n\n        try:\n            while True:\n                this_name, _ = it.next()\n\n                if this_name == name:\n                    next_name, next_address = it.next()\n                    break\n        except StopIteration:\n            next_name, next_address = iter(self.contacts).next()\n\n        self.nameLine.setText(next_name)\n        self.addressText.setText(next_address)\n\n    def previous(self):\n        name = self.nameLine.text()\n\n        prev_name = prev_address = None\n        for this_name, this_address in self.contacts:\n            if this_name == name:\n                break\n\n            prev_name = this_name\n            prev_address = this_address\n        else:\n            self.nameLine.clear()\n            self.addressText.clear()\n            return\n\n        if prev_name is None:\n            for prev_name, prev_address in self.contacts:\n                pass\n\n        self.nameLine.setText(prev_name)\n        self.addressText.setText(prev_address)\n\nif __name__ == \'__main__\':\n    import sys\n\n    from PyQt5.QtWidgets import QApplication\n\n    app = QApplication(sys.argv)\n\n    addressBook = AddressBook()\n    addressBook.show()\n\n    sys.exit(app.exec_()) \n simple Scintilla editor: \n import sys\n\nimport sip\nfrom PyQt5.QtWidgets import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.Qsci import QsciScintilla, QsciLexerPython\n\n\nclass SimplePythonEditor(QsciScintilla):\n    ARROW_MARKER_NUM = 8\n\n    def __init__(self, parent=None):\n        super().__init__()\n\n        # Set the default font\n        font = QFont()\n        font.setFamily(\'Courier\')\n        font.setFixedPitch(True)\n        font.setPointSize(10)\n        self.setFont(font)\n        self.setMarginsFont(font)\n        self.setUtf8(True)\n\n        # Margin 0 is used for line numbers\n        fontmetrics = QFontMetrics(font)\n        self.setMarginsFont(font)\n        self.setMarginWidth(0, fontmetrics.width("00000") + 6)\n        self.setMarginLineNumbers(0, True)\n        self.setMarginsBackgroundColor(QColor("#cccccc"))\n\n        # Clickable margin 1 for showing markers\n        self.setMarginSensitivity(1, True)\n        self.marginClicked.connect(self.on_margin_clicked)\n        self.markerDefine(QsciScintilla.RightArrow,\n            self.ARROW_MARKER_NUM)\n        self.setMarkerBackgroundColor(QColor("#ee1111"),\n            self.ARROW_MARKER_NUM)\n\n        # Brace matching: enable for a brace immediately before or after\n        # the current position\n        #\n        self.setBraceMatching(QsciScintilla.SloppyBraceMatch)\n\n        # Current line visible with special background color\n        self.setCaretLineVisible(True)\n        self.setCaretLineBackgroundColor(QColor("#ffe4e4"))\n\n        # Set Python lexer\n        # Set style for Python comments (style number 1) to a fixed-width\n        # courier.\n        #\n\n        lexer = QsciLexerPython()\n        lexer.setDefaultFont(font)\n        self.setLexer(lexer)\n\n        text = bytearray(str.encode("Arial"))\n        # 32, "Courier New"\n        self.SendScintilla(QsciScintilla.SCI_STYLESETFONT, 1, text)\n\n        # Don\'t want to see the horizontal scrollbar at all\n        # Use raw message to Scintilla here (all messages are documented\n        # here: http://www.scintilla.org/ScintillaDoc.html)\n        self.SendScintilla(QsciScintilla.SCI_SETHSCROLLBAR, 0)\n\n        # not too small\n        self.setMinimumSize(600, 450)\n\n    def on_margin_clicked(self, nmargin, nline, modifiers):\n        # Toggle marker for the line the margin was clicked on\n        if self.markersAtLine(nline) != 0:\n            self.markerDelete(nline, self.ARROW_MARKER_NUM)\n        else:\n            self.markerAdd(nline, self.ARROW_MARKER_NUM)\n\n\nif __name__ == "__main__":\n    app = QApplication(sys.argv)\n    editor = SimplePythonEditor()\n    editor.show()\n    editor.setText(open(sys.argv[0]).read())\n    app.exec() \n csv file example: \n import csv\nimport sys\nfrom PyQt5.QtWidgets import (\n    QApplication,\n    QMainWindow,\n    qApp,\n    QAction,\n    QWidget,\n    QFileDialog,\n    QTableView\n)\nfrom PyQt5.QtGui import (\n    QStandardItemModel,\n    QStandardItem\n)\nfrom PyQt5.QtCore import (\n    Qt,\n    QAbstractTableModel,\n    QVariant\n)\n\nclass MainWindow(QMainWindow):\n\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle("CSV GUI")\n        self.create_menu_bar()\n\n    def create_menu_bar(self):\n        menu_bar = self.menuBar()\n        menu_bar.setNativeMenuBar(False)\n        self.create_file_menu(menu_bar)\n\n    def create_file_menu(self, menu_bar):\n        exit = QAction("Exit", self)\n        exit.setShortcut("Ctrl+Q")\n        exit.setStatusTip("Exit CSV GUI")\n        exit.triggered.connect(qApp.quit)\n\n        open = QAction("&Open", self)\n        open.setShortcut("Ctrl+O")\n        open.setStatusTip("Open a CSV file")\n        open.triggered.connect(self.open_file)\n\n        file_menu = menu_bar.addMenu("&File")\n        file_menu.addAction(open)\n        file_menu.addAction(exit)\n\n    def open_file(self):\n        file_name, filter = \\\n            QFileDialog.getOpenFileName(self, "Open file", ".",\n                                        "All files (*);;CSV Files (*.csv)")\n\n        with open(file_name) as fin:\n            csv_data = [row for row in csv.reader(fin)]\n        table_model = SimpleTableModel(csv_data[0], csv_data[1:])\n        table_view = QTableView()\n        table_view.setModel(table_model)\n        self.setCentralWidget(table_view)\n\nclass SimpleTableModel(QAbstractTableModel):\n\n    def __init__(self, headers, rows):\n        QAbstractTableModel.__init__(self, None)\n        self.headers = headers\n        self.rows = rows\n\n    def rowCount(self, parent):\n        return len(self.rows)\n\n    def columnCount(self, parent):\n        return len(self.headers)\n\n    def data(self, index, role):\n        if (not index.isValid()) or (role != Qt.DisplayRole):\n            return QVariant()\n        else:\n            return QVariant(self.rows[index.row()][index.column()])\n\n    def headerData(self, section, orientation, role):\n        if role != Qt.DisplayRole:\n            return QVariant()\n        elif orientation == Qt.Vertical:\n            return section + 1\n        else:\n            return self.headers[section]\n\n\nif __name__==\'__main__\':\n    app = QApplication(sys.argv)\n    main = MainWindow()\n    main.show()\n    sys.exit(app.exec())\n \n Graphics 範例: \n from math import pi\nimport sys, os.path\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\n\nfrom PyQt5.QtWidgets import QApplication, QWidget\n\n\n# library version number\n__version__ = "3.0.7pyqt"\n\nprint("Imported cs1lib, version " + __version__)\n\n# hint to window manager where to place graphics window\nWINDOW_X = 300\nWINDOW_Y = 300\n\n# Global canvas object\ncanvas = None\n\n# main app is global to allow things like timers to be started before/without graphics loop\napp = QApplication(sys.argv)\n\n# used for noop callbacks\ndef noop(*args, **kwargs):\n    pass\n\n# Generic State class used to create objects to pass between callbacks in cs1 examples\n#   (Monkey-patched to add variables in early examples.)\n\nclass State():\n    def __init__(self):\n        pass\n\nclass CS1Image(QImage):\n    def get_pixel(self, x, y):\n        p = self.pixel(x, y)\n\n        r = qRed(p) / 255.0\n        g = qGreen(p) / 255.0\n        b = qBlue(p) / 255.0\n        a = qAlpha(p) / 255.0\n\n        return (r, g, b, a)\n\n    def set_pixel(self, x, y, r, g, b, a = 1.0):\n        ri  = int(r * 255)\n        gi  = int(g * 255)\n        bi  = int(b * 255)\n        ai  = int(a * 255)\n\n        qrgba = qRgba ( ri, gi, bi, ai )\n        self.setPixel(x, y, qrgba)\n\nclass CS1Canvas(QWidget):\n\n    def __init__(self, draw_fn, data, window_x, window_y, width, height, title, framerate,\n                 mouse_press, mouse_release, mouse_move,\n                 key_press, key_release):\n        super(CS1Canvas, self).__init__()\n\n        # store callback function\n        self.draw_fn = draw_fn\n        self.mouse_press = mouse_press\n        self.mouse_release = mouse_release\n        self.mouse_move = mouse_move\n        self.key_press = key_press\n        self.key_release = key_release\n\n        # data to pass to callback functions\n        self.data = data\n\n        self.window_x = window_x\n        self.window_y = window_y\n\n        self.width = width\n        self.height = height\n        self.title = title\n        self.framerate = framerate\n\n        # basic state setup\n\n        self.fill_enabled = True\n        self.stroke_enabled = True\n\n        self.stroke_width = 1\n\n        self.clear_color = (1, 1, 1, 1)\n        self.pen_color = (0, 0, 0, 1)\n        self.fill_color = (0, 0, 0, 1)\n\n        # Initial font\n\n        self.font_name = "Arial"\n        self.font_size = 14\n        self.font_style = QFont.Normal\n        self.font_italic = False\n\n        # initialize image just so that there is one for first redraw\n        self.image = QImage(self.size(), QImage.Format_ARGB32_Premultiplied)\n        self.init_qt()\n\n        # get the size right this time\n        self.image = QImage(self.size(), QImage.Format_ARGB32_Premultiplied)\n\n        self.ipainter = QPainter(self.image)\n        self.ipainter.setRenderHint(QPainter.Antialiasing, True)\n        self.ipainter.setRenderHint(QPainter.SmoothPixmapTransform, True)\n\n        self.closed = False\n\n        # store the set of currently pressed keys\n        self.keys_down = set()\n\n        self.mouse_down = False\n        self.mx = -1\n        self.my = -1\n\n        #self.clear()\n        self.timer = QTimer()\n        self.timer.timeout.connect(self.draw)\n        self.timer.start(1000 / self.framerate)\n\n\n\n    def init_qt(self):\n\n        # self.setGeometry(self.window_x, self.window_y, self.width, self.height)\n        self.setFixedSize(self.width, self.height)\n        self.setWindowTitle(self.title)\n\n        self.show()\n\n        # enable tracking mouse during mouse move\n        self.setMouseTracking(True)\n\n        #self.enable_smoothing()\n\n        self.raise_()\n\n    def paintEvent(self, event):\n\n        screen_painter = QPainter(self)\n\n        screen_painter.drawImage(0, 0, self.image)\n\n        screen_painter.end()\n\n\n    def closeEvent(self, event):\n        # qt unhappy if a reference to ipainter is still hanging\n        #   around on close\n\n        self.timer.stop()\n\n        self.ipainter = None\n\n\n\n    # used for main rendering loop\n    def draw(self):\n        #print("draw called")\n\n        if self.data:\n            self.draw_fn(self.data)\n        else:\n            self.draw_fn()\n\n        self.update()\n\n\n    def mousePressEvent(self, event):\n        mx = event.x()\n        my = event.y()\n\n        self.mouse_down = True\n        self.mx = mx\n        self.my = my\n\n        if self.data:\n            self.mouse_press(mx, my, self.data)\n        else:\n            self.mouse_press(mx, my)\n\n\n    def mouseReleaseEvent(self, event):\n        mx = event.x()\n        my = event.y()\n\n        self.mouse_down = False\n        self.mx = mx\n        self.my = my\n\n        if self.data:\n            self.mouse_release(mx, my, self.data)\n        else:\n            self.mouse_release(mx, my)\n\n    def mouseMoveEvent(self, event):\n        mx = event.x()\n        my = event.y()\n\n        self.mx = mx\n        self.my = my\n\n        if self.data:\n            self.mouse_move(mx, my, self.data)\n        else:\n            self.mouse_move(mx, my)\n\n    @staticmethod\n    def get_key_str(event):\n        #key = event.key()\n        #print("text: " + event.text())\n        #if key >=65 and key <= 90:\n        #    modifiers = event.modifiers()\n        #    print(str(modifiers))\n        #    if (modifiers & Qt.ShiftModifier) == 0:\n        #        print("no shift " + chr(key))\n        #        key += 32\n        #\n        #if key >= 0 and key <=255:\n        #    return chr(key)\n\n        #return None\n        return event.text()\n\n\n    def keyPressEvent(self, event):\n\n        key_str= self.get_key_str(event)\n\n        self.keys_down.add(key_str)\n        print("key pressed " + key_str)\n        if key_str:\n            if self.data:\n                self.key_press(key_str, self.data)\n            else:\n                self.key_press(key_str)\n\n    def keyReleaseEvent(self, event):\n        key_str = self.get_key_str(event)\n        self.keys_down.discard(key_str)\n\n        if key_str:\n            if self.data:\n                self.key_release(key_str, self.data)\n            else:\n                self.key_release(key_str)\n\n    def is_key_pressed(self, key):\n        return key in self.keys_down\n\n    # Commands that affect state such as color or stroke\n\n    # update functions that update the state of Qt based on\n    #  state variables.  Call after changing relevant state variables.\n\n    def enable_smoothing(self):\n        # left in only for backwards compatibility.  antialising on by default\n        pass\n\n    def update_font(self):\n        f = QFont(self.font_name, self.font_size, self.font_style, self.font_italic)\n        self.ipainter.setFont(f)\n\n    def update_pen(self):\n        # set stroke color and width\n        if self.stroke_enabled:\n            r = int(self.pen_color[0] * 255)\n            g = int(self.pen_color[1] * 255)\n            b = int(self.pen_color[2] * 255)\n            a = int(self.pen_color[3] * 255)\n            pen = QPen(QColor(r, g, b, a))\n            pen.setWidth(self.stroke_width)\n            self.ipainter.setPen(pen)\n        else:\n            self.ipainter.setPen(Qt.NoPen)\n\n    def update_brush(self):\n        # set fill color\n        if self.fill_enabled:\n            r = int(self.fill_color[0] * 255)\n            g = int(self.fill_color[1] * 255)\n            b = int(self.fill_color[2] * 255)\n            a = int(self.fill_color[3] * 255)\n            self.ipainter.setBrush(QBrush(QColor(r, g, b, a)))\n        else:\n            self.ipainter.setBrush(Qt.NoBrush)\n\n    def set_clear_color(self, r, g, b, alpha=1.0):\n        self.clear_color = (r, g, b, alpha)\n\n    def set_stroke_color(self, r, g, b, alpha=1.0):\n        self.pen_color = (r, g, b, alpha)\n        self.update_pen()\n\n    def set_stroke_width(self, width):\n        self.stroke_width = width\n        self.update_pen()\n\n    def set_fill_color(self, r, g, b, alpha=1.0):\n        self.fill_color = (r, g, b, alpha)\n        self.enable_fill()\n\n    def enable_fill(self):\n        self.fill_enabled = True\n        self.update_brush()\n\n    def disable_fill(self):\n        self.fill_enabled = False\n        self.update_brush()\n\n    def enable_stroke(self):\n        self.stroke_enabled = True\n        self.update_pen()\n\n    def disable_stroke(self):\n        self.stroke_enabled = False\n        self.update_pen()\n\n    def set_font(self, font_name):\n        self.font_name = font_name\n        self.update_font()\n\n    def set_font_size(self, size):\n        self.font_size = size\n        self.update_font()\n\n    def set_font_normal(self):\n        self.font_style = QFont.Normal\n        self.font_italic = False\n        self.update_font()\n\n    def set_font_bold(self):\n        self.font_style = QFont.Bold\n        self.update_font()\n\n    def set_font_italic(self):\n        self.font_italic = True\n        self.update_font()\n\n\n    def rotate(self, angle):\n        self.ipainter.rotate(angle)\n\n    def translate(self, x, y):\n        self.ipainter.translate(x, y)\n\n    def scale(self, sx, sy):\n        self.ipainter.scale(sx, sy)\n\n    def save(self):\n        self.ipainter.save()\n\n    def restore(self):\n        self.ipainter.restore()\n\n    # Drawing command wrapper methods\n\n    def clear(self):\n\n        r = int(self.clear_color[0] * 255)\n        g = int(self.clear_color[1] * 255)\n        b = int(self.clear_color[2] * 255)\n        a = int(self.clear_color[3] * 255)\n\n        self.ipainter.setBackground(QBrush(QColor(r, g, b, a)))\n        #print(self.image.rect())\n        self.ipainter.eraseRect(self.image.rect());\n\n    def draw_point(self, x, y):\n        self.ipainter.drawPoint(x, y)\n\n    def draw_line(self, x1, y1, x2, y2):\n        self.ipainter.drawLine(x1, y1, x2, y2)\n\n    def draw_rectangle(self, x, y, w, h):\n        self.ipainter.drawRect(x, y, w, h)\n\n    def draw_polygon(self, vertices):\n        qpoints = []\n\n        for vertex in vertices:\n            qpoints.append(QPoint(vertex[0], vertex[1]))\n\n        poly = QPolygonF(qpoints)\n        self.ipainter.drawPolygon(poly)\n\n    def draw_ellipse(self, x, y, rx, ry):\n        self.ipainter.drawEllipse(QRectF(x - rx, y - ry, rx * 2, ry * 2))\n\n    def draw_text(self, s, x, y):\n\n        self.ipainter.drawText(x, y, s)\n\n\n    def get_text_width(self, str):\n        f = QFont(self.font_name, self.font_size, self.font_style, self.font_italic)\n        fmetric = QFontMetrics(f)\n        #return fmetric.boundingRect(str).width()\n        return fmetric.width(str)\n\n    def get_text_height(self):\n        f = QFont(self.font_name, self.font_size, self.font_style, self.font_italic)\n        fmetric = QFontMetrics(f)\n        #return fmetric.boundingRect(str).height()\n        return fmetric.height()\n\n\n    def draw_image(self, image, x, y):\n        self.ipainter.drawImage(x, y, image)\n\n\n\n\n# cs1lib drawing commands\n\n#  utility\n\ndef is_key_pressed(key):\n    return canvas.is_key_pressed(key)\n\ndef is_mouse_pressed():\n    return canvas.mouse_down\n\ndef mouse_x():\n    return canvas.mx\n\ndef mouse_y():\n    return canvas.my\n\ndef degrees(rad):\n    return 180 * rad / pi\n\n#  state commands\n\ndef enable_smoothing():\n    pass\n\n\ndef disable_smoothing():\n    pass\n\n\ndef enable_fill():\n    canvas.enable_fill()\n\n\ndef disable_fill():\n    canvas.disable_fill()\n\n\ndef set_fill_color(r, g, b, alpha=1.0):\n    canvas.set_fill_color(r, g, b, alpha)\n\n\ndef set_clear_color(r, g, b, alpha=1.0):\n    canvas.set_clear_color(r, g, b, alpha)\n\n\ndef enable_stroke():\n    canvas.enable_stroke()\n\n\ndef disable_stroke():\n    canvas.disable_stroke()\n\n\ndef set_stroke_color(r, g, b, alpha=1.0):\n    canvas.set_stroke_color(r, g, b, alpha)\n\n\ndef set_stroke_width(width):\n    canvas.set_stroke_width(width)\n\n\ndef set_font(font_name):\n    canvas.set_font(font_name)\n\n\ndef set_font_size(font_size):\n    canvas.set_font_size(font_size)\n\n\ndef set_font_normal():\n    canvas.set_font_normal()\n\n\ndef set_font_bold():\n    canvas.set_font_bold()\n\ndef set_font_italic():\n    canvas.set_font_italic()\n\n\n#  drawing commands\n\ndef clear():\n    canvas.clear()\n\ndef draw_point(x, y):\n    canvas.draw_point(x, y)\n\n\ndef draw_line(x1, y1, x2, y2):\n    canvas.draw_line(x1, y1, x2, y2)\n\n\ndef draw_polygon(vertices):\n    canvas.draw_polygon(vertices)\n\n\ndef draw_triangle(x1, y1, x2, y2, x3, y3):\n    draw_polygon([(x1, y1), (x2, y2), (x3, y3)])\n\n\ndef draw_circle(x, y, r):\n    draw_ellipse(x, y, r, r)\n\n\ndef draw_ellipse(x, y, rx, ry):\n    assert rx >= 0\n    assert ry >= 0\n\n    if rx == 0 or ry == 0:\n        return\n\n    canvas.draw_ellipse(x, y, rx, ry)\n\n\ndef draw_rectangle(x, y, w, h):\n    canvas.draw_rectangle(x, y, w, h)\n\n\ndef draw_text(string, x, y):\n    canvas.draw_text(string, x, y)\n\n\n\n## transformations and canvas state functions\n\ndef push_state():\n    canvas.save()\n\ndef pop_state():\n    canvas.restore()\n\ndef rotate(degrees):\n    canvas.rotate(degrees)\n\ndef translate(x, y):\n    canvas.translate(x, y)\n\n# Images\n\ndef draw_image(image, x, y, cx = 0, cy = 0, theta = 0):\n    push_state()\n    translate(x - cx, y - cy)\n\n    if theta != 0:\n\n        translate(cx, cy)\n        rotate(theta)\n        translate(-cx, -cy)\n\n    canvas.draw_image(image, 0, 0)\n\n    pop_state()\n\ndef load_image(filename):\n    img = CS1Image()\n    img.load(filename)\n    return img\n\n\ndef get_text_width(string):\n    return canvas.get_text_width(string)\n\n\ndef get_text_height():\n    return canvas.get_text_height()\n\n# Main graphics loop\n\n# the frames parameters gives the number of frames to display on the\n#  browser version of cs1lib.  Ignored in qt version.\ndef start_graphics(draw_func=noop, frames=1, data=None, framerate=40,\n                title="cs1", width=400, height=400,\n                mouse_press=noop, mouse_release = noop, mouse_move=noop,\n                key_press=noop, key_release=noop):\n\n    global canvas\n\n    canvas = CS1Canvas(draw_fn = draw_func, data = data, window_x=WINDOW_X, window_y=WINDOW_Y,\n                       width=width, height=height, title=title, framerate=framerate,\n                       mouse_press=mouse_press, mouse_release=mouse_release, mouse_move=mouse_move,\n                       key_press=key_press, key_release=key_release)\n\n\n\n    sys.exit(app.exec_())\n\ndef cs1_quit():\n    print("cs1_quit called")\n    app.quit()\n    exit()\n\n\n# for testing purposes\nif __name__ == \'__main__\':\n\n    vx = 1\n    x = 200\n    y = 200\n\n    def on_click(mx, my):\n        print("Mouse click! " + str(mx) + " " + str(my))\n\n    def on_move(mx, my):\n        #print("Mouse move! " + str(mx) + " " + str(my))\n        pass\n\n    def on_release(mx, my):\n        print("Mouse up! " + str(mx) + " " + str(my))\n\n    def on_keydown(key):\n        print("Pressed " + key)\n\n    def on_keyup(key):\n        print("Released " + key)\n\n\n    def draw():\n        global x, vx\n        clear()\n\n        set_clear_color(.8, .4, .4)\n        clear()\n\n        set_fill_color(.2, .5, .9)\n        set_stroke_color(1, 1, 0)\n        draw_rectangle(100, 100, 200, 200)\n\n        set_stroke_color(0, 0, 0)\n        set_fill_color(1, 1, 1)\n        draw_circle(200, 200, 100)\n\n        if star_img:\n            draw_image(star_img, 200, 200, star_img.width()/2, star_img.height()/ 2, x)\n\n\n        draw_circle(x, y, 5)\n\n\n        x += vx\n\n        if x + 5 > 300 or x - 5 < 100:\n            vx *= -1\n\n        set_font("Times")\n        set_font_bold()\n        set_font_italic()\n        set_font_size(20)\n\n        text = "Hello, world!"\n        w = get_text_width(text)\n\n        draw_text("Hello, world!", 200 - w/2, 277)\n\n        h = get_text_height()\n        draw_text(str(mouse_x()), 10, 400)\n        draw_text( str(mouse_y()), 10, 400 + h)\n        draw_text( str(is_mouse_pressed()), 10, 400 + 2 * h)\n\n\n    star_img = None\n    if os.path.exists("star.png"):\n        star_img = load_image("star.png")\n\n    start_graphics(draw, width=500, height=500, mouse_press = on_click, mouse_release = on_release, mouse_move = on_move,\n                   key_press=on_keydown, key_release=on_keyup) \n html 轉 pdf: \n import sys\nfrom PyQt5 import QtCore, QtWidgets, QtWebEngineWidgets\n\napp = QtWidgets.QApplication(sys.argv)\nloader = QtWebEngineWidgets.QWebEngineView()\nloader.setZoomFactor(1)\nloader.page().pdfPrintingFinished.connect(\n    lambda *args: print(\'finished:\', args))\nloader.load(QtCore.QUrl(\'http://mde.tw/cadp2018/content/index.html\'))\n\ndef emit_pdf(finished):\n    loader.show()\n    loader.page().printToPdf("test.pdf")\n\nloader.loadFinished.connect(emit_pdf)\n\napp.exec() \n mouse event and line drawing: \n from PyQt5 import QtWidgets, QtGui, QtCore\n\n\nclass Window(QtWidgets.QWidget):\n    def __init__(self):\n        QtWidgets.QWidget.__init__(self)\n        self.view = View(self)\n        self.button = QtWidgets.QPushButton(\'Clear View\', self)\n        self.button.clicked.connect(self.handleClearView)\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.addWidget(self.view)\n        layout.addWidget(self.button)\n\n    def handleClearView(self):\n        self.view.scene().clear()\n\nclass View(QtWidgets.QGraphicsView):\n    def __init__(self, parent):\n        QtWidgets.QGraphicsView.__init__(self, parent)\n        self.setScene(QtWidgets.QGraphicsScene(self))\n        self.setSceneRect(QtCore.QRectF(self.viewport().rect()))\n\n    def mousePressEvent(self, event):\n        self._start = event.pos()\n\n    def mouseReleaseEvent(self, event):\n        start = QtCore.QPointF(self.mapToScene(self._start))\n        end = QtCore.QPointF(self.mapToScene(event.pos()))\n        self.scene().addItem(\n            QtWidgets.QGraphicsLineItem(QtCore.QLineF(start, end)))\n        for point in (start, end):\n            text = self.scene().addSimpleText(\n                \'(%d, %d)\' % (point.x(), point.y()))\n            text.setBrush(QtCore.Qt.red)\n            text.setPos(point)\n\nif __name__ == \'__main__\':\n\n    import sys\n    app = QtWidgets.QApplication(sys.argv)\n    window = Window()\n    window.resize(640, 480)\n    window.show()\n    sys.exit(app.exec()) \n 在場景中加入元件 ( 來源 ) \n #!/usr/bin/env python\n\nfrom PyQt5.QtCore import (QLineF, QPointF, QRectF, Qt)\nfrom PyQt5.QtGui import (QBrush, QColor, QPainter)\nfrom PyQt5.QtWidgets import (QApplication, QGraphicsView, QGraphicsScene, QGraphicsItem,\n                             QGridLayout, QVBoxLayout, QHBoxLayout,\n                             QLabel, QLineEdit, QPushButton)\n\n# 繼承 QGraphicsItem 類別, 建立 TicTacToe 類別\nclass TicTacToe(QGraphicsItem):\n    # 定義建構子\n    def __init__(self):\n        # 先執行父物件的建構子方法\n        super().__init__()\n        # 定義 board instance 屬性\n        self.board = [[-1, -1, -1],[-1, -1, -1], [-1, -1, -1]]\n        # 定義 O 與 X 與 turn 物件案例屬性\n        self.O = 0\n        self.X = 1\n        self.turn = self.O\n\n    # 定義重置方法\n    def reset(self):\n        # 以 y=0, 1, 2 重複執行迴圈\n        for y in range(3):\n            # 以 x=0, 1, 2 重複執行迴圈\n            for x in range(3):\n                # board 案例數列全設為 -1\n                self.board[y][x] = -1\n        # turn 設為 O\n        self.turn = self.O\n        # 執行 update 案例方法\n        self.update()\n\n    # 定義 select\n    def select(self, x, y):\n        # 不在範圍中的 x 與 y 直接 return\n        if x < 0 or y < 0 or x >= 3 or y >= 3:\n            return\n        # 當板中特定位置為 -1, 表示該位置尚未 paint, 則一開始 turn 為 O, 也就是 0\n        # 接著 turn 成為 1-0  轉為 1\n        if self.board[y][x] == -1:\n            self.board[y][x] = self.turn\n            self.turn = 1 - self.turn\n\n    def paint(self, painter, option, widget):\n        painter.setPen(Qt.black)\n        painter.drawLine(0,100,300,100)\n        painter.drawLine(0,200,300,200)\n        painter.drawLine(100,0,100,300)\n        painter.drawLine(200,0,200,300)\n\n        for y in range(3):\n            for x in range(3):\n                if self.board[y][x] == self.O:\n                    painter.setPen(Qt.red)\n                    painter.drawEllipse(QPointF(50+x*100, 50+y*100), 30, 30)\n                elif self.board[y][x] == self.X:\n                    painter.setPen(Qt.blue)\n                    painter.drawLine(20+x*100, 20+y*100, 80+x*100, 80+y*100)\n                    painter.drawLine(20+x*100, 80+y*100, 80+x*100, 20+y*100)\n\n    def boundingRect(self):\n        return QRectF(0,0,300,300)\n\n    # 滑鼠點按事件\n    def mousePressEvent(self, event):\n        pos = event.pos()\n        self.select(int(pos.x()/100), int(pos.y()/100))\n        self.update()\n        super(TicTacToe, self).mousePressEvent(event)\n\n# 以 QGraphicsView 作為視窗\nclass MainWindow(QGraphicsView):\n    def __init__(self):\n        super().__init__()\n        # 場景\n        scene = QGraphicsScene(self)\n        self.tic_tac_toe = TicTacToe()\n        # 在場景中加入 TicTacToe() 的案例物件\n        scene.addItem(self.tic_tac_toe)\n        scene.setSceneRect(0, 0, 300, 300)\n        # 在視窗中 setScene\n        self.setScene(scene)\n        # 設定 CacheMode\n        self.setCacheMode(QGraphicsView.CacheBackground)\n        self.setWindowTitle("Tic Tac Toe")\n\n    def keyPressEvent(self, event):\n        key = event.key()\n        # 若按下 R 鍵, 則執行 reset 方法\n        if key == Qt.Key_R:\n            self.tic_tac_toe.reset()\n        # 執行 MainWindow 中的 keyPressEvent\n        super(MainWindow, self).keyPressEvent(event)\n\nif __name__ == \'__main__\':\n    import sys\n    app = QApplication(sys.argv)\n    mainWindow = MainWindow()\n\n    mainWindow.show()\n    sys.exit(app.exec()) \n 納入 matplotlib 動畫 ( 來源 ) \n #!/usr/bin/env python\n\nimport random\nimport numpy as np\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nfrom PyQt5.QtCore import (QLineF, QPointF, QRectF, Qt, QTimer)\nfrom PyQt5.QtGui import (QBrush, QColor, QPainter)\nfrom PyQt5.QtWidgets import (QApplication, QGraphicsView, QGraphicsScene, QGraphicsItem,\n                             QGridLayout, QVBoxLayout, QHBoxLayout, QSizePolicy,\n                             QLabel, QLineEdit, QPushButton)\n\n# FigureCanvas inherits QWidget\nclass MainWindow(FigureCanvas):\n    def __init__(self, parent=None, width=4, height=3, dpi=100):\n        fig = Figure(figsize=(width, height), dpi=dpi)\n        self.axes = fig.add_subplot(111)\n        self.axes.hold(False)\n\n        super(MainWindow, self).__init__(fig)\n        self.setParent(parent)\n\n        FigureCanvas.setSizePolicy(self,\n                                   QSizePolicy.Expanding,\n                                   QSizePolicy.Expanding)\n        FigureCanvas.updateGeometry(self)\n\n        timer = QTimer(self)\n        timer.timeout.connect(self.update_figure)\n        timer.start(50)\n\n        self.x  = np.arange(0, 4*np.pi, 0.1)\n        self.y  = np.sin(self.x)\n\n        self.setWindowTitle("Sin Curve")\n\n    def update_figure(self):\n        self.axes.plot(self.x, self.y)\n        self.y = np.roll(self.y,-1)\n        self.draw()\n\nif __name__ == \'__main__\':\n    import sys\n    app = QApplication(sys.argv)\n    mainWindow = MainWindow()\n\n    mainWindow.show()\n    sys.exit(app.exec()) \n 表單 Factorial ( 來源 ) \n #!/usr/bin/env python\n\nfrom PyQt5.QtWidgets import (QApplication, QWidget,\n                             QGridLayout, QVBoxLayout, QHBoxLayout,\n                             QLabel, QLineEdit, QPushButton)\n\ndef factorial(n):\n    if n < 0:\n        return -1\n    elif n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nclass MainWindow(QWidget):\n    def __init__(self, parent=None):\n        super(MainWindow, self).__init__(parent)\n\n        self.inputLine = QLineEdit()\n        self.outputLine = QLineEdit()\n        self.outputLine.setReadOnly(True)\n\n        self.calcButton = QPushButton("&Calc")\n        self.calcButton.clicked.connect(self.calc)\n\n        lineLayout = QGridLayout()\n        lineLayout.addWidget(QLabel("num"), 0, 0)\n        lineLayout.addWidget(self.inputLine, 0, 1)\n        lineLayout.addWidget(QLabel("result"), 1, 0)\n        lineLayout.addWidget(self.outputLine, 1, 1)\n\n        buttonLayout = QVBoxLayout()\n        buttonLayout.addWidget(self.calcButton)\n\n        mainLayout = QHBoxLayout()\n        mainLayout.addLayout(lineLayout)\n        mainLayout.addLayout(buttonLayout)\n\n        self.setLayout(mainLayout)\n        self.setWindowTitle("Factorial")\n\n    def calc(self):\n        n = int(self.inputLine.text())\n        r = factorial(n)\n        self.outputLine.setText(str(r))\n\nif __name__ == \'__main__\':\n    import sys\n    app = QApplication(sys.argv)\n    main_window = MainWindow()\n\n    main_window.show()\n    sys.exit(app.exec()) \n 使用 QGraphicsView 與 QWidget ( 來源 ) \n #!/usr/bin/env python\n\nimport random\n\nfrom PyQt5.QtCore import (QLineF, QPointF, QRectF, Qt, QTimer)\nfrom PyQt5.QtGui import (QBrush, QColor, QPainter, QIntValidator)\nfrom PyQt5.QtWidgets import (QApplication, QWidget, QGraphicsView, QGraphicsScene, QGraphicsItem,\n                             QGridLayout, QVBoxLayout, QHBoxLayout,\n                             QLabel, QLineEdit, QPushButton)\n\nclass CelllarAutomaton(QGraphicsItem):\n    def __init__(self, width=500, height=500, size=5):\n        super(CelllarAutomaton, self).__init__()\n        self.width = width\n        self.height = height\n        self.size = size\n        self.NH = self.height//size\n        self.NW = self.width//size\n        self.board = []\n        for y in range(self.NH):\n            self.board.append([0] * self.NW)\n        self.board[0][self.NW//2] = 1\n        self.pos = 0\n\n    def reset(self):\n        for y in range(self.NH):\n            for x in range(self.NW):\n                self.board[y][x] = 0\n        self.board[0][self.NW//2] = 1\n        self.pos = 0\n        self.update()\n\n    def randomInit(self):\n        for y in range(self.NH):\n            for x in range(self.NW):\n                self.board[y][x] = 0\n        for x in range(self.NW):\n            self.board[0][x] = int(random.random() < 0.2)\n        self.pos = 0\n        self.update()\n\n    def paint(self, painter, option, widget):\n        painter.setPen(QColor(220,220,220))\n        for y in range(self.NH):\n            painter.drawLine(0, y*self.size, self.width, y*self.size)\n        for x in range(self.NW):\n            painter.drawLine(x*self.size, 0, x*self.size, self.height)\n\n        painter.setBrush(Qt.black)\n        for y in range(self.NH):\n            for x in range(self.NW):\n                if self.board[y][x] == 1:\n                    painter.drawRect(self.size*x, self.size*y, self.size, self.size)\n\n    def do_prev(self):\n        if self.pos == 0:\n            return\n        for x in range(self.NW):\n            self.board[self.pos][x] = 0\n        self.pos -= 1\n        self.update()\n\n    def do_next(self, n):\n        if self.pos+1 >= self.NH:\n            return False\n        p = []\n        for i in range(8):\n            p.append(n & 0b1) \n            n >>= 1\n\n        self.board[self.pos+1][0] = p[(self.board[self.pos][0]<<1) + self.board[self.pos][1]]\n        self.board[self.pos+1][self.NW-1] = p[(self.board[self.pos][self.NW-2]<<1) + self.board[self.pos][self.NW-1]]\n        for x in range(1,self.NW-1):\n            self.board[self.pos+1][x] = p[(self.board[self.pos][x-1]<<2)\n                                            + (self.board[self.pos][x]<<1)\n                                            + (self.board[self.pos][x+1])]\n        self.pos += 1\n        self.update()\n        return True\n\n    def boundingRect(self):\n        return QRectF(0,0,self.width,self.height)\n\nclass MainWindow(QWidget):\n    def __init__(self, parent=None):\n        super(MainWindow, self).__init__(parent)\n\n        self.graphicsView = QGraphicsView()\n        scene = QGraphicsScene(self.graphicsView)\n        scene.setSceneRect(0, 0, 400, 400)\n        self.graphicsView.setScene(scene)\n        self.celluarAutomaton = CelllarAutomaton(400,400)\n        scene.addItem(self.celluarAutomaton)\n\n        validator = QIntValidator(0,1)\n        ruleLayout = QGridLayout()\n        ruleLayout.setAlignment(Qt.AlignTop)\n        self.ruleEdits = []\n        for i in range(7,-1,-1):\n            ruleEdit = QLineEdit()\n            ruleEdit.setValidator(validator)\n            ruleEdit.setText("0")\n            ruleEdit.setFixedWidth(30)\n            ruleEdit.textEdited.connect(self.update_rule)\n            ruleLayout.addWidget(QLabel("{0:03b}".format(i)), 0, 7-i)\n            ruleLayout.addWidget(ruleEdit, 1,7-i)\n            self.ruleEdits.append(ruleEdit)\n\n        validator2 = QIntValidator(0,255)\n        self.rule10Edit = QLineEdit()\n        self.rule10Edit.setValidator(validator2)\n        self.rule10Edit.textEdited.connect(self.update_rule10)\n        rule10Layout = QHBoxLayout()\n        rule10Layout.addWidget(QLabel("Rule"))\n        rule10Layout.addWidget(self.rule10Edit)\n\n        self.resetButton = QPushButton("&Reset")\n        self.resetButton.clicked.connect(self.reset)\n        self.randomInitButton = QPushButton("&Random init")\n        self.randomInitButton.clicked.connect(self.randomInit)\n        self.nextButton = QPushButton("&Next")\n        self.nextButton.clicked.connect(self.do_next)\n        self.prevButton = QPushButton("&Prev")\n        self.prevButton.clicked.connect(self.do_prev)\n        self.autoButton = QPushButton("&Auto")\n        self.autoButton.clicked.connect(self.auto)\n        self.stopButton = QPushButton("&Stop")\n        self.stopButton.clicked.connect(self.stop)\n        buttonLayout = QVBoxLayout()\n        buttonLayout.addWidget(self.resetButton)\n        buttonLayout.addWidget(self.randomInitButton)\n        buttonLayout.addWidget(self.nextButton)\n        buttonLayout.addWidget(self.prevButton)\n        buttonLayout.addWidget(self.autoButton)\n        buttonLayout.addWidget(self.stopButton)\n\n        propertyLayout = QVBoxLayout()\n        propertyLayout.setAlignment(Qt.AlignTop)\n        propertyLayout.addLayout(ruleLayout)\n        propertyLayout.addLayout(rule10Layout)\n        propertyLayout.addLayout(buttonLayout)\n\n        mainLayout = QHBoxLayout()\n        mainLayout.setAlignment(Qt.AlignTop)\n        mainLayout.addWidget(self.graphicsView)\n        mainLayout.addLayout(propertyLayout)\n\n        self.setLayout(mainLayout)\n        self.setWindowTitle("Cellular Automaton")\n        self.updating_rule = False\n        self.rule10Edit.setText("90")\n        self.update_rule10()\n        self.timer = None\n\n    def update_rule(self):\n        if self.updating_rule: return\n        rule = 0\n        for i in range(8):\n            n = self.ruleEdits[i].text()\n            if n == "": return\n            rule = (rule << 1) + int(n)\n        self.updating_rule = True\n        self.rule10Edit.setText(str(rule))\n        self.updating_rule = False\n\n    def update_rule10(self):\n        n = self.rule10Edit.text()\n        if n == "": return\n        rule = int(n)\n        self.updating_rule = True\n        for i in range(7,-1,-1):\n            self.ruleEdits[i].setText(str(rule & 0b1))\n            rule >>= 1\n        self.updating_rule = False\n\n    def do_next(self):\n        n = self.rule10Edit.text()\n        return self.celluarAutomaton.do_next(int(n))\n\n    def do_prev(self):\n        self.celluarAutomaton.do_prev()\n\n    def reset(self):\n        self.celluarAutomaton.reset()\n\n    def randomInit(self):\n        self.celluarAutomaton.randomInit()\n\n    def auto(self):\n        self.timer = QTimer()\n        self.timer.setInterval(100)\n        self.timer.timeout.connect(self.timeout)\n        self.timer.start()\n\n    def timeout(self):\n        r = self.do_next()\n        if not r:\n            self.stop()\n\n    def stop(self):\n        if self.timer:\n            self.timer.stop()\n            self.timer = None\n\n    #def keyPressEvent(self, event):\n    #    key = event.key()\n    #    super(MainWindow, self).keyPressEvent(event)\n\nif __name__ == \'__main__\':\n    import sys\n    app = QApplication(sys.argv)\n    mainWindow = MainWindow()\n\n    mainWindow.show()\n    sys.exit(app.exec()) \n 使用 Eric6 開發 PyQt5 GUI 程式: \n 參考流程:  http://www.science.smith.edu/dftwiki/index.php/PyQt5_Tutorial:_A_Window_Application_with_File_IO   \n Qt Designer 教學.pdf \n', 'tags': '', 'url': 'PyQt5 範例.html'}, {'title': 'STetris', 'text': 'StApp.py \n import sys\nfrom StTetris import StTetris\nfrom PyQt5.QtWidgets import QApplication\n\n\nif __name__ == \'__main__\':\n\n    app = QApplication(sys.argv)\n    stetris = StTetris()\n    stetris.start()\n    sys.exit(app.exec()) \n StTetris.py \n from StPlay import StPlay\nfrom StScore import StScore\nfrom PyQt5.QtCore import QBasicTimer, QRect, Qt\nfrom PyQt5.QtGui import QBrush, QColor, QFont, QPainter\nfrom PyQt5.QtWidgets import QWidget\n\n\nclass StTetris(QWidget):\n\n    ST_WINDOW_WIDTH = 800\n    ST_WINDOW_HEIGHT = 600\n    ST_BLOCK_WIDTH = 30\n    ST_BLOCK_HEIGHT = 30\n    ST_BOARD_POS_X = 200\n    ST_BOARD_POS_Y = 0\n    ST_NEXT_BLOCK_POS_X = 650\n    ST_NEXT_BLOCK_POS_Y = 150\n    ST_SCORE_POS_X = 550\n    ST_SCORE_POS_Y = 30\n    ST_HIGHSCORE_POS_X = 650\n    ST_HIGHSCORE_POS_Y = 30\n    ST_BLOCK_COLOR = ["#000000", "#C71585", "#FFA500", "#FFD700", "#228B22", "#1E90FF", "#483D8B", "#9932CC"]\n    ST_BACKGROUND_COLOR = "#FFFFFF"\n    ST_DOWN_INTERVAL = 500\n\n    # Constructor\n    def __init__(self):\n        super().__init__()\n\n        # Show widget\n        super().resize(self.ST_WINDOW_WIDTH, self.ST_WINDOW_HEIGHT)\n        super().setWindowTitle("STetris")\n        super().show()\n\n        # Painter\n        self.painter = QPainter()\n\n        # Play\n        self.play = StPlay(self)\n        # Score\n        self.score = StScore()\n        # High Score\n        self.highScore = StScore()\n        # Load high score\n        # highScore = sessionStorage.getItem("highscore")\n        # if (highScore):\n        #   Set high score\n        #   self.highScore.setScore(highScore)\n        # Play interval\n        self.playInterval = 500\n        # Play timer\n        self.playTimer = QBasicTimer()\n\n    # Start\n    def start(self):\n        # Set interval\n        self.playTimer.start(self.ST_DOWN_INTERVAL, self)\n\n    # Stop\n    def stop(self):\n        self.playTimer.stop()\n\n    def timerEvent(self, e):\n        self.play.moveDown()\n\n    def keyPressEvent(self, e):\n        key = e.key()\n\n        if key == Qt.Key_Left:\n            self.play.moveLeft()\n        elif key == Qt.Key_Right:\n            self.play.moveRight()\n        elif key == Qt.Key_Down:\n            self.play.moveDown()\n        elif key == Qt.Key_Up:\n            self.play.rotate()\n        elif key == Qt.Key_Space:\n            self.play.drop()\n\n    # Notify\n    def notify(self, message, param=None):\n        if (message == StPlay.ST_NOTIFY_DOWN):\n            self.score.setScore(self.score.getScore() + 100)\n        elif (message == StPlay.ST_NOTIFY_DROP):\n            self.score.setScore(self.score.getScore() + 100)\n        elif (message == StPlay.ST_NOTIFY_CLEAR):\n            self.score.setScore(self.score.getScore()\n                                + param.cleared_lines * 1000)\n        elif (message == StPlay.ST_NOTIFY_TETRISOVER):\n            self.stop()\n\n        # Update high score\n        #if self.highScore.getScore() < self.score.getScore():\n        #    self.highScore.setScore(self.score.getScore())\n        #    sessionStorage.setItem("highscore", self.highScore.getScore())\n\n        self.update()\n\n    def paintEvent(self, e):\n        self.painter.begin(self)\n        self.drawTetris(self.painter)\n        self.painter.end()\n\n    # Draw tetris\n    def drawTetris(self, painter):\n\n        # Draw background\n        rect = {\n            "x" : 0,\n            "y" : 0,\n            "width" : self.ST_WINDOW_WIDTH,\n            "height" : self.ST_WINDOW_HEIGHT\n        }\n        self.drawBackground(painter, rect)\n\n        # Draw board\n        boardRect = {\n            "x" : self.ST_BOARD_POS_X,\n            "y" : self.ST_BOARD_POS_Y,\n            "width" : self.ST_BLOCK_WIDTH * self.play.getBoard().getXSize(),\n            "height" : self.ST_BLOCK_HEIGHT * self.play.getBoard().getYSize()\n        }\n        self.drawBoard(painter, boardRect, self.play.getBoard())\n\n        # Draw current block\n        self.drawBlock(painter, boardRect, self.play.getCurrentBlock())\n\n        # Draw next block\n        nextBlockRect = {\n            "x" : self.ST_NEXT_BLOCK_POS_X,\n            "y" : self.ST_NEXT_BLOCK_POS_Y,\n            "width" : self.ST_BLOCK_WIDTH * 4,\n            "height" : self.ST_BLOCK_HEIGHT * 4,\n        }\n        self.drawBlock(painter, nextBlockRect, self.play.getNextBlock())\n\n        # Draw score\n        scoreRect = {\n            "x" : self.ST_SCORE_POS_X,\n            "y" : self.ST_SCORE_POS_Y,\n            "width" : self.ST_BLOCK_WIDTH * 7,\n            "height" : self.ST_BLOCK_HEIGHT * 2\n        }\n        self.drawScore(painter, scoreRect, "SCORE", self.score)\n\n        # Draw high score\n        highScoreRect = {\n            "x" : self.ST_HIGHSCORE_POS_X,\n            "y" : self.ST_HIGHSCORE_POS_Y,\n            "width" : self.ST_BLOCK_WIDTH * 7,\n            "height" : self.ST_BLOCK_HEIGHT * 2\n        }\n        self.drawScore(painter, highScoreRect, "HIGH SCORE", self.highScore)\n\n    # Draw background\n    def drawBackground(self, painter, rect):\n        painter.fillRect(QRect(rect["x"], rect["y"], rect["width"], rect["height"]), QColor(self.ST_BACKGROUND_COLOR))\n\n    # Draw board\n    def drawBoard(self, painter, rect, board):\n\n        # Draw board\n        for boardY in range(board.getYSize()):\n            for boardX in range(board.getXSize()):\n                rectBlock = {\n                    "x" : rect["x"] + boardX * StTetris.ST_BLOCK_WIDTH,\n                    "y" : rect["y"] + boardY * StTetris.ST_BLOCK_HEIGHT,\n                    "width" : StTetris.ST_BLOCK_WIDTH,\n                    "height" : StTetris.ST_BLOCK_HEIGHT\n                }\n                fillColor = StTetris.ST_BLOCK_COLOR[self.play.getBoard().getBlock(boardX, boardY)]\n                painter.fillRect(QRect(rectBlock["x"], rectBlock["y"], rectBlock["width"], rectBlock["height"]), QColor(fillColor))\n\n    # Draw block\n    def drawBlock(self, painter, rect, block):\n\n        # Draw block\n        for blockY in range(block.getYSize()):\n            for blockX in range(block.getXSize()):\n                if block.getBlock(blockX, blockY):\n                    rectBlock = {\n                        "x" : rect["x"] + (block.getXPos() + blockX) * StTetris.ST_BLOCK_WIDTH,\n                        "y" : rect["y"] + (block.getYPos() + blockY) * StTetris.ST_BLOCK_HEIGHT,\n                        "width" : StTetris.ST_BLOCK_WIDTH,\n                        "height" : StTetris.ST_BLOCK_HEIGHT\n                    }\n                    fillColor = StTetris.ST_BLOCK_COLOR[block.getBlock(blockX, blockY)]\n                    painter.fillRect(QRect(rectBlock["x"], rectBlock["y"], rectBlock["width"], rectBlock["height"]), QColor(fillColor))\n\n    # Draw score\n    def drawScore(self, painter, rect, title, score):\n        # Draw title\n        painter.textAligh = "right"\n        painter.fillStyle = "red"\n        painter.drawText(rect["x"], rect["y"], title)\n\n        # Draw score\n        painter.drawText(rect["x"], rect["y"] + rect["height"] // 2, str(score.getScore())) \n StPlay.py \n from StBoard import StBoard\nfrom StBlock import StBlock\n\nclass StPlay:\n    ST_NOTIFY_LEFT = "NOTIFY_LEFT"\n\n    ST_NOTIFY_RIGHT = "NOTIFY_RIGHT"\n\n    ST_NOTIFY_DOWN = "NOTIFY_DOWN"\n        \n    ST_NOTIFY_DROP = "NOTIFY_DROP"\n\n    ST_NOTIFY_ROTATE = "NOTIFY_ROTATE"\n\n    ST_NOTIFY_CLEAR = "NOTIFY_CLEAR"\n\n    ST_NOTIFY_TETRISOVER = "NOTIFY_TETRISOVER"\n\n    # Constructor\n    def __init__(self, notify):\n        # Board\n        self.board = StBoard()\n        # Current block\n        self.currentBlock = StBlock()\n        self.currentBlock.setXPos((self.board.getXSize() - self.currentBlock.getXSize()) // 2)\n        self.currentBlock.setYPos(0 - self.currentBlock.getYSize())\n        # Next block\n        self.nextBlock = StBlock()\n        # Notify\n        self.notify = notify\n\n    # Get board\n    def getBoard(self):\n        return self.board\n\n    # Get current block\n    def getCurrentBlock(self):\n        return self.currentBlock\n\n    # Get next block\n    def getNextBlock(self):\n        return self.nextBlock\n\n    # Move left\n    def moveLeft(self):\n        # Is block movable\n        if self.isMovable(self.currentBlock, self.currentBlock.getXPos() - 1, self.currentBlock.getYPos(), self.currentBlock.getRotation()):\n            # Set current X position to left\n            self.currentBlock.setXPos(self.currentBlock.getXPos() - 1)\n            # Notify\n            self.notify.notify(StPlay.ST_NOTIFY_LEFT)\n\n    # Move right\n    def moveRight(self):\n        # Is block movable\n        if self.isMovable(self.currentBlock, self.currentBlock.getXPos() + 1, self.currentBlock.getYPos(), self.currentBlock.getRotation()):\n            # Set current X position to right\n            self.currentBlock.setXPos(self.currentBlock.getXPos() + 1)\n            # Notify\n            self.notify.notify(StPlay.ST_NOTIFY_RIGHT)\n\n    # Move down\n    def moveDown(self):\n        # Is block movable\n        if self.isMovable(self.currentBlock, self.currentBlock.getXPos(), self.currentBlock.getYPos() + 1, self.currentBlock.getRotation()):\n            # Set current Y position to down\n            self.currentBlock.setYPos(self.currentBlock.getYPos() + 1)\n            # Notify\n            self.notify.notify(StPlay.ST_NOTIFY_DOWN)\n        # Block is not movable\n        else:\n            # Set current block to board\n            self.setCurrentBlockToBoard()\n            # Change current block\n            self.changeCurrentBlock()\n            # Clear completed line\n            cleared_lines = self.board.clearCompleteLines()\n            if cleared_lines:\n                # Notify\n                self.notify.notify(StPlay.ST_NOTIFY_CLEAR, { cleared_lines : cleared_lines })\n            # Tetris is over\n            if self.isTetrisOver():\n                # Notify\n                self.notify.notify(StPlay.ST_NOTIFY_TETRISOVER)\n\n    # Drop\n    def drop(self):\n\n        while True:\n            # Block is movable\n            if self.isMovable(self.currentBlock, self.currentBlock.getXPos(), self.currentBlock.getYPos() + 1, self.currentBlock.getRotation()):\n                # Set current Y position to down\n                self.currentBlock.setYPos(self.currentBlock.getYPos() + 1)\n            # Block is not movable\n            else:\n                # Notify\n                self.notify.notify(StPlay.ST_NOTIFY_DROP)\n                break\n\n        # Set current block to board\n        self.setCurrentBlockToBoard()\n        # Change current block\n        self.changeCurrentBlock()\n        # Clear completed line\n        cleared_lines = self.board.clearCompleteLines()\n        if cleared_lines:\n            # Notify\n            self.notify.notify(StPlay.ST_NOTIFY_CLEAR, { cleared_lines : cleared_lines })\n        # Tetris is over\n        if self.isTetrisOver():\n            # Notify\n            self.notify.notify(StPlay.ST_NOTIFY_TETRISOVER)\n\n    # Rotate\n    def rotate(self):\n        # Is block movable\n        if self.isMovable(self.currentBlock, self.currentBlock.getXPos(), self.currentBlock.getYPos(), self.currentBlock.getRotation() + 1):\n            # Rotate\n            self.currentBlock.setRotation(self.currentBlock.getRotation() + 1)\n            # Notify\n            self.notify.notify(StPlay.ST_NOTIFY_ROTATE)\n\n    # Is movable\n    def isMovable(self, block, xPos, yPos, rotation):\n\n        # Create block to check and set value to check\n        checkBlock = StBlock(block)\n        checkBlock.setXPos(xPos)\n        checkBlock.setYPos(yPos)\n        checkBlock.setRotation(rotation)\n\n        # Get value of board\n        for blockX in range(checkBlock.getXSize()):\n            for blockY in range(checkBlock.getYSize()):\n\n                # Check if block to check is empty\n                if checkBlock.getBlock(blockX, blockY) == 0:\n                    continue\n\n                boardX = checkBlock.getXPos() + blockX\n                boardY = checkBlock.getYPos() + blockY\n\n                # Check X position of block to check\n                if boardX < 0 or boardX >= self.board.getXSize():\n                    return False\n\n                # Check Y position of block to check\n                if boardY >= self.board.getYSize():\n                    return False\n\n                # Check if block is already exist\n                if self.board.getBlock(boardX, boardY) != 0:\n                    return False\n\n        return True\n\n    # Set current block to board\n    def setCurrentBlockToBoard(self):\n        # Set current block to board\n        for blockX in range(self.currentBlock.getXSize()):\n            for blockY in range(self.currentBlock.getYSize()):\n                if self.currentBlock.getBlock(blockX, blockY) != 0:\n                    self.board.setBlock(self.currentBlock.getXPos() + blockX, self.currentBlock.getYPos() + blockY, self.currentBlock.getType())\n\n    # Check if tetris is over\n    def isTetrisOver(self):\n        isTetrisOver = False\n        for boardX in range(self.board.getXSize()):\n            if self.board.getBlock(boardX, 0) != 0:\n                isTetrisOver = True\n                break\n        return isTetrisOver\n\n    # Change current block\n    def changeCurrentBlock(self):\n        # Set next block to current block\n        self.currentBlock = self.nextBlock\n        self.currentBlock.setXPos((self.board.getXSize() - self.currentBlock.getXSize()) // 2)\n        self.currentBlock.setYPos(- self.currentBlock.getYSize())\n        # Set next block\n        self.nextBlock = StBlock() \n StScore.py \n class StScore:\n    # Constructor\n    def __init__(self):\n        # Score\n        self.score = 0\n\n    # Clear\n    def clear(self):\n        self.score = 0\n\n    # Add score\n    def addScore(self, score):\n        self.score += score\n\n    # Set score\n    def setScore(self, score):\n        self.score = score\n\n    # Get score\n    def getScore(self):\n        return self.score \n StBoard.py \n import numpy\n\nclass StBoard:\n\n    # Constructor\n    def __init__(self):\n        # Board\n        self.board = numpy.zeros(shape=(self.getYSize(), self.getXSize()), dtype=int)\n\n    # Get X size\n    def getXSize(self):\n        return 10\n\n    # Get Y size\n    def getYSize(self):\n        return 20\n\n    # Get block\n    def getBlock(self, x, y):\n        if x < 0 or x >= self.getXSize():\n            return 0\n\n        if y < 0 or y >= self.getYSize():\n            return 0\n\n        return self.board[y][x]\n\n    # Set block\n    def setBlock(self, x, y, block):\n        if x < 0 or x >= self.getXSize():\n            return\n\n        if y < 0 or y >= self.getYSize():\n            return\n\n        self.board[y][x] = block\n\n    # Clear complete lines\n    def clearCompleteLines(self):\n        complete_lines = 0\n\n        for boardY in range(self.getYSize()):\n            block_count = 0\n\n            # Count the number of block\n            for boardX in range(self.getXSize()):\n                if (self.board[boardY][boardX]):\n                    block_count += 1\n\n            # The line of board is full of block\n            if block_count is len(self.board[boardY]):\n                # Delete line of board\n                self.board.pop(boardY)\n                # Add line to the beginning of the board\n                self.board = numpy.zeros(shape=(1, self.getXSize()), dtype=int) + self.board\n                complete_lines += 1\n\n        return complete_lines \n StBlock.py \n import random\n\nclass StBlock:\n\n    blocks = [ [\n                [\n                    [ 1, 0, 0 ],\n                    [ 1, 1, 1 ],\n                    [ 0, 0, 0 ]\n                ], [\n                    [ 0, 1, 0 ],\n                    [ 0, 1, 0 ],\n                    [ 1, 1, 0 ]\n                ], [\n                    [ 0, 0, 0 ],\n                    [ 1, 1, 1 ],\n                    [ 0, 0, 1 ]\n                ], [\n                    [ 0, 1, 1 ],\n                    [ 0, 1, 0 ],\n                    [ 0, 1, 0 ]\n                ]\n            ], [\n                [\n                    [ 0, 0, 2 ],\n                    [ 2, 2, 2 ],\n                    [ 0, 0, 0 ]\n                ], [\n                    [ 2, 2, 0 ],\n                    [ 0, 2, 0 ],\n                    [ 0, 2, 0 ]\n                ], [\n                    [ 0, 0, 0 ],\n                    [ 2, 2, 2 ],\n                    [ 2, 0, 0 ]\n                ], [\n                    [ 0, 2, 0 ],\n                    [ 0, 2, 0 ],\n                    [ 0, 2, 2 ]\n                ]\n            ], [\n                [\n                    [ 3, 3 ],\n                    [ 3, 3 ]\n                ]\n            ], [\n                [\n                    [ 0, 4, 4 ],\n                    [ 4, 4, 0 ],\n                    [ 0, 0, 0 ]\n                ], [\n                    [ 0, 4, 0 ],\n                    [ 0, 4, 4 ],\n                    [ 0, 0, 4 ]\n                ]\n            ], [\n                [\n                    [ 0, 0, 0 ],\n                    [ 5, 5, 5 ],\n                    [ 0, 5, 0 ]\n                ], [\n                    [ 0, 5, 0 ],\n                    [ 0, 5, 5 ],\n                    [ 0, 5, 0 ]\n                ], [\n                    [ 0, 5, 0 ],\n                    [ 5, 5, 5 ],\n                    [ 0, 0, 0 ]\n                ], [\n                    [ 0, 5, 0 ],\n                    [ 5, 5, 0 ],\n                    [ 0, 5, 0 ]\n                ]\n            ], [\n                [\n                    [ 6, 6, 0 ],\n                    [ 0, 6, 6 ],\n                    [ 0, 0, 0 ]\n                ], [\n                    [ 0, 0, 6 ],\n                    [ 0, 6, 6 ],\n                    [ 0, 6, 0 ]\n                ]\n            ], [\n                [\n                    [ 0, 0, 0, 0 ],\n                    [ 0, 0, 0, 0 ],\n                    [ 7, 7, 7, 7 ],\n                    [ 0, 0, 0, 0 ]\n                ], [\n                    [ 0, 7, 0, 0 ],\n                    [ 0, 7, 0, 0 ],\n                    [ 0, 7, 0, 0 ],\n                    [ 0, 7, 0, 0 ]\n                ]\n            ] ]\n\n    def __init__(self, block=None):\n        if block is None:\n            # Type\n            self.type = random.randint(1, len(StBlock.blocks))\n            # X Position\n            self.xPos = 0\n            # Y Position\n            self.yPos = 0\n            # Rotation\n            self.rotation = 0\n            # Block\n            self.block = StBlock.blocks[self.type-1]\n        else:\n            # Type\n            self.type = block.type\n            # X Position\n            self.xPos = block.xPos\n            # Y Position\n            self.yPos = block.yPos\n            # Rotation\n            self.rotation = block.rotation\n            # Block\n            self.block = block.block\n\n    # Get type\n    def getType(self):\n        return self.type\n\n    # Get X size\n    def getXSize(self):\n        return len(self.block[self.rotation][0])\n\n    # Get Y size\n    def getYSize(self):\n        return len(self.block[self.rotation])\n\n    # Get X position\n    def getXPos(self):\n        return self.xPos\n\n    # Get Y position\n    def getYPos(self):\n        return self.yPos\n\n    # Get rotation\n    def getRotation(self):\n        return self.rotation\n\n    # Get block\n    def getBlock(self, x, y):\n        if x < 0 or x >= self.getXSize():\n            return 0\n\n        if y < 0 or y >= self.getYSize():\n            return 0\n\n        return self.block[self.rotation][y][x]\n\n    # Set X position\n    def setXPos(self, xPos):\n        self.xPos = xPos\n\n    # Set Y position\n    def setYPos(self, yPos):\n        self.yPos = yPos\n    \n    # Set rotation\n    def setRotation(self, rotation):\n        self.rotation = self.rotation % len(self.block) \n Reference: \n https://github.com/siprikorea/stetris-python   \n', 'tags': '', 'url': 'STetris.html'}, {'title': 'Tetrix', 'text': 'import copy\nimport random\n\nfrom PyQt5.QtCore import pyqtSignal, QBasicTimer, QSize, Qt\nfrom PyQt5.QtGui import QColor, QPainter, QPixmap\nfrom PyQt5.QtWidgets import (QApplication, QFrame, QGridLayout, QLabel,\n        QLCDNumber, QPushButton, QWidget)\n\n\nNoShape, ZShape, SShape, LineShape, TShape, SquareShape, LShape, MirroredLShape = range(8)\n\n\nclass TetrixWindow(QWidget):\n    def __init__(self):\n        super().__init__()\n\n        self.board = TetrixBoard()\n\n        nextPieceLabel = QLabel()\n        nextPieceLabel.setFrameStyle(QFrame.Box | QFrame.Raised)\n        nextPieceLabel.setAlignment(Qt.AlignCenter)\n        self.board.setNextPieceLabel(nextPieceLabel)\n\n        scoreLcd = QLCDNumber(5)\n        scoreLcd.setSegmentStyle(QLCDNumber.Filled)\n        levelLcd = QLCDNumber(2)\n        levelLcd.setSegmentStyle(QLCDNumber.Filled)\n        linesLcd = QLCDNumber(5)\n        linesLcd.setSegmentStyle(QLCDNumber.Filled)\n\n        startButton = QPushButton("&Start")\n        startButton.setFocusPolicy(Qt.NoFocus)\n        quitButton = QPushButton("&Quit")\n        quitButton.setFocusPolicy(Qt.NoFocus)\n        pauseButton = QPushButton("&Pause")\n        pauseButton.setFocusPolicy(Qt.NoFocus)\n\n        startButton.clicked.connect(self.board.start)\n        pauseButton.clicked.connect(self.board.pause)\n        quitButton.clicked.connect(QApplication.instance().quit)\n        self.board.scoreChanged.connect(scoreLcd.display)\n        self.board.levelChanged.connect(levelLcd.display)\n        self.board.linesRemovedChanged.connect(linesLcd.display)\n\n        layout = QGridLayout()\n        layout.addWidget(self.createLabel("NEXT"), 0, 0)\n        layout.addWidget(nextPieceLabel, 1, 0)\n        layout.addWidget(self.createLabel("LEVEL"), 2, 0)\n        layout.addWidget(levelLcd, 3, 0)\n        layout.addWidget(startButton, 4, 0)\n        layout.addWidget(self.board, 0, 1, 6, 1)\n        layout.addWidget(self.createLabel("SCORE"), 0, 2)\n        layout.addWidget(scoreLcd, 1, 2)\n        layout.addWidget(self.createLabel("LINES REMOVED"), 2, 2)\n        layout.addWidget(linesLcd, 3, 2)\n        layout.addWidget(quitButton, 4, 2)\n        layout.addWidget(pauseButton, 5, 2)\n        self.setLayout(layout)\n\n        self.setWindowTitle("Tetrix")\n        self.resize(550, 370)\n\n    def createLabel(self, text):\n        lbl = QLabel(text)\n        lbl.setAlignment(Qt.AlignHCenter | Qt.AlignBottom)\n        return lbl\n\n\nclass TetrixBoard(QFrame):\n    BoardWidth = 10\n    BoardHeight = 22\n\n    scoreChanged = pyqtSignal(int)\n\n    levelChanged = pyqtSignal(int)\n\n    linesRemovedChanged = pyqtSignal(int)\n\n    def __init__(self, parent=None):\n        super().__init__()\n\n        self.timer = QBasicTimer()\n        self.nextPieceLabel = None\n        self.isWaitingAfterLine = False\n        self.curPiece = TetrixPiece()\n        self.nextPiece = TetrixPiece()\n        self.curX = 0\n        self.curY = 0\n        self.numLinesRemoved = 0\n        self.numPiecesDropped = 0\n        self.score = 0\n        self.level = 0\n        self.board = None\n\n        self.setFrameStyle(QFrame.Panel | QFrame.Sunken)\n        self.setFocusPolicy(Qt.StrongFocus)\n        self.isStarted = False\n        self.isPaused = False\n        self.clearBoard()\n\n        self.nextPiece.setRandomShape()\n\n    def shapeAt(self, x, y):\n        return self.board[(y * TetrixBoard.BoardWidth) + x]\n\n    def setShapeAt(self, x, y, shape):\n        self.board[(y * TetrixBoard.BoardWidth) + x] = shape   \n\n    def timeoutTime(self):\n        return 1000 / (1 + self.level)\n\n    def squareWidth(self):\n        return self.contentsRect().width() / TetrixBoard.BoardWidth\n\n    def squareHeight(self):\n        return self.contentsRect().height() / TetrixBoard.BoardHeight\n\n    def setNextPieceLabel(self, label):\n        self.nextPieceLabel = label\n\n    def sizeHint(self):\n        return QSize(TetrixBoard.BoardWidth * 15 + self.frameWidth() * 2,\n                TetrixBoard.BoardHeight * 15 + self.frameWidth() * 2)\n\n    def minimumSizeHint(self):\n        return QSize(TetrixBoard.BoardWidth * 5 + self.frameWidth() * 2,\n                TetrixBoard.BoardHeight * 5 + self.frameWidth() * 2)\n\n    def start(self):\n        if self.isPaused:\n            return\n\n        self.isStarted = True\n        self.isWaitingAfterLine = False\n        self.numLinesRemoved = 0\n        self.numPiecesDropped = 0\n        self.score = 0\n        self.level = 1\n        self.clearBoard()\n\n        self.linesRemovedChanged.emit(self.numLinesRemoved)\n        self.scoreChanged.emit(self.score)\n        self.levelChanged.emit(self.level)\n\n        self.newPiece()\n        self.timer.start(self.timeoutTime(), self)\n\n    def pause(self):\n        if not self.isStarted:\n            return\n\n        self.isPaused = not self.isPaused\n        if self.isPaused:\n            self.timer.stop()\n        else:\n            self.timer.start(self.timeoutTime(), self)\n\n        self.update()\n\n    def paintEvent(self, event):\n        super(TetrixBoard, self).paintEvent(event)\n\n        painter = QPainter(self)\n        rect = self.contentsRect()\n\n        if self.isPaused:\n            painter.drawText(rect, Qt.AlignCenter, "Pause")\n            return\n\n        boardTop = rect.bottom() - TetrixBoard.BoardHeight * self.squareHeight()\n\n        for i in range(TetrixBoard.BoardHeight):\n            for j in range(TetrixBoard.BoardWidth):\n                shape = self.shapeAt(j, TetrixBoard.BoardHeight - i - 1)\n                if shape != NoShape:\n                    self.drawSquare(painter,\n                            rect.left() + j * self.squareWidth(),\n                            boardTop + i * self.squareHeight(), shape)\n\n        if self.curPiece.shape() != NoShape:\n            for i in range(4):\n                x = self.curX + self.curPiece.x(i)\n                y = self.curY - self.curPiece.y(i)\n                self.drawSquare(painter, rect.left() + x * self.squareWidth(),\n                        boardTop + (TetrixBoard.BoardHeight - y - 1) * self.squareHeight(),\n                        self.curPiece.shape())\n\n    def keyPressEvent(self, event):\n        if not self.isStarted or self.isPaused or self.curPiece.shape() == NoShape:\n            super(TetrixBoard, self).keyPressEvent(event)\n            return\n\n        key = event.key()\n        if key == Qt.Key_Left:\n            self.tryMove(self.curPiece, self.curX - 1, self.curY)\n        elif key == Qt.Key_Right:\n            self.tryMove(self.curPiece, self.curX + 1, self.curY)\n        elif key == Qt.Key_Down:\n            self.tryMove(self.curPiece.rotatedRight(), self.curX, self.curY)\n        elif key == Qt.Key_Up:\n            self.tryMove(self.curPiece.rotatedLeft(), self.curX, self.curY)\n        elif key == Qt.Key_Space:\n            self.dropDown()\n        elif key == Qt.Key_D:\n            self.oneLineDown()\n        else:\n            super(TetrixBoard, self).keyPressEvent(event)\n\n    def timerEvent(self, event):\n        if event.timerId() == self.timer.timerId():\n            if self.isWaitingAfterLine:\n                self.isWaitingAfterLine = False\n                self.newPiece()\n                self.timer.start(self.timeoutTime(), self)\n            else:\n                self.oneLineDown()\n        else:\n            super(TetrixBoard, self).timerEvent(event)\n\n    def clearBoard(self):\n        self.board = [NoShape for i in range(TetrixBoard.BoardHeight * TetrixBoard.BoardWidth)]\n\n    def dropDown(self):\n        dropHeight = 0\n        newY = self.curY\n        while newY > 0:\n            if not self.tryMove(self.curPiece, self.curX, newY - 1):\n                break\n            newY -= 1\n            dropHeight += 1\n\n        self.pieceDropped(dropHeight)\n\n    def oneLineDown(self):\n        if not self.tryMove(self.curPiece, self.curX, self.curY - 1):\n            self.pieceDropped(0)\n\n    def pieceDropped(self, dropHeight):\n        for i in range(4):\n            x = self.curX + self.curPiece.x(i)\n            y = self.curY - self.curPiece.y(i)\n            self.setShapeAt(x, y, self.curPiece.shape())\n\n        self.numPiecesDropped += 1\n        if self.numPiecesDropped % 25 == 0:\n            self.level += 1\n            self.timer.start(self.timeoutTime(), self)\n            self.levelChanged.emit(self.level)\n\n        self.score += dropHeight + 7\n        self.scoreChanged.emit(self.score)\n        self.removeFullLines()\n\n        if not self.isWaitingAfterLine:\n            self.newPiece()\n\n    def removeFullLines(self):\n        numFullLines = 0\n\n        for i in range(TetrixBoard.BoardHeight - 1, -1, -1):\n            lineIsFull = True\n\n            for j in range(TetrixBoard.BoardWidth):\n                if self.shapeAt(j, i) == NoShape:\n                    lineIsFull = False\n                    break\n\n            if lineIsFull:\n                numFullLines += 1\n                for k in range(TetrixBoard.BoardHeight - 1):\n                    for j in range(TetrixBoard.BoardWidth):\n                        self.setShapeAt(j, k, self.shapeAt(j, k + 1))\n\n                for j in range(TetrixBoard.BoardWidth):\n                    self.setShapeAt(j, TetrixBoard.BoardHeight - 1, NoShape)\n\n        if numFullLines > 0:\n            self.numLinesRemoved += numFullLines\n            self.score += 10 * numFullLines\n            self.linesRemovedChanged.emit(self.numLinesRemoved)\n            self.scoreChanged.emit(self.score)\n\n            self.timer.start(500, self)\n            self.isWaitingAfterLine = True\n            self.curPiece.setShape(NoShape)\n            self.update()\n\n    def newPiece(self):\n        self.curPiece = copy.deepcopy(self.nextPiece)\n        self.nextPiece.setRandomShape()\n        self.showNextPiece()\n        self.curX = TetrixBoard.BoardWidth // 2 + 1\n        self.curY = TetrixBoard.BoardHeight - 1 + self.curPiece.minY()\n\n        if not self.tryMove(self.curPiece, self.curX, self.curY):\n            self.curPiece.setShape(NoShape)\n            self.timer.stop()\n            self.isStarted = False\n\n    def showNextPiece(self):\n        if self.nextPieceLabel is None:\n            return\n\n        dx = self.nextPiece.maxX() - self.nextPiece.minX() + 1\n        dy = self.nextPiece.maxY() - self.nextPiece.minY() + 1\n\n        pixmap = QPixmap(dx * self.squareWidth(), dy * self.squareHeight())\n        painter = QPainter(pixmap)\n        painter.fillRect(pixmap.rect(), self.nextPieceLabel.palette().window())\n\n        for i in range(4):\n            x = self.nextPiece.x(i) - self.nextPiece.minX()\n            y = self.nextPiece.y(i) - self.nextPiece.minY()\n            self.drawSquare(painter, x * self.squareWidth(),\n                    y * self.squareHeight(), self.nextPiece.shape())\n\n        painter.end()\n\n        self.nextPieceLabel.setPixmap(pixmap)\n\n    def tryMove(self, newPiece, newX, newY):\n        for i in range(4):\n            x = newX + newPiece.x(i)\n            y = newY - newPiece.y(i)\n            if x < 0 or x >= TetrixBoard.BoardWidth or y < 0 or y >= TetrixBoard.BoardHeight:\n                return False\n            if self.shapeAt(x, y) != NoShape:\n                return False\n\n        self.curPiece = newPiece\n        self.curX = newX\n        self.curY = newY\n        self.update()\n        return True\n\n    def drawSquare(self, painter, x, y, shape):\n        colorTable = [0x000000, 0xCC6666, 0x66CC66, 0x6666CC,\n                      0xCCCC66, 0xCC66CC, 0x66CCCC, 0xDAAA00]\n\n        color = QColor(colorTable[shape])\n        painter.fillRect(x + 1, y + 1, self.squareWidth() - 2,\n                self.squareHeight() - 2, color)\n\n        painter.setPen(color.lighter())\n        painter.drawLine(x, y + self.squareHeight() - 1, x, y)\n        painter.drawLine(x, y, x + self.squareWidth() - 1, y)\n\n        painter.setPen(color.darker())\n        painter.drawLine(x + 1, y + self.squareHeight() - 1,\n                x + self.squareWidth() - 1, y + self.squareHeight() - 1)\n        painter.drawLine(x + self.squareWidth() - 1,\n                y + self.squareHeight() - 1, x + self.squareWidth() - 1, y + 1)\n\n\nclass TetrixPiece(object):\n    coordsTable = (\n        ((0, 0),     (0, 0),     (0, 0),     (0, 0)),\n        ((0, -1),    (0, 0),     (-1, 0),    (-1, 1)),\n        ((0, -1),    (0, 0),     (1, 0),     (1, 1)),\n        ((0, -1),    (0, 0),     (0, 1),     (0, 2)),\n        ((-1, 0),    (0, 0),     (1, 0),     (0, 1)),\n        ((0, 0),     (1, 0),     (0, 1),     (1, 1)),\n        ((-1, -1),   (0, -1),    (0, 0),     (0, 1)),\n        ((1, -1),    (0, -1),    (0, 0),     (0, 1))\n    )\n\n    def __init__(self):\n        self.coords = [[0, 0] for _ in range(4)]\n        self.pieceShape = NoShape\n\n        self.setShape(NoShape)\n\n    def shape(self):\n        return self.pieceShape\n\n    def setShape(self, shape):\n        table = TetrixPiece.coordsTable[shape]\n        for i in range(4):\n            for j in range(2):\n                self.coords[i][j] = table[i][j]\n\n        self.pieceShape = shape\n\n    def setRandomShape(self):\n        self.setShape(random.randint(1, 7))\n\n    def x(self, index):\n        return self.coords[index][0]\n\n    def y(self, index):\n        return self.coords[index][1]\n\n    def setX(self, index, x):\n        self.coords[index][0] = x\n\n    def setY(self, index, y):\n        self.coords[index][1] = y\n\n    def minX(self):\n        m = self.coords[0][0]\n        for i in range(4):\n            m = min(m, self.coords[i][0])\n\n        return m\n\n    def maxX(self):\n        m = self.coords[0][0]\n        for i in range(4):\n            m = max(m, self.coords[i][0])\n\n        return m\n\n    def minY(self):\n        m = self.coords[0][1]\n        for i in range(4):\n            m = min(m, self.coords[i][1])\n\n        return m\n\n    def maxY(self):\n        m = self.coords[0][1]\n        for i in range(4):\n            m = max(m, self.coords[i][1])\n\n        return m\n\n    def rotatedLeft(self):\n        if self.pieceShape == SquareShape:\n            return self\n\n        result = TetrixPiece()\n        result.pieceShape = self.pieceShape\n        for i in range(4):\n            result.setX(i, self.y(i))\n            result.setY(i, -self.x(i))\n\n        return result\n\n    def rotatedRight(self):\n        if self.pieceShape == SquareShape:\n            return self\n\n        result = TetrixPiece()\n        result.pieceShape = self.pieceShape\n        for i in range(4):\n            result.setX(i, -self.y(i))\n            result.setY(i, self.x(i))\n\n        return result\n\n\nif __name__ == \'__main__\':\n\n    import sys\n\n    app = QApplication(sys.argv)\n    window = TetrixWindow()\n    window.show()\n    random.seed(None)\n    sys.exit(app.exec()) \n \n', 'tags': '', 'url': 'Tetrix.html'}, {'title': 'V-rep', 'text': 'http://lab.kmol.info/2017fall/blog/kmol-2017-fall-event-driven-programming-design.html   \n \n', 'tags': '', 'url': 'V-rep.html'}, {'title': 'Lua 學習', 'text': 'http://notebook.kulchenko.com/programming/lua-good-different-bad-and-ugly-parts   \n https://github.com/CoppeliaRobotics/lua   \n http://www.coppeliarobotics.com/helpFiles/en/scripts.htm   \n', 'tags': '', 'url': 'Lua 學習.html'}, {'title': '車輛工程', 'text': 'DIY 自動駕駛: \n https://github.com/commaai/openpilot   \n https://comma.ai/   \n 舊款自印硬體:  https://github.com/commaai/neo   \n \n 自駕車:  \n https://github.com/ndrplz/self-driving-car   \n https://github.com/RyanZotti/Self-Driving-Car   \n https://github.com/philbort/awesome-self-driving-cars   \n https://github.com/ApolloAuto/apollo   \n', 'tags': '', 'url': '車輛工程.html'}, {'title': '維修管理', 'text': 'http://t2100.myweb.hinet.net/   (汽車維修管理系統) \n', 'tags': '', 'url': '維修管理.html'}, {'title': 'ERPNext', 'text': 'https://github.com/frappe/erpnext   \n https://github.com/frappe/frappe   \n https://erpnext.com/download   \n https://www.maketecheasier.com/import-export-ova-files-in-virtualbox/   \n https://www.clouderp.be/en/blog/285-installing-erpnext-on-windows-in-18-minutes   \n Frappe requirements: \n boto3\nchardet\ndropbox==7.3.1\ngunicorn\njinja2\nmarkdown2\nPyMySQL\nmaxminddb-geolite2\npython-dateutil\npytz\nsix\nwerkzeug\nsemantic_version\nrauth>=0.6.2\nrequests\nredis\nselenium\nbabel\nipython\nhtml2text==2016.9.19\nemail_reply_parser\nclick\nnum2words==0.5.5\nwatchdog==0.8.0\nbleach\nbleach-whitelist\nPillow\nbeautifulsoup4\nrq\nschedule\ncryptography\npyopenssl\nndg-httpsclient\npyasn1\nzxcvbn-python\nunittest-xml-reporting\noauthlib\npdfkit\nPyJWT\nPyPDF2\nopenpyxl\npyotp\npyqrcode\npypng\npremailer\ncroniter\ngooglemaps\nbraintree\nfuture\npasslib\ngoogle-api-python-client\ngoogle-auth\ngoogle-auth-httplib2\ngoogle-auth-oauthlib\nfaker\nstripe Erpnext requirements: \n frappe\nunidecode\npygithub\ngooglemaps\npython-stdnum\nbraintree\ngocardless_pro\nwoocommerce \n', 'tags': '', 'url': 'ERPNext.html'}, {'title': '人臉辨識', 'text': 'https://github.com/meownoid/face-identification-tpe   \n Real-time Object Detection: \n https://pjreddie.com/darknet/yolo/ \n Neural Network Library by Sony: \n https://github.com/sony/nnabla \n Structure Sensor \n https://structure.io/ \n https://github.com/occipital/openni2   \n https://skanect.occipital.com/   \n https://en.wikipedia.org/wiki/OpenNI   \n \n', 'tags': '', 'url': '人臉辨識.html'}, {'title': '輔助設計套件', 'text': 'MCAD 套件 \n http://lab.kmol.info/2017fall/blog/kmol-2017-fall-cadp-what-is-computer-aided-design.html   \n 一般常見的機械電腦輔助設計套件包括法國   Dassault   公司的   SolidWorks   與   Catia , 美國   AutoDesk   公司的   AutoCAD   與   Inventor , 德國   Siemens   公司的   Solid Edge   與   NX , 美國   PTC   公司的   Creo , 以及 2015 年推出的   Onshape \n 其他 MCAD: 俄羅斯的   T-Flex \n 如何進行電腦輔助機械設計專題 \n 1. 文獻回顧 (Literature Review) 階段 - 了解現存既有的研究成果, 確立專題定位與目標 \n 利用關鍵字搜尋相關文獻, 針對文獻回顧與探討, 初步定位專案性質以及從事專案的目標. \n 例如, 關鍵字:   marble machine construction set ,   linkage synthesis ,   arduino mechatronics ,   arduino servo control ,   lifter linkage ,   Doing a Literature Review \n 2. 整理可用工具, 擬想何謂機械?何謂設計?何謂電腦輔助?擬想所要解決的問題, 準備開始進行電腦輔助機械設計專題 \n 機械是一種功能明確的器物, 內容包含固體、流體與軟體元件, 彼此精巧配置結合, 可展現特定功能 \n 設計是一種表達, 而且是可以讓人依循, 逐步按照指示, 完成設計者預想的結果, 且表達方法包含文字、口語、2D、3D、數學與實體方法. \n 文字結合 2D、3D、數學表達方法 - 設計專題報告 \n 利用口語簡報設計專題內容 - 設計專題報告影片 \n 電腦輔助 - 利用電腦的功能協助設計進行 \n 電腦功能 - 設計組態管理、運算、模擬、網路資訊傳輸、展示、協同 \n 例如: \n 零組件繪圖工具:   Solvespace   (包含在隨身系統),   Onshape   (自行申請帳號),   PTC Creo Parametric   (可從區網下載可攜網路認證版本) ,   Autodesk Inventor   (可自行申請免費學生版本或安裝系上提供之網路認證版本),   Dassault Solidworks   (可安裝學校提供之網路認證版本). \n 協同工具:   Onshape   (自行申請帳號),   A360   (自行申請帳號) \n 模擬工具:   V-rep   (包含在隨身系統),   Blender   (包含在隨身系統),   Tinkercad   (自行申請帳號) \n 控制與致動工具:   Arduino   (包含在工具箱中),   Servo Motor   (包含在工具箱中) \n 3D 列印工具:   Delta Printer   (由系上實習設備提供) \n 3. 根據專題定位與目標, 確定所要解決的問題項目, 逐一採模組式, 以協同流程, 透過自學、執行與檢討想像, 由簡入繁, 持續改進各模組的內容與功能, 在可用時間內, 解決各種問題, 終至完成專題, 達成目標. \n 鋼球循環運動系統設計 \n 機構設計 - 軌道設計、鋼球提升與傳動系統設計、其他零組件設計 \n 致動與控制系統設計 - 電路設計、伺服馬達致動程式設計 \n 監控程式設計 - 以視窗程式啟動系統運作、傳回鋼球通過控制點訊息、計算運行距離與速度 \n marble lift mechanism \n 四連桿浮動桿通過三個位置的尺寸合成設計 \n 六連桿尺寸合成 \n 八連桿尺寸合成 \n http://www.eddiesmind.com/basic-lifting-mechanisms.html \n Linkage:   http://blog.rectorsquid.com/linkage-mechanism-designer-and-simulator/   ( Source codes ) \n LinkageDesigner (an add-on package to Wolfram\'s Mathematica):   http://www.linkagedesigner.com/ ,   https://www.wolfram.com/products/applications/linkagedesigner/ \n https://github.com/KmolYuan/Pyslvs-PyQt5 \n Stl 零件 Viewer \n 使用 Pygame 與 OpenGL \n #coding: utf8\n# source: https://www.linux.com/community/blogs/133-general-linux/291889\nimport os\nimport struct\n\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nimport pygame\nfrom pygame.locals import *\n\n#class for a 3d point\nclass createpoint:\n    def __init__(self,p,c=(1,0,0)):\n        self.point_size=0.5\n        self.color=c\n        self.x=p[0]\n        self.y=p[1]\n        self.z=p[2]\n      \n    def glvertex(self):\n        glVertex3f(self.x,self.y,self.z)\n\n#class for a 3d face on a model\nclass createtriangle:\n    points=None\n    normal=None\n\n    def __init__(self,p1,p2,p3,n=None):\n        #3 points of the triangle\n        self.points=createpoint(p1),createpoint(p2),createpoint(p3)\n      \n        #triangles normal\n        self.normal=createpoint(self.calculate_normal(self.points[0],self.points[1],self.points[2]))#(0,1,0)#\n  \n    #calculate vector / edge\n    def calculate_vector(self,p1,p2):\n        return -p1.x+p2.x,-p1.y+p2.y,-p1.z+p2.z\n      \n    def calculate_normal(self,p1,p2,p3):\n        a=self.calculate_vector(p3,p2)\n        b=self.calculate_vector(p3,p1)\n        #calculate the cross product returns a vector\n        return self.cross_product(a,b)    \n  \n    def cross_product(self,p1,p2):\n        return (p1[1]*p2[2]-p2[1]*p1[2]) , (p1[2]*p2[0])-(p2[2]*p1[0]) , (p1[0]*p2[1])-(p2[0]*p1[1])\n\nclass loader:\n    model=[]\n      \n    #return the faces of the triangles\n    def get_triangles(self):\n        if self.model:\n            for face in self.model:\n                yield face\n\n    #draw the models faces\n    def draw(self):\n        glBegin(GL_TRIANGLES)\n        for tri in self.get_triangles():\n            glNormal3f(tri.normal.x,tri.normal.y,tri.normal.z)\n            glVertex3f(tri.points[0].x,tri.points[0].y,tri.points[0].z)\n            glVertex3f(tri.points[1].x,tri.points[1].y,tri.points[1].z)\n            glVertex3f(tri.points[2].x,tri.points[2].y,tri.points[2].z)\n        glEnd()\n  \n    #load stl file detects if the file is a text file or binary file\n    def load_stl(self,filename):\n        #read start of file to determine if its a binay stl file or a ascii stl file\n        fp=open(filename,\'rb\')\n        h=fp.read(80)\n        type=h[0:5]\n        fp.close()\n\n        if type==\'solid\':\n            print ("reading text file"+str(filename))\n            self.load_text_stl(filename)\n        else:\n            print ("reading binary stl file "+str(filename,))\n            self.load_binary_stl(filename)\n  \n    #read text stl match keywords to grab the points to build the model\n    def load_text_stl(self,filename):\n        fp=open(filename,\'r\')\n\n        for line in fp.readlines():\n            words=line.split()\n            if len(words)>0:\n                if words[0]==\'solid\':\n                    self.name=words[1]\n\n                if words[0]==\'facet\':\n                    center=[0.0,0.0,0.0]\n                    triangle=[]\n                    normal=(eval(words[2]),eval(words[3]),eval(words[4]))\n                  \n                if words[0]==\'vertex\':\n                    triangle.append((eval(words[1]),eval(words[2]),eval(words[3])))\n                  \n                  \n                if words[0]==\'endloop\':\n                    #make sure we got the correct number of values before storing\n                    if len(triangle)==3:\n                        self.model.append(createtriangle(triangle[0],triangle[1],triangle[2],normal))\n        fp.close()\n\n    #load binary stl file check wikipedia for the binary layout of the file\n    #we use the struct library to read in and convert binary data into a format we can use\n    def load_binary_stl(self,filename):\n        fp=open(filename,\'rb\')\n        h=fp.read(80)\n\n        l=struct.unpack(\'I\',fp.read(4))[0]\n        count=0\n        while True:\n            try:\n                p=fp.read(12)\n                if len(p)==12:\n                    n=struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]\n                  \n                p=fp.read(12)\n                if len(p)==12:\n                    p1=struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]\n\n                p=fp.read(12)\n                if len(p)==12:\n                    p2=struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]\n\n                p=fp.read(12)\n                if len(p)==12:\n                    p3=struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]\n\n                new_tri=(n,p1,p2,p3)\n\n                if len(new_tri)==4:\n                    tri=createtriangle(p1,p2,p3,n)\n                    self.model.append(tri)\n                count+=1\n                fp.read(2)\n\n                if len(p)==0:\n                    break\n            except EOFError:\n                break\n        fp.close()\n\n      \n\nclass draw_scene:\n    def __init__(self,style=1):\n        #create a model instance and\n        self.model1=loader()\n        #self.model1.load_stl(os.path.abspath(\'\')+\'/text.stl\')\n        self.model1.load_stl(os.path.abspath(\'\')+\'/cube.stl\')\n        self.init_shading()\n\n\n    #solid model with a light / shading\n    def init_shading(self):\n        glShadeModel(GL_SMOOTH)\n        glClearColor(0.0, 0.0, 0.0, 0.0)\n        glClearDepth(1.0)\n        glEnable(GL_DEPTH_TEST)\n        glShadeModel(GL_SMOOTH) \n        glDepthFunc(GL_LEQUAL)\n        glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)\n      \n        glEnable(GL_COLOR_MATERIAL)\n        glEnable(GL_LIGHTING)\n        glEnable(GL_LIGHT0)   \n        glLight(GL_LIGHT0, GL_POSITION,  (0, 1, 1, 0))      \n        glMatrixMode(GL_MODELVIEW)\n      \n    def resize(self, width, height):\n        if height==0:\n            height=1\n        glViewport(0, 0, width, height)\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        gluPerspective(45, 1.0*width/height, 0.1, 100.0)\n        #gluLookAt(0.0,0.0,45.0,0,0,0,0,40.0,0)\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n      \n\n    def init(self):\n        glShadeModel(GL_SMOOTH)\n        glClearColor(0.0, 0.0, 0.0, 0.0)\n        glClearDepth(1.0)\n        glEnable(GL_DEPTH_TEST)\n        glShadeModel(GL_SMOOTH) \n        glDepthFunc(GL_LEQUAL)\n        glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)\n\n      \n        glEnable(GL_COLOR_MATERIAL)\n      \n        glEnable(GL_LIGHTING)\n        glEnable(GL_LIGHT0)   \n        glLight(GL_LIGHT0, GL_POSITION,  (0, 1, 1, 0))\n\n        glMatrixMode(GL_MODELVIEW)\n\n    def draw(self):\n        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)\n        glLoadIdentity()\n      \n        glTranslatef(0.0,-26.0, -100.0)\n        self.model1.draw()\n\n#main program loop\ndef main():\n    #initalize pygame\n    pygame.init()\n    pygame.display.set_mode((640,480), OPENGL|DOUBLEBUF)\n\n    #setup the open gl scene\n    scene=draw_scene()\n    scene.resize(640,480)\n  \n    frames = 0\n    ticks = pygame.time.get_ticks()\n    while 1:\n        event = pygame.event.poll()\n        if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):\n            break\n      \n        #draw the scene\n        scene.draw()\n        pygame.display.flip()\n        frames = frames+1\n\n    print ("fps:  %d" % ((frames*1000)/(pygame.time.get_ticks()-ticks)))\n\n\nif __name__ == \'__main__\':\n    main() \n 使用 VPython \n #coding: utf-8\n# STL viewer 原始檔案來自\n# University of Wuppertal - http://mbi-wiki.uni-wuppertal.de/wordpress/\n# Modified by Uli Eggersmann\n# Binary STL 資料讀取原始作者 Oliver Marks - http://www.linux.com\n# 原始檔案僅讀取 Text STL 零件檔案\n# 2011 Fall 由 KMOL 新增 Binary STL 零件檔案讀取\n\nfrom visual import scene, color, materials, faces, points\nimport os, struct\n\n#file ="ritzel.stl"\n\nfile ="binary.stl"\n\nscene.width = 400\nscene.height = 400\nscene.background = color.white # black\n# 視窗標題取自 cvisual.pyd, 不可使用中文\nscene.title = "STLViewer in VPython"\n \nprint ("利用滑鼠右鍵旋轉")\nprint ("滑鼠左右鍵同時按下後移動, 可以縮放畫面")\n \n# Read STL file, only use vertex-line with xyz coordinates\nlist = []\n\n#load stl file detects if the file is a text file or binary file\ndef load_stl(filename):\n    #read start of file to determine if its a binay stl file or a ascii stl file\n    fp=open(filename,\'rb\')\n    header=fp.read(80)\n    filetype=header[0:5]\n    # 這裡必須要能夠分辨二位元字串與文字字串\n    #print (type(filetype))\n    #print (filetype)\n    fp.close()\n    \n    # for Python 3\n    if filetype==b\'solid\':\n    # for Python 2\n    #if filetype==\'solid\':\n        print ("讀取文字檔案格式:"+str(filename))\n        load_text_stl(filename)\n    else:\n        print ("讀取二位元檔案格式:"+str(filename,))\n        load_binary_stl(filename)\n\n#load binary stl file check wikipedia for the binary layout of the file\n#we use the struct library to read in and convert binary data into a format we can use\ndef load_binary_stl(filename):\n    \'\'\'\n    二位元 STL 檔案格式如下:\n    檔案標頭共有 80 個字元(bytes), 內容通常省略, 但是內容不可使用 solid, 以免與文字檔案 STL 混淆\n    UINT8[80] – Header\n    UINT32 – Number of triangles (I:佔 4 bytes 的 unsigned integer)\n\n    foreach triangle\n    REAL32[3] – Normal vector (f:每一座標分量為一佔 4 bytes 的 float, 共佔 12 bytes)\n    REAL32[3] – Vertex 1\n    REAL32[3] – Vertex 2\n    REAL32[3] – Vertex 3\n    UINT16 – Attribute byte count (H:兩個 bytes 的 unsigned short, 表示 attribute byte count)\n    end\n\n    \'\'\'\n    global list\n    \n    fp=open(filename,\'rb\')\n    header=fp.read(80)\n\n    triangle_number = struct.unpack(\'I\',fp.read(4))[0]\n    count=0\n    while True:\n        try:\n            p=fp.read(12)\n            if len(p)==12:\n                n=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n              \n            p=fp.read(12)\n            if len(p)==12:\n                p1=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                list.append(p1)\n            p=fp.read(12)\n            if len(p)==12:\n                p2=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                list.append(p2)\n            p=fp.read(12)\n            if len(p)==12:\n                p3=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                list.append(p3)\n            # 使用 count 來計算三角形平面個數\n            # triangle_number 為 STL 檔案中的三角形個數\n            count += 1\n            # 在前面 12*4 個 bytes 的 normal 與三個點資料後, 為\n            # 一個 2 bytes 長的 unsigned short, 其值為零, 為 attribute\n            fp.read(2)\n            # 讀完所有三角平面後, 即跳出 while\n            if count > triangle_number:\n                break\n        except EOFError:\n            break\n    fp.close()\n\n\ndef load_text_stl(filename):\n    global list\n    for dataline in open(filename,"r").readlines():\n        if not dataline.strip(): # skip blank lines\n            continue\n        field = dataline.split() # split with no argument makes the right place!\n        if field[0] == "vertex":\n            list.append([float(x) for x in field[1:4]])\n            #print (list)\n            #break\n            #for x in field[1:4]:\n                #print(x)\n\nload_stl(os.path.abspath(\'\')+\'/\'+file)\n\n\n# Graphics\nmodel = faces(pos=list, color=(0.8,0.8,0.8),\n              material=materials.plastic) # creates triangles\n# 請注意, 這裡並沒有使用 STL 檔案中的平面 normal, 而是利用 VPython make_normals() 產生\nmodel.make_normals() # creates plane normals\nmodel.smooth(0.93) # smooths the edges\n# = AllepunkteSTL points (pos = list, size = 3, color = Color.Black) # generates points  \n STL writer \n #coding:utf-8\n# source: http://code.activestate.com/recipes/578246-stl-writer/\n\nimport struct\n\nASCII_FACET = """facet normal 0 0 0\nouter loop\nvertex {face[0][0]:.4f} {face[0][1]:.4f} {face[0][2]:.4f}\nvertex {face[1][0]:.4f} {face[1][1]:.4f} {face[1][2]:.4f}\nvertex {face[2][0]:.4f} {face[2][1]:.4f} {face[2][2]:.4f}\nendloop\nendfacet\n"""\n\nBINARY_HEADER ="80sI"\nBINARY_FACET = "12fH"\n\nclass ASCII_STL_Writer:\n    """ Export 3D objects build of 3 or 4 vertices as ASCII STL file.\n    """\n    def __init__(self, stream):\n        self.fp = stream\n        self._write_header()\n\n    def _write_header(self):\n        self.fp.write("solid python\\n")\n\n    def close(self):\n        self.fp.write("endsolid python\\n")\n\n    def _write(self, face):\n        self.fp.write(ASCII_FACET.format(face=face))\n\n    def _split(self, face):\n        p1, p2, p3, p4 = face\n        return (p1, p2, p3), (p3, p4, p1)\n\n    def add_face(self, face):\n        """ Add one face with 3 or 4 vertices. """\n        if len(face) == 4:\n            face1, face2 = self._split(face)\n            self._write(face1)\n            self._write(face2)\n        elif len(face) == 3:\n            self._write(face)\n        else:\n            raise ValueError(\'only 3 or 4 vertices for each face\')\n\n    def add_faces(self, faces):\n        """ Add many faces. """\n        for face in faces:\n            self.add_face(face)\n\nclass Binary_STL_Writer(ASCII_STL_Writer):\n    """ Export 3D objects build of 3 or 4 vertices as binary STL file.\n    """\n    def __init__(self, stream):\n        self.counter = 0\n        super(Binary_STL_Writer, self).__init__(stream)\n\n    def close(self):\n        self._write_header()\n\n    def _write_header(self):\n        self.fp.seek(0)\n        self.fp.write(struct.pack(BINARY_HEADER, b\'Python Binary STL Writer\', self.counter))\n\n    def _write(self, face):\n        self.counter += 1\n        data = [\n            0., 0., 0.,\n            face[0][0], face[0][1], face[0][2],\n            face[1][0], face[1][1], face[1][2],\n            face[2][0], face[2][1], face[2][2],\n            0\n        ]\n        self.fp.write(struct.pack(BINARY_FACET, *data))\n\n\ndef example():\n    def get_cube():\n        # cube corner points\n        s = 3.\n        p1 = (0, 0, 0)\n        p2 = (0, 0, s)\n        p3 = (0, s, 0)\n        p4 = (0, s, s)\n        p5 = (s, 0, 0)\n        p6 = (s, 0, s)\n        p7 = (s, s, 0)\n        p8 = (s, s, s)\n\n        # define the 6 cube faces\n        # faces just lists of 3 or 4 vertices\n        return [\n            [p1, p5, p7, p3],\n            [p1, p5, p6, p2],\n            [p5, p7, p8, p6],\n            [p7, p8, p4, p3],\n            [p1, p3, p4, p2],\n            [p2, p6, p8, p4],\n        ]\n    \'\'\'\n    for writing ASCII STL cube file\n    with open(\'cube_ascii.stl\', \'w\') as fp:\n        writer = ASCII_STL_Writer(fp)\n        writer.add_faces(get_cube())\n        writer.close()\n    \'\'\'\n    with open(\'cube_bin.stl\', \'wb\') as fp:\n        writer = Binary_STL_Writer(fp)\n        writer.add_faces(get_cube())\n        writer.close()\n\nif __name__ == \'__main__\':\n    example() \n \n', 'tags': '', 'url': '輔助設計套件.html'}, {'title': 'NURB-Python', 'text': 'https://github.com/orbingol/NURBS-Python   \n https://github.com/orbingol/NURBS-Python_Examples   \n', 'tags': '', 'url': 'NURB-Python.html'}, {'title': 'libfive', 'text': 'https://github.com/libfive/libfive   \n', 'tags': '', 'url': 'libfive.html'}, {'title': 'robovision', 'text': 'https://github.com/stoic1979/robovision \n', 'tags': '', 'url': 'robovision.html'}, {'title': 'jsketcher', 'text': 'https://github.com/xibyte/jsketcher \n', 'tags': '', 'url': 'jsketcher.html'}, {'title': 'kmolcad', 'text': 'from PyQt5 import QtWidgets, uic\nfrom PyQt5.QtWidgets import QTableWidgetItem\nfrom PyQt5.QtGui import QPen, QColor, QImage, QPixmap, QPainter\nfrom PyQt5.QtCore import Qt, QTime, QCoreApplication, QEventLoop, QPoint\nimport time\n\ncol_one = Qt.black\ncol_zero = Qt.white\n\n\nclass Window(QtWidgets.QMainWindow):\n    def __init__(self):\n        QtWidgets.QWidget.__init__(self)\n        uic.loadUi("window.ui", self)\n        self.scene = myScene(0, 0, 561, 581)\n        self.scene.win = self\n        self.view.setScene(self.scene)\n        self.image = QImage(561, 581, QImage.Format_ARGB32_Premultiplied)\n        self.image.fill(col_zero)\n        self.lock.clicked.connect(lambda: lock(self))\n        self.erase.clicked.connect(lambda: clean_all(self))\n        self.paint.clicked.connect(lambda: fill_xor(self))\n        self.addpoint.clicked.connect(lambda: add_point_by_btn(self))\n        self.edges = []\n        self.point_now = None\n        self.point_lock = None\n        self.pen = QPen(col_one)\n        self.delay.setChecked(False)\n\n\nclass myScene(QtWidgets.QGraphicsScene):\n    def mousePressEvent(self, event):\n        add_point(event.scenePos())\n\n\ndef add_row(win):\n    win.table.insertRow(win.table.rowCount())\n\n\ndef add_point(point):\n    global w\n    if w.point_now is None:\n        w.point_now = point\n        w.point_lock = point\n        add_row(w)\n        i = w.table.rowCount() - 1\n        item_x = QTableWidgetItem("{0}".format(point.x()))\n        item_y = QTableWidgetItem("{0}".format(point.y()))\n        w.table.setItem(i, 0, item_x)\n        w.table.setItem(i, 1, item_y)\n    else:\n        w.edges.append([w.point_now.x(), w.point_now.y(),\n                        point.x(), point.y()])\n        w.point_now = point\n        add_row(w)\n        i = w.table.rowCount() - 1\n        item_x = QTableWidgetItem("{0}".format(point.x()))\n        item_y = QTableWidgetItem("{0}".format(point.y()))\n        w.table.setItem(i, 0, item_x)\n        w.table.setItem(i, 1, item_y)\n        item_x = w.table.item(i-1, 0)\n        item_y = w.table.item(i-1, 1)\n        w.scene.addLine(point.x(), point.y(), float(item_x.text()), float(item_y.text()), w.pen)\n    #print(w.edges)\n\n\ndef lock(win):\n    win.edges.append([win.point_now.x(), win.point_now.y(), win.point_lock.x(), win.point_lock.y()])\n    win.scene.addLine(win.point_now.x(), win.point_now.y(), win.point_lock.x(), win.point_lock.y(), w.pen)\n    win.point_now = None\n    #print(win.edges)\n\n\ndef clean_all(win):\n    win.scene.clear()\n    win.table.clear()\n    win.edges = []\n    win.point_now = None\n    win.point_lock = None\n    win.image.fill(col_zero)\n    r = win.table.rowCount()\n    for i in range(r, -1, -1):\n        win.table.removeRow(i)\n\n\ndef draw_edges(image, edges):\n    p = QPainter()\n    p.begin(image)\n    p.setPen(QPen(col_one))\n    for ed in edges:\n        p.drawLine(ed[0], ed[1], ed[2], ed[3])\n    p.end()\n\n\ndef delay():\n    #QCoreApplication.processEvents(QEventLoop.AllEvents, 1)\n    QtWidgets.QApplication.processEvents(QEventLoop.AllEvents, 1)\n    #time.sleep(.005)\n\n    """t = QTime.currentTime().addMSecs(1)\n    while QTime.currentTime() < t:\n        QCoreApplication.processEvents(QEventLoop.AllEvents, 1)"""\n\n\ndef find_max_y(ed):\n    x_max = None\n    for i in range(len(ed)):\n        if x_max is None or ed[i][0] > x_max:\n            x_max = ed[i][0]\n\n        if x_max is None or ed[i][2] > x_max:\n            x_max = ed[i][2]\n\n    return x_max\n\n\ndef fill_xor(win):\n    pix = QPixmap()\n    p = QPainter()\n\n\n    xm = int(find_max_y(win.edges))\n    for ed in win.edges:\n        p.begin(win.image)\n        # if the horizontal edge is farther\n        if ed[1] == ed[3]:\n            continue\n        # otherwise we define scanning boundaries\n        if ed[1] > ed[3]:\n            ed[1], ed[3] = ed[3], ed[1]\n\n            ed[0], ed[2] = ed[2], ed[0]\n            \n\n        y = ed[1]\n        end_y = ed[3]\n        dx = (ed[2] - ed[0]) / (ed[3] - ed[1])\n        start_x = ed[0]\n\n        while y < end_y:\n            # determine the intersection\n\n            x = start_x\n            while x < xm:\n                col = QColor(win.image.pixel(x, y))\n                if col == col_zero:\n                    p.setPen(QPen(col_one))\n                else:\n                    p.setPen(QPen(col_zero))\n                p.drawPoint(x, y)\n                x += 1\n\n            start_x += dx\n            y += 1\n\n            if win.delay.isChecked():\n                delay()\n                pix.convertFromImage(win.image)\n                win.scene.addPixmap(pix)\n\n        if not win.delay.isChecked():\n            pix.convertFromImage(win.image)\n            win.scene.addPixmap(pix)\n        p.end()\n    draw_edges(win.image, win.edges)\n\ndef add_point_by_btn(win):\n    x = win.x.value()\n    y = win.y.value()\n    p = QPoint()\n    p.setX(x)\n    p.setY(y)\n    add_point(p)\n\nif __name__ == "__main__":\n    import sys\n    app = QtWidgets.QApplication(sys.argv)\n    w = Window()\n    w.show()\n    sys.exit(app.exec_()) \n window.ui \n <?xml version="1.0" encoding="UTF-8"?>\n<ui version="4.0">\n <class>MainWindow</class>\n <widget class="QMainWindow" name="MainWindow">\n  <property name="geometry">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>809</width>\n    <height>605</height>\n   </rect>\n  </property>\n  <property name="windowTitle">\n   <string>Filling areasstring</string>\n  </property>\n  <widget class="QWidget" name="centralwidget">\n   <widget class="QGraphicsView" name="view">\n    <property name="geometry">\n     <rect>\n      <x>10</x>\n      <y>10</y>\n      <width>561</width>\n      <height>581</height>\n     </rect>\n    </property>\n   </widget>\n   <widget class="QTableWidget" name="table">\n    <property name="geometry">\n     <rect>\n      <x>590</x>\n      <y>10</y>\n      <width>211</width>\n      <height>241</height>\n     </rect>\n    </property>\n    <column>\n     <property name="text">\n      <string>X</string>\n     </property>\n    </column>\n    <column>\n     <property name="text">\n      <string>Y</string>\n     </property>\n    </column>\n   </widget>\n   <widget class="QPushButton" name="paint">\n    <property name="geometry">\n     <rect>\n      <x>620</x>\n      <y>560</y>\n      <width>113</width>\n      <height>32</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>Colorize</string>\n    </property>\n   </widget>\n   <widget class="QPushButton" name="lock">\n    <property name="geometry">\n     <rect>\n      <x>620</x>\n      <y>500</y>\n      <width>113</width>\n      <height>32</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>Close</string>\n    </property>\n   </widget>\n   <widget class="QPushButton" name="erase">\n    <property name="geometry">\n     <rect>\n      <x>620</x>\n      <y>530</y>\n      <width>113</width>\n      <height>32</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>Clear</string>\n    </property>\n   </widget>\n   <widget class="QCheckBox" name="delay">\n    <property name="geometry">\n     <rect>\n      <x>620</x>\n      <y>480</y>\n      <width>141</width>\n      <height>20</height>\n     </rect>\n    </property>\n    <property name="font">\n     <font>\n      <pointsize>13</pointsize>\n     </font>\n    </property>\n    <property name="text">\n     <string>With a delay</string>\n    </property>\n   </widget>\n   <widget class="QPushButton" name="addpoint">\n    <property name="geometry">\n     <rect>\n      <x>600</x>\n      <y>410</y>\n      <width>141</width>\n      <height>32</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>Add Point</string>\n    </property>\n   </widget>\n   <widget class="QSpinBox" name="x">\n    <property name="geometry">\n     <rect>\n      <x>620</x>\n      <y>440</y>\n      <width>48</width>\n      <height>24</height>\n     </rect>\n    </property>\n    <property name="minimum">\n     <number>1</number>\n    </property>\n    <property name="maximum">\n     <number>561</number>\n    </property>\n   </widget>\n   <widget class="QSpinBox" name="y">\n    <property name="geometry">\n     <rect>\n      <x>700</x>\n      <y>440</y>\n      <width>48</width>\n      <height>24</height>\n     </rect>\n    </property>\n    <property name="minimum">\n     <number>1</number>\n    </property>\n    <property name="maximum">\n     <number>581</number>\n    </property>\n   </widget>\n   <widget class="QLabel" name="label">\n    <property name="geometry">\n     <rect>\n      <x>600</x>\n      <y>440</y>\n      <width>16</width>\n      <height>16</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>X</string>\n    </property>\n   </widget>\n   <widget class="QLabel" name="label_2">\n    <property name="geometry">\n     <rect>\n      <x>680</x>\n      <y>440</y>\n      <width>16</width>\n      <height>16</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>Y</string>\n    </property>\n   </widget>\n   <widget class="QSpinBox" name="p_y">\n    <property name="geometry">\n     <rect>\n      <x>700</x>\n      <y>370</y>\n      <width>48</width>\n      <height>24</height>\n     </rect>\n    </property>\n    <property name="minimum">\n     <number>1</number>\n    </property>\n    <property name="maximum">\n     <number>581</number>\n    </property>\n   </widget>\n   <widget class="QLabel" name="label_3">\n    <property name="geometry">\n     <rect>\n      <x>600</x>\n      <y>370</y>\n      <width>16</width>\n      <height>16</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>X</string>\n    </property>\n   </widget>\n   <widget class="QPushButton" name="pixel">\n    <property name="geometry">\n     <rect>\n      <x>580</x>\n      <y>330</y>\n      <width>211</width>\n      <height>32</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>Enter the seed pixel</string>\n    </property>\n   </widget>\n   <widget class="QSpinBox" name="p_x">\n    <property name="geometry">\n     <rect>\n      <x>620</x>\n      <y>370</y>\n      <width>48</width>\n      <height>24</height>\n     </rect>\n    </property>\n    <property name="minimum">\n     <number>1</number>\n    </property>\n    <property name="maximum">\n     <number>561</number>\n    </property>\n   </widget>\n   <widget class="QLabel" name="label_4">\n    <property name="geometry">\n     <rect>\n      <x>680</x>\n      <y>370</y>\n      <width>16</width>\n      <height>16</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>Y</string>\n    </property>\n   </widget>\n   <widget class="QLabel" name="label_5">\n    <property name="geometry">\n     <rect>\n      <x>640</x>\n      <y>300</y>\n      <width>71</width>\n      <height>20</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>Radius</string>\n    </property>\n   </widget>\n   <widget class="QPushButton" name="addcircle">\n    <property name="geometry">\n     <rect>\n      <x>580</x>\n      <y>270</y>\n      <width>211</width>\n      <height>32</height>\n     </rect>\n    </property>\n    <property name="text">\n     <string>Add circle</string>\n    </property>\n   </widget>\n   <widget class="QSpinBox" name="rad">\n    <property name="geometry">\n     <rect>\n      <x>700</x>\n      <y>300</y>\n      <width>48</width>\n      <height>24</height>\n     </rect>\n    </property>\n    <property name="minimum">\n     <number>1</number>\n    </property>\n    <property name="maximum">\n     <number>561</number>\n    </property>\n    <property name="value">\n     <number>160</number>\n    </property>\n   </widget>\n  </widget>\n </widget>\n <resources/>\n <connections/>\n</ui> \n 參考資料 \n https://github.com/Panda-Lewandowski/Computer-graphics   \n https://github.com/chiamingyen/PythonCAD_py3   \n', 'tags': '', 'url': 'kmolcad.html'}, {'title': '分組專題', 'text': '分組專題報告 \n 章節 \n \n 標題頁 - 含報告標題、作者、日期與所屬單位 \n 目錄 - 列出全文章節與所屬頁面連結 \n 摘要 - 解釋報告編寫動機、報告重點、結論、建議與關鍵字 \n 前言 - 簡要描述全文意旨與背景, 說明報告目標與報告內容組成架構 \n 內文 - 依照章節標題, 詳細說明報告內容, 包括方法、操作步驟與所得結果的詳細說明 \n 結論 - 條列所獲致的重要成果, 與摘要及導言中的目標互相呼應 \n 討論與建議 - 說明後續值得進行的方向、方法與可能遭遇問題的討論 \n 參考 - 詳列所引用的參考內容 \n 附錄 - 附加值得參考的詳細內容 \n \n', 'tags': '', 'url': '分組專題.html'}, {'title': '分組題目', 'text': "https://github.com/mdecourse/wcms-scrum1   \n 單機工程用計算機設計 \n 網際工程用計算機設計 \n 正齒輪嚙合傳動齒面寬設計 \n 網際 PMKS (Planar Mechanism Kinematic Simulator):  https://designengrlab.github.io/PMKS/   \n https://design.engr.oregonstate.edu/matthew-campbell-phd-dissertation   or  The A-Design Invention Machine.pdf \n Automated Synthesis of Planar Mechanisms with Revolute, Prismatic and Pin-In-Slot Joints.pdf  (or  local ) \n Gruebler’s Equation \n Degrees of freedom for planar linkages joined with common joints can be calculated through Gruebler’s equation. \n Gruebler’s equation is given by the formula: Gruebler's equation formula for calculating degrees of freedom \n dof = 3(n-1)-2jp-jh \n where, n = total number of links in the mechanism jp = total number of primary joints (pins or sliding joints) jh = total number of higher-order joints (cam or gear joints) \n Exception to Gruebler’s Equation: \n The Gruebler’s equation does not account for link geometry, in rare instances, it can lead to misleading results. \n Notice that the linkage contains five links and six pin joints. Using Gruebler’s equation, this linkage has zero degrees of freedom. Of course, this suggests that the mechanism is locked. However, if all pivoted links were the same size and the distance between the joints on the frame and coupler were identical, this mechanism is capable of motion, with a single degree of freedom. The center link is redundant and because it is identical in length to the other two links attached to the frame, it does not alter the action of the linkage. \n There are other examples of mechanisms that violate the Gruebler’s equation because of unique geometry. A designer must be aware that the mobility equation can, at times, lead to inconsistencies. \n A graph consists of a set of vertices (points) together with a set of edges or lines. The set of vertices is connected by the set of edges. Let the graph be denoted by the symbol G, the vertex by set V , and the edge by set E. We call a graph with v vertices and e edges a (v, e) graph. Edges and vertices in a graph should be labeled or colored, otherwise they are indistinguishable. Each edge of a graph connects two vertices called the end points. We specify an edge by its end points; that is, eij denotes the edge connecting vertices i and j . An edge is said to be incident with a vertex, if the vertex is an end point of that edge. The two end points of an edge are said to be adjacent. Two edges are adjacent if they are incident to a common vertex. \n", 'tags': '', 'url': '分組題目.html'}, {'title': '符號式推導', 'text': '使用 Python 的符號式推導前, 需要先安裝  sympy  模組: \n python -m pip install sympy \n 參考資料:  https://github.com/mdecourse/2017springcd/tree/gh-pages/data   \n PLAP - 已知三角形 abc,   P oint a 座標,  L ength of a to C, and  A ngle of ac link relative to ab, and  P oint b 座標. \n 求 c 點座標, 表示為已知輸入變數的方程式. \n \n #PLAP\nfrom sympy import symbols, sqrt, solve, cos, sin, Abs\n\n# inputs\nax, ay, bx, by, bac, ac = symbols(\'ax ay bx by bac ac\')\n# intermediate variables\nab, dab = symbols(\'ab dab\')\nad, bd = symbols(\'ad bd\')\n# outputs\ncx, cy = symbols(\'cx cy\')\n# 從 a, b 點座標求 ab, ad 與 bd\nab = sqrt((ax-bx)**2+(ay-by)**2)\nad = Abs(bx-ax)\nbd = Abs(by-ay)\ndata = solve(-bd**2+ad**2+ab**2-2*ad*ab*cos(dab), dab)\n# 第1組解\ndab = data[0]\ncx = ax+ac*cos(dab+bac)\ncy = ay+ac*sin(dab+bac)\nprint("cx=", cx, "cy=", cy)\n# 第二組解\ndab = data[1]\ncx = ax+ac*cos(dab+bac)\ncy = ay+ac*sin(dab+bac)\nprint("cx=", cx, "cy=", cy) \n PLLP - 已知三角形 abc,  順時鐘方向 Point a 座標,  Length of ac 與 Length of cb, 以及 Point b 座標. \n 求 c 點座標, 表示為已知輸入變數的方程式. \n #PLLP\nfrom sympy import symbols, sqrt, solve, cos, sin, Abs\n\n# inputs\nax, ay, bx, by, ac, cb = symbols(\'ax ay bx by ac cb\')\n# intermediate variables\nab, dab, bac, degree= symbols(\'ab dab bac degree\')\nad, bd = symbols(\'ad bd\')\n# outputs\ncx, cy = symbols(\'cx cy\')\n# 從 a, b 點座標求 ab, ad 與 bd\n\nab = sqrt((ax-bx)**2+(ay-by)**2)\n\'\'\'\nac = sqrt((ax-cx)**2+(ay-cy)**2)\ncb = sqrt((cx-bx)**2+(cy-by)**2)\n#ac = sqrt((ax-cx)**2+(ay-cy)**2)\n\'\'\'\n# 從兩組解中擇一\ndata = solve([ac**2-((ax-cx)**2+(ay-cy)**2), cb**2-((cx-bx)**2+(cy-by)**2)], [cx, cy])\n# 第1組解\nprint("cx = ", data[0][0])\nprint("cy = ", data[1][0])\n# 第2組解\nprint("cx = ", data[0][1])\nprint("cy = ", data[1][1])\n \n PLPP - 已知 Point b 座標, Length of be, Point c 座標與 Point d 座標. \n 求 e 點座標, 表示為已知輸入變數的方程式. \n \n #PLPP\nfrom sympy import symbols, sqrt, solve\n\n# inputs\nbx, by, be, cx, cy, dx, dy = symbols(\'bx by be cx cy dx dy\')\n# intermediate variables\ncd, m= symbols(\'cd m\')\n# outputs\nex, ey = symbols(\'ex ey\')\n# e on line cd\ncd = sqrt((cx-dx)**2+(cy-dy)**2)\nm = (dx-cx)/(dy-cy)\ndata = solve([be-sqrt((bx-ex)**2+(by-ey)**2), ex-cx-m*(ey-cy)] ,  [ex, ey])\nprint(data)\n\'\'\'\n[(((cx - dx)*(bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (-cy + dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2)) - (cx*dy - cy*dx)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2))/((cy - dy)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2)), (bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (-cy + dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2))/(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2)), (((cx - dx)*(bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (cy - dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2)) - (cx*dy - cy*dx)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2))/((cy - dy)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2)), (bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (cy - dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2))/(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2))]\n\'\'\'\n\n\n \n', 'tags': '', 'url': '符號式推導.html'}, {'title': 'CMSimfly 解析', 'text': 'CMSimfly 源起 \n CMSimfly 的設計概念源自  https://www.cmsimple.org/en/ , CMSimple 不需要使用資料庫,所有的頁面資料都以一個超文件檔案格式, 名稱為content.htm, 存於全球資訊網伺服器上.純文字檔的資料設計使得安裝與備份工作相對較為簡單. \n CMSimple主要的程式功能分為頁面展示與後台管理. 其頁面展示功能是利用超文件中的 <h1></h1>, <h2></h2>, 與 <h3></h3> 標註（可後續延伸至 <h4></h4>等）, 進行分頁. CMSimple程式會將 content.htm 中的 <h1></h1> 當作第一層頁面的標題, 緊跟其後之 <h2></h2> 則將被視為第二層頁面的標題, 而 <h3></h3> 所涵蓋的內容則為第三層頁面的標題. 各層標題則依照其位於content.htm文件中的順序而定. 由於CMSimple利用 <h1></h1>, <h2></h2>，與<h3></h3> 標註進行分頁，因此其文件內容無法出現標題標註（header）所對應的粗體文字. 使用者必須透過其他方式產生類似粗體文字的效果. \n CMSimple的後台管理, 僅允許單一用戶使用. 透過後台管理, 可設定各種與頁面展示相關的參數. 與許多內容管理系統相同, CMSimple提供延伸程式開發架構的設計, 可以讓程式開發者自行建構原始CMSimple以外的功能. \n KMOL  將 CMSimple 轉為 Python 程式時, 採用  Cherrypy  網際框架. 稱為  https://github.com/chiamingyen/cmsimply  , 之後的版本改用 Flask 網際框架, 名稱改為  https://github.com/chiamingyen/cmsimfly   \n CMSimfly 架構 \n CMSimfly 網際內容管理系統, 以位於 config 目錄中的 content.htm 檔案的解析為主, 一旦取得各頁面的標題、階次與內容時, 就可以列出各頁對應的內容. \n config/content.htm 的解讀, 以  Python 的 Beautiful Soup 模組達成, 主要先取得 content.htm 檔案中的各 <h1> <h2> 與 <h3> 標註的內容後, 轉為數列, 然後利用各頁面標題作為切割各頁內容的依據, 以便取得各頁面的標題、階次與內容, 標題階次主要用來建立多層次表單以及 site map. \n 由於切割頁面的依據為 <h1> 至 <h3> 的標題, 且頁面連結與編輯均依賴頁面標題, 因此各頁面標題不可重複, 否則連結與編輯時, 將會在畫面出現多個資料與編輯區. 要改進此一缺點, 可以將 content.htm 的資料存入資料庫, 並以獨立序號來辨識各頁面標題、階次與內容. \n CMSimfly 中採 bs4 與 re 所建立的 parse_content 方法, 提供重複標題頁面處理: \n def parse_content():\n    """use bs4 and re module functions to parse content.htm"""\n    #from pybean import Store, SQLiteWriter\n    # if no content.db, create database file with cms table\n    \'\'\'\n    if not os.path.isfile(config_dir+"content.db"):\n        library = Store(SQLiteWriter(config_dir+"content.db", frozen=False))\n        cms = library.new("cms")\n        cms.follow = 0\n        cms.title = "head 1"\n        cms.content = "content 1"\n        cms.memo = "first memo"\n        library.save(cms)\n        library.commit()\n    \'\'\'\n    # if no content.htm, generate a head 1 and content 1 file\n    if not os.path.isfile(config_dir+"content.htm"):\n        # create content.htm if there is no content.htm\n        File = open(config_dir + "content.htm", "w", encoding="utf-8")\n        File.write("<h1>head 1</h1>content 1")\n        File.close()\n    subject = file_get_contents(config_dir+"content.htm")\n    # deal with content without content\n    if subject == "":\n        # create content.htm if there is no content.htm\n        File = open(config_dir + "content.htm", "w", encoding="utf-8")\n        File.write("<h1>head 1</h1>content 1")\n        File.close()\n        subject = "<h1>head 1</h1>content 1"\n    # initialize the return lists\n    head_list = []\n    level_list = []\n    page_list = []\n    # make the soup out of the html content\n    soup = BeautifulSoup(subject, \'html.parser\')\n    # get all h1, h2, h3 tags into list\n    htag= soup.find_all([\'h1\', \'h2\', \'h3\'])\n    n = len(htag)\n    # get all h tags\n    # g.es(soup.find_all(re.compile(r"^h\\d$")))\n    # get the page content to split subject using each h tag\n    # i = 0\n    temp_data = subject.split(str(htag[0]))\n    if len(temp_data) > 2:\n        subject = str(htag[0]).join(temp_data[1:])\n    else:\n        subject = temp_data[1]\n    if n >1:\n            # i from 1 to i-1\n            for i in range(1, len(htag)):\n                # add the first page title\n                head_list.append(htag[i-1].text.strip())\n                # use name attribute of h* tag to get h1, h2 or h3\n                # the number of h1, h2 or h3 is the level of page menu\n                level_list.append(htag[i-1].name[1])\n                temp_data = subject.split(str(htag[i]))\n                if len(temp_data) > 2:\n                    subject = str(htag[i]).join(temp_data[1:])\n                else:\n                    subject = temp_data[1]\n                # cut the other page content out of htag from 1 to i-1\n                cut = temp_data[0]\n                # add the page content\n                page_list.append(cut)\n    # last i\n    # add the last page title\n    head_list.append(htag[n-1].text.strip())\n    # add the last level\n    level_list.append(htag[n-1].name[1])\n    temp_data = subject.split(str(htag[n-1]))\n    # the last subject\n    subject = temp_data[0]\n    # cut the last page content out\n    cut = temp_data[0]\n    # the last page content\n    page_list.append(cut)\n    return head_list, level_list, page_list\n \n get_page2 則提供從動態網頁內容, 轉為靜態網頁檔案. \n # seperate page need heading and edit variables, if edit=1, system will enter edit mode\n# single page edit will use ssavePage to save content, it means seperate save page\n\'\'\'\n@app.route(\'/get_page2\')\n@app.route(\'/get_page2/<heading>\', defaults={\'edit\': 0})\n@app.route(\'/get_page2/<heading>/<int:edit>\')\n\'\'\'\ndef get_page2(heading, head, edit):\n    not_used_head, level, page = parse_content()\n    # 直接在此將 ./../images/ 換為 ./.../../images/, ./../downloads/ 換為 ./.../../downloads/, 以 content 為基準的相對目錄設定\n    page = [w.replace(\'./../images/\', \'./.../../images/\') for w in page]\n    page = [w.replace(\'./../downloads/\', \'./.../../downloads/\') for w in page]\n    directory = render_menu2(head, level, page)\n    if heading is None:\n        heading = head[0]\n    # 因為同一 heading 可能有多頁, 因此不可使用 head.index(heading) 搜尋 page_order\n    page_order_list, page_content_list = search_content(head, page, heading)\n    return_content = ""\n    pagedata = ""\n    outstring = ""\n    outstring_duplicate = ""\n    pagedata_duplicate = ""\n    outstring_list = []\n    for i in range(len(page_order_list)):\n        #page_order = head.index(heading)\n        page_order = page_order_list[i]\n        if page_order == 0:\n            last_page = ""\n        else:\n            #last_page = head[page_order-1]+" << <a href=\'/get_page/"+head[page_order-1]+"\'>Previous</a>"\n            last_page = head[page_order-1] + " << <a href=\'"+head[page_order-1] + ".html\'>Previous</a>"\n        if page_order == len(head) - 1:\n            # no next page\n            next_page = ""\n        else:\n            #next_page = "<a href=\'/get_page/"+head[page_order+1]+"\'>Next</a> >> "+ head[page_order+1]\n            next_page = "<a href=\'" + head[page_order+1] + ".html\'>Next</a> >> " + head[page_order+1]\n        if len(page_order_list) > 1:\n            return_content += last_page + " " + next_page + "<br /><h1>" + \\\n                                      heading + "</h1>" + page_content_list[i] + \\\n                                      "<br />" + last_page + " "+ next_page + "<br /><hr>"\n            pagedata_duplicate = "<h"+level[page_order] + ">" + heading + "</h" + level[page_order]+">"+page_content_list[i]\n            outstring_list.append(last_page + " " + next_page + "<br />" + tinymce_editor(directory, cgi.escape(pagedata_duplicate), page_order))\n        else:\n            return_content += last_page + " " + next_page + "<br /><h1>" + \\\n                                      heading + "</h1>" + page_content_list[i] + \\\n                                      "<br />" + last_page + " " + next_page\n            \n        pagedata += "<h" + level[page_order] + ">" + heading + \\\n                          "</h" + level[page_order] + ">" + page_content_list[i]\n        # 利用 cgi.escape() 將 specialchar 轉成只能顯示的格式\n        outstring += last_page + " " + next_page + "<br />" + tinymce_editor(directory, cgi.escape(pagedata), page_order)\n    \n    # edit=0 for viewpage\n    if edit == 0:\n        return set_css2() + "<div class=\'container\'><nav>"+ \\\n        directory + "</nav><section>" + return_content + "</section></div></body></html>"\n    # enter edit mode\n    else:\n        # check if administrator\n        if not isAdmin():\n            redirect(url_for(\'login\'))\n        else:\n            if len(page_order_list) > 1:\n                # 若碰到重複頁面頁印, 且要求編輯, 則導向 edit_page\n                #return redirect("/edit_page")\n                for i in range(len(page_order_list)):\n                    outstring_duplicate += outstring_list[i] + "<br /><hr>"\n                return outstring_duplicate\n            else:\n            #pagedata = "<h"+level[page_order]+">"+heading+"</h"+level[page_order]+">"+search_content(head, page, heading)\n            #outstring = last_page+" "+next_page+"<br />"+ tinymce_editor(directory, cgi.escape(pagedata), page_order)\n                return outstring\n \n generate_pages 方法提供將帶有重複標題頁面轉為不同標題名的靜態網頁檔案 \n @app.route(\'/generate_pages\')\ndef generate_pages():\n    # 必須決定如何處理重複標題頁面的轉檔\n    import os\n    # 確定程式檔案所在目錄, 在 Windows 有最後的反斜線\n    _curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))\n    # 根據 content.htm 內容, 逐一產生各頁面檔案\n    # 在此也要同時配合 render_menu2, 產生對應的 anchor 連結\n    head, level, page = parse_content()\n    # 處理重複標題 head 數列， 再重複標題按照次序加上 1, 2, 3...\n    newhead = []\n    for i, v in enumerate(head):\n        # 各重複標題總數\n        totalcount = head.count(v)\n        # 目前重複標題出現總數\n        count = head[:i].count(v)\n        # 針對重複標題者, 附加目前重複標題出現數 +1, 未重複採原標題\n        newhead.append(v + str(count + 1) if totalcount > 1 else v)\n    # 刪除 content 目錄中所有 html 檔案\n    filelist = [ f for f in os.listdir(_curdir + "\\\\content\\\\") if f.endswith(".html") ]\n    for f in filelist:\n        os.remove(os.path.join(_curdir + "\\\\content\\\\", f))\n    # 這裡需要建立專門寫出 html 的 write_page\n    # index.html\n    file = open(_curdir + "\\\\content\\\\index.html", "w", encoding="utf-8")\n    file.write(get_page2(None, newhead, 0))\n    file.close()\n    # sitemap\n    file = open(_curdir + "\\\\content\\\\sitemap.html", "w", encoding="utf-8")\n    # sitemap2 需要 newhead\n    file.write(sitemap2(newhead))\n    file.close()\n    # 以下轉檔, 改用 newhead 數列\n    for i in range(len(newhead)):\n        # 在此必須要將頁面中的 ./../images/ 字串換為 images/, ./../downloads/ 換為 downloads/\n        # 因為 Flask 中靠 ./../images/ 取檔案, 但是一般 html 則採相對目錄取檔案\n        # 此一字串置換在 get_page2 中進行\n        file = open(_curdir + "\\\\content\\\\" + newhead[i] + ".html", "w", encoding="utf-8")\n        # 增加以 newhead 作為輸入\n        file.write(get_page2(newhead[i], newhead, 0))\n        file.close()\n    # generate each page html under content directory\n    return "已經將網站轉為靜態網頁. <a href=\'/\'>Home</a>"\n \n \n', 'tags': '', 'url': 'CMSimfly 解析.html'}, {'title': 'CMSimfly 開發', 'text': '以下為可行的開發項目: \n \n 採用 SQLite 資料庫儲存內容資料, 以允許重複頁面標題. \n 在靜態內容管理系統中, 納入  Tipue Search  功能. \n 目前採用 html editor, 若能改為  Markdown editor , 然後再 轉為  html, 應該有助於協同. \n 能否導入  together.js , 進行線上協同編輯? \n \n 近端啟動 \n 在可攜 Python 程式環境, 只需 Flask 與 Beautiful Soup 模組, 即可以 python wsgi.py 啟動 CMSimfly \n 由於 CMSimfly 的除了 Flask 動態網頁系統外, 還提供位於 content 目錄中的靜態網頁. 當在動態網頁模式下, 按下管理者功能表中的 generate_pages 就可以將 config/content.htm 中的各頁面內容, 以各頁面分割的方式存入 content 目錄中. \n 由於 config/content.htm 並無針對各頁面的內容更動進行查驗, 因此目前轉為靜態網頁的方式為每次均需全部刪除 content 目錄中的所有檔案後, 再逐一重新建立, 因此只有在將靜態網頁改版並送往遠端網站時, 才進行靜態轉檔. \n 遠端啟動 \n 以 Ubuntu 配置 nginx 與 uwsgi 伺服環境為例. \n 安裝並配置 Python3 的網際程式伺服環境. \n sudo apt install python3-pip \n sudo pip3 install Flask \n sudo apt install build-essential python3-dev \n sudo pip3 install uwsgi \n sudo apt install nginx uwsgi-plugin-python3 \n /etc/nginx/sites-availables/default 設定檔: \n server {\n    listen 80 default_server;\n    #listen [::]:80 default_server ipv6only=on;\n \n    listen 443 ssl;\n    #listen [::]:443 ssl ipv6only=on;\n \n    location /static {\n        alias /home/cadlab/cmsimfly/static/;\n    }\n \n    location / {\n        include uwsgi_params;\n        uwsgi_pass  127.0.0.1:8080;\n    }\n \n    server_name localhost;\n    #ssl on;\n    ssl_certificate /etc/nginx/ssl/nginx.crt;\n    ssl_certificate_key /etc/nginx/ssl/nginx.key;\n    ssl_session_timeout 5m;\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";\n    ssl_prefer_server_ciphers on;\n    try_files $uri $uri/ =404;\n}\n \nserver {\n    listen 88 default_server;\n    #listen [::]:88 default_server ipv6only=on;\n \n    listen 8443 ssl;\n    #listen [::]:8443 ssl ipv6only=on;\n \n    location /static {\n        alias /home/cadlab/cmsimfly2/static/;\n    }\n \n    location / {\n        include uwsgi_params;\n        uwsgi_pass  127.0.0.1:8081;\n    }\n \n    server_name localhost;\n    #ssl on;\n    ssl_certificate /etc/nginx/ssl/nginx.crt;\n    ssl_certificate_key /etc/nginx/ssl/nginx.key;\n    ssl_session_timeout 5m;\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";\n    ssl_prefer_server_ciphers on;\n    try_files $uri $uri/ =404;\n} \n 利用 /etc/rc.local 開機時啟動所有 uwsgi 程式: \n exec uwsgi_python35 --uid cadlab --gid cadlab --emperor /home/cadlab/uwsgi_ini \n /home/cadlab/uwsgi_ini/uwsgi.ini 設定檔案內容: \n [uwsgi]\nsocket = 127.0.0.1:8080\nplugins-dir = /usr/lib/uwsgi/plugins/\nplugin = python3\nprocesses = 4\nthreads = 2\nchdir = /home/cadlab/cmsimfly\nwsgi-file = /home/cadlab/cmsimfly/wsgi.py \n /home/cadlab/uwsgi_ini/uwsgi2.ini 設定檔案內容: \n [uwsgi]\nsocket = 127.0.0.1:8081\nplugins-dir = /usr/lib/uwsgi/plugins/\nplugin = python3\nprocesses = 4\nthreads = 2\nchdir = /home/cadlab/cmsimfly2\nwsgi-file = /home/cadlab/cmsimfly2/wsgi.py \n \n', 'tags': '', 'url': 'CMSimfly 開發.html'}, {'title': 'Pygrouf 解析', 'text': 'https://github.com/chiamingyen/pygrouf   為多人群組軟體, 使用者可以透過 Gmail 帳號登入, 以類似討論版的方式進行網際互動. \n Pygrouf 採用  Flask  網際框架,  peewee  ORM,  authomatic  (可能已經不再維護),  mako  (可能已經不再維護),  PyMySQL . \n', 'tags': '', 'url': 'Pygrouf 解析.html'}, {'title': 'Pyslvs 解析', 'text': 'https://github.com/KmolYuan/Pyslvs-PyQt5   \n 採用 PyQt5 建立, 核心  https://github.com/KmolYuan/pyslvs   \n 演化運算模組: Adesign:  https://github.com/KmolYuan/Adesign   \n 因為倉儲帶有子模組與子模組下的子模組, 因此必須利用 --recurse-submodules 取下倉儲檔案: \n git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5 \n 假如希望直接 git clone 特定分支, 例如: dev, 則使用下列指令: \n git clone --recurse-submodules -b dev https://github.com/KmolYuan/Pyslvs-PyQt5 \n 編譯 Pyslvs 所需模組: \n requests pyqt5>=5.10 pyqtchart>=5.1 ezdxf==0.8.8 numpy cython openpyxl psutil peewee lark-parser networkx pydot pygments \n 以  \n pip install -r requirements.txt \n 安裝所需 Python 模組. \n 另外, 使用 Msys2 編譯前提必須設定: \n y:\\Python36\\Lib\\distutils\\distutils.cfg \n 內容為: \n [build]\ncompiler=mingw32 \n 表示要使用 mingw32-make 執行編譯. \n 編譯指令: \n mingw32-make clean\nmingw32-make \n', 'tags': '', 'url': 'Pyslvs 解析.html'}, {'title': 'Pyslvs 範例', 'text': 'python_solvespace 範例: \n 含動態程式庫範例檔案  sgcs_2_1.7z \n 必須採用 moving reference frame 執行運算. \n \'\'\'\npython3 -m pip install matplotlib\nPoint1 (0, 0)\nPoint2(90, 0)\nlink1 length 35\nlink2 length 70\nlink3 length 70\ntriangle length 70, 40, 40\n\'\'\'\nfrom slvs import *\nfrom math import *\nimport matplotlib.pyplot as plt\n\n# variables\nd0 = 90\nn1 = 35\nn2 = 70\nt1 = 40\nt2 = 40\nt3 = 70\n\n# use moving reference frame as p2 prime, increment angel is 5 degree\ndef crank_rocker(degree, p2x, p2y, p3x, p3y, p4x, p4y, p5x, p5y):\n    sys = System()\n    g = 1\n    # origin Point zero\n    p0 = sys.add_param(0.0)\n    p1 = sys.add_param(0.0)\n    p2 = sys.add_param(0.0)\n    Point0 = Point3d(p0, p1, p2)\n\n    # add normal vector\n    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)\n    p3 = sys.add_param(qw)\n    p4 = sys.add_param(qx)\n    p5 = sys.add_param(qy)\n    p6 = sys.add_param(qz)\n    Normal1 = Normal3d(p3, p4, p5, p6)\n\n    # add workplane\n    Workplane1 = Workplane(Point0, Normal1)\n\n    # convert 3D point to 2D point\n    p7 = sys.add_param(0.0)\n    p8 = sys.add_param(0.0)\n    Point1 = Point2d(Workplane1, p7, p8)\n    Constraint.dragged(Workplane1, Point1)\n\n    #add Point2 and Line0\n    p9 = sys.add_param(d0)\n    p10 = sys.add_param(0.0)\n    Point2 = Point2d(Workplane1, p9, p10)\n    Constraint.dragged(Workplane1, Point2)\n    \n    p11 = sys.add_param(p2x)\n    p12 = sys.add_param(p2y)\n    moving2 = Point2d(Workplane1, p11, p12)\n    Constraint.dragged(Workplane1, moving2)\n    # Line0 depends on Point1 and moving2\n    Line0 = LineSegment2d(Workplane1, Point1, moving2)\n\n    # triangle Point4- Point3-Point5\n    p13 = sys.add_param(p3x)\n    p14 = sys.add_param(p3y)\n    Point3 = Point2d(Workplane1, p13, p14)\n    p15 = sys.add_param(p4x)\n    p16 = sys.add_param(p4y)\n    Point4 = Point2d(Workplane1, p15, p16)\n    p17 = sys.add_param(p5x)\n    p18 = sys.add_param(p5y)\n    Point5 = Point2d(Workplane1, p17, p18)\n    Constraint.distance(t1, Workplane1, Point4, Point3)\n    Constraint.distance(t2, Workplane1, Point3, Point5)\n    Constraint.distance(t3, Workplane1, Point4, Point5)\n\n    # add Line1 and link length constraints\n    Constraint.distance(n1, Workplane1, Point1, Point4)\n    Constraint.distance(n2, Workplane1, Point2, Point5)\n    Line1 = LineSegment2d(Workplane1, Point1, Point4)\n\n    #add rotation angle constraint\n    Constraint.angle(Workplane1, degree, Line1, Line0, False)\n\n    #solve for results\n    sys.calculateFaileds = 1;\n\n    sys.solve()\n    result = sys.result\n\n    if(result == SLVS_RESULT_OKAY):\n\n        # return coordinates of Point3\n        return sys.get_param(13).val, sys.get_param(14).val, sys.get_param(15).val, sys.get_param(16).val, sys.get_param(17).val, sys.get_param(18).val\n\n    elif (result == SLVS_RESULT_INCONSISTENT):\n        print ("solve failed", degree)\n        print ("SLVS_RESULT_INCONSISTENT")\n        print ("%d DOF" % sys.dof)\n    elif (result == SLVS_RESULT_DIDNT_CONVERGE):\n        print ("solve failed")\n        print ("SLVS_RESULT_DIDNT_CONVERGE")\n        print ("%d DOF" % sys.dof)\n    elif (result == SLVS_RESULT_TOO_MANY_UNKNOWNS):\n        print ("solve failed")\n        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")\n        print ("%d DOF" % sys.dof)\n\n# main program\nXval  = []\nYval  = []\ninc = 5\n# initially Point3, Point4, Point5 coordinate\np3x = 20\np3y = 20\np4x = 0\np4y = 10\np5x = 30\np5y = 20\nfor i in range(0, 360+inc*3, inc):\n    # moving reference point\n    p2x = d0*cos(i*pi/180)\n    p2y = d0*sin(i*pi/180)\n    try:\n        p3x, p3y, p4x, p4y, p5x, p5y = crank_rocker(inc, p2x, p2y, p3x, p3y, p4x, p4y, p5x, p5y)\n        Xval += [p3x]\n        Yval += [p3y]\n        print(i, ":", round(p3x, 4), round(p3y, 4))\n    except:\n        pass\nprint ("Solve Completed")\n\nplt.plot(Xval, Yval)\nplt.xlabel(\'x coordinate\')\nplt.ylabel(\'y coordinate\')\nplt.show() \n 利用三角形符號式解四連桿運動模擬範例: \n # triangle_fourbar_point_track.py\nfrom math import pi, cos, sin, sqrt, acos\nimport matplotlib.pyplot as plt\n \nradian = 180/pi\ndegree = pi/180\n \n#PLAP\ndef plap(ax, ay, ac, bac, bx, by, pos):\n    if pos == 0:\n        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax \n        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay\n    else:\n        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax \n        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay\n    return cx, cy\n \n#PLLP\ndef pllp(ax, ay, ac, cb, bx, by, pos):\n    if pos == 0:\n        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))\n        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))\n    else:\n        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))\n        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))\n    return cx, cy\n\ndef crank_rocker(angle, p1x, p1y, p2x, p2y, len1, len2, len3, len4, len5):\n    p4x, p4y = plap(p1x, p1y, len1, angle, p2x, p2y, 0)\n    #print("cx=", cx, "cy=", cy)\n    p5x, p5y = pllp(p4x, p4y, len2, len3, p2x, p2y, 0)\n    #print("dx=", dx, "dy=", dy)\n    p3x, p3y = pllp(p4x, p4y, len4, len5, p5x, p5y, 0)\n    #print("ex=", ex, "ey=", ey)\n    return p3x, p3y\n    \n#主程式\nXval  = []\nYval  = []\ninc = 5\n\nfor i in range(0, 360+inc, inc):\n    try:\n        p3x, p3y = crank_rocker(i*degree, 0, 0, 90, 0, 35, 70, 70, 40, 40)\n        Xval += [p3x]\n        Yval += [p3y]\n        print(i, ":", round(p3x, 4), round(p3y, 4))\n    except:\n        pass\nprint ("Solve Completed")\n\nplt.plot(Xval, Yval)\nplt.xlabel(\'x coordinate\')\nplt.ylabel(\'y coordinate\')\n#plt.title("Involute - "+str(degree)+" deg")\nplt.show() \n', 'tags': '', 'url': 'Pyslvs 範例.html'}, {'title': '機構設計參考', 'text': 'Computer Aided Design of Eight-bar Linkages.pdf  (2014) \n \n', 'tags': '', 'url': '機構設計參考.html'}, {'title': 'Pyquino 解析', 'text': 'https://github.com/kmolLin/Pyquino   \n', 'tags': '', 'url': 'Pyquino 解析.html'}, {'title': 'Solvespace 解析', 'text': 'http://solvespace.com   \n', 'tags': '', 'url': 'Solvespace 解析.html'}, {'title': 'V-rep 解析', 'text': 'http://www.coppeliarobotics.com/   \n https://github.com/CoppeliaRobotics/v_rep   \n', 'tags': '', 'url': 'V-rep 解析.html'}, {'title': 'FreeCAD 解析', 'text': 'https://www.freecadweb.org/   \n', 'tags': '', 'url': 'FreeCAD 解析.html'}, {'title': 'RigitBody library', 'text': 'Rigit Body Dynamic Library \n https://rbdl.bitbucket.io   \n https://bitbucket.org/rbdl/rbdl   \n RBDL - an Efficient Rigid-Body Dynamics Library using Recursive Algorithms \n https://orb.iwr.uni-heidelberg.de/phpref/orb/pdf/Felis2016RBDLPreprint.pdf   or  local \n', 'tags': '', 'url': 'RigitBody library.html'}, {'title': 'FiniteElement library', 'text': 'http://mfem.org/   \n https://fenicsproject.org/   \n https://github.com/ali7line/awesome-fem   \n', 'tags': '', 'url': 'FiniteElement library.html'}, {'title': '網際平面連桿模擬', 'text': 'Brython 程式碼: \n <!-- 啟動 Brython -->\n\n<script>\nwindow.onload=function(){\n// 設定 data/py 為共用程式路徑\nbrython({debug:1, pythonpath:[\'./../data/py\']});\n}\n</script>\n\n<canvas id="plotarea" width="600" height="450"></canvas>\n\n<script type="text/python3">\nfrom browser import document\nimport math\nimport time\nfrom browser import timer\n\nclass Coord(object):\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n\n    def __sub__(self,other):\n        # This allows you to substract vectors\n        return Coord(self.x-other.x,self.y-other.y)\n\n    def __repr__(self):\n        # Used to get human readable coordinates when printing\n        return "Coord(%f,%f)"%(self.x,self.y)\n\n    def length(self):\n        # Returns the length of the vector\n        return math.sqrt(self.x**2 + self.y**2)\n\n    def angle(self):\n        # Returns the vector\'s angle\n        return math.atan2(self.y,self.x)\n\ndef normalize(coord):\n    return Coord(\n        coord.x/coord.length(),\n        coord.y/coord.length()\n        )\n\ndef perpendicular(coord):\n    # Shifts the angle by pi/2 and calculate the coordinates\n    # using the original vector length\n    return Coord(\n        coord.length()*math.cos(coord.angle()+math.pi/2),\n        coord.length()*math.sin(coord.angle()+math.pi/2)\n        )\n\n# 點類別\nclass Point(object):\n    # 起始方法\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    # 繪製方法\n    def drawMe(self, g, r):\n        self.g = g\n        self.r = r\n        self.g.save()\n        self.g.moveTo(self.x,self.y)\n        self.g.beginPath()\n        # 根據 r 半徑繪製一個圓代表點的所在位置\n        self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True)\n        self.g.moveTo(self.x,self.y)\n        self.g.lineTo(self.x+self.r, self.y)\n        self.g.moveTo(self.x, self.y)\n        self.g.lineTo(self.x-self.r, self.y)\n        self.g.moveTo(self.x, self.y)\n        self.g.lineTo(self.x, self.y+self.r)\n        self.g.moveTo(self.x, self.y)\n        self.g.lineTo(self.x, self.y-self.r)\n        self.g.restore()\n        self.g.stroke()\n\n    # 加入 Eq 方法\n    def Eq(self, pt):\n        self.x = pt.x\n        self.y = pt.y\n\n    # 加入 setPoint 方法\n    def setPoint(self, px, py):\n        self.x = px\n        self.y = py\n\n    # 加上 distance(pt) 方法, 計算點到 pt 的距離\n    def distance(self, pt):\n        self.pt = pt\n        x = self.x - self.pt.x\n        y = self.y - self.pt.y\n        return math.sqrt(x * x + y * y)\n\n    # 利用文字標示點的座標位置\n    def tag(self, g):\n        self.g = g\n        self.g.beginPath()\n        self.g.fillText("%d, %d"%(self.x, self.y),self.x, self.y)\n        self.g.stroke()\n\n\n# Line 類別物件\nclass Line(object):\n\n    # 起始方法\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        # 直線的第一點, 設為線尾\n        self.Tail = self.p1\n        # 直線組成的第二點, 設為線頭\n        self.Head = self.p2\n        # 直線的長度屬性\n        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))\n\n    # setPP 以指定頭尾座標點來定義直線\n    def setPP(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        self.Tail = self.p1\n        self.Head = self.p2\n        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))\n\n    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考\n    def setRT(self, r, t):\n        self.r = r\n        self.t = t\n        x = self.r * math.cos(self.t)\n        y = self.r * math.sin(self.t)\n        self.Tail.Eq(self.p1)\n        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)\n\n    # getR 方法 for Line\n    def getR(self):\n        # x 分量與 y 分量\n        x = self.p1.x - self.p2.x\n        y = self.p1.y - self.p2.y\n        return math.sqrt(x * x + y * y)\n\n    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間\n    def getT(self):\n        x = self.p2.x - self.p1.x\n        y = self.p2.y - self.p1.y\n        if (math.fabs(x) < math.pow(10,-100)):\n            if(y < 0.0):\n                return (-math.pi/2)\n            else:\n                return (math.pi/2)\n        else:\n            return math.atan2(y, x)\n\n    # setTail 方法 for Line\n    def setTail(self, pt):\n        self.pt = pt\n        self.Tail.Eq(pt)\n        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)\n\n    # getHead 方法 for Line\n    def getHead(self):\n        return self.Head\n\n    def getTail(self):\n        return self.Tail\n\n    def drawMe(self, g):\n        self.g = g\n        self.g.beginPath()\n        self.g.moveTo(self.p1.x,self.p1.y)\n        self.g.lineTo(self.p2.x,self.p2.y)\n        self.g.stroke()\n\n    def test(self):\n        return ("this is pure test to Inherit")\n\n\nclass Link(Line):\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))\n\n    #g context\n    def drawMe(self, g):\n        self.g = g\n        hole = 5\n        radius = 10\n        length = self.getR()\n        # alert(length)\n        # 儲存先前的繪圖狀態\n        self.g.save()\n        self.g.translate(self.p1.x,self.p1.y)\n        #alert(str(self.p1.x)+","+str(self.p1.y))\n        #self.g.rotate(-((math.pi/2)-self.getT()))\n        self.g.rotate(-math.pi*0.5 + self.getT())\n        #alert(str(self.getT()))\n        #self.g.rotate(10*math.pi/180)\n        #this.g.rotate(-(Math.PI/2-this.getT()));\n        # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...\n        self.g.beginPath()\n        self.g.moveTo(0,0)\n        self.g.arc(0, 0, hole, 0, 2*math.pi, True)\n        self.g.stroke()\n        self.g.moveTo(0,length)\n        self.g.beginPath()\n        self.g.arc(0,length, hole, 0, 2*math.pi, True)\n        self.g.stroke()\n        self.g.moveTo(0,0)\n        self.g.beginPath()\n        self.g.arc(0,0, radius, 0, math.pi, True)\n        self.g.moveTo(0+radius,0)\n        self.g.lineTo(0+radius,0+length)\n        self.g.stroke()\n        self.g.moveTo(0,0+length)\n        self.g.beginPath()\n        self.g.arc(0, 0+length, radius, math.pi, 0, True)\n        self.g.moveTo(0-radius,0+length)\n        self.g.lineTo(0-radius,0)\n        self.g.stroke()\n        self.g.restore()\n        \'\'\'\n        self.g.beginPath()\n        self.g.fillStyle = "red"\n        self.g.font = "bold 18px sans-serif"\n        self.g.fillText("%d, %d"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y)\n        self.g.stroke()\n        \'\'\'\n\n\nclass Triangle(object):\n    def __init__(self, p1, p2, p3):\n        self.p1 = p1\n        self.p2 = p2\n        self.p3 = p3\n\n    def getLenp3(self):\n        p1 = self.p1\n        ret = p1.distance(self.p2)\n        return ret\n\n    def getLenp1(self):\n        p2 = self.p2\n        ret = p2.distance(self.p3)\n        return ret\n\n    def getLenp2(self):\n        p1 = self.p1\n        ret = p1.distance(self.p3)\n        return ret\n\n    # 角度\n    def getAp1(self):\n        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))\n        return ret\n\n    #\n    def getAp2(self):\n        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))\n        return ret\n\n    def getAp3(self):\n        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))\n        return ret\n\n    def drawMe(self, g):\n        self.g = g\n        r = 5\n        # 繪出三個頂點\n        self.p1.drawMe(self.g,r)\n        self.p2.drawMe(self.g,r)\n        self.p3.drawMe(self.g,r)\n        line1 = Line(self.p1,self.p2)\n        line2 = Line(self.p1,self.p3)\n        line3 = Line(self.p2,self.p3)\n        # 繪出三邊線\n        line1.drawMe(self.g)\n        line2.drawMe(self.g)\n        line3.drawMe(self.g)\n\n    # ends Triangle def\n    # 透過三個邊長定義三角形\n    def setSSS(self, lenp3, lenp1, lenp2):\n        self.lenp3 = lenmidpt = Point(0, 0)\n        self.lenp1 = lenp1\n        self.lenp2 = lenp2\n        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))\n        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))\n        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))\n\n    # 透過兩個邊長與夾角定義三角形\n    def setSAS(self, lenp3, ap2, lenp1):\n        self.lenp3 = lenp3\n        self.ap2 = ap2\n        self.lenp1 = lenp1\n        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))\n        #等於 SSS(AB, BC, CA)\n\n    def setSaSS(self, lenp2, lenp3, lenp1):\n        self.lenp2 = lenp2\n        self.lenp3 = lenp3\n        self.lenp1 = lenp1\n        if(self.lenp1 > (self.lenp2 + self.lenp3)):\n        #<CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間\n            ret = math.pi\n        else :\n            # <CAB 夾角為 0, 三點共線且 A 不在 BC 之間\n            if((self.lenp1 < (self.lenp2 - self.lenp3)) or (self.lenp1 < (self.lenp3 - self.lenp2))):\n                ret = 0.0\n            else :\n            # 透過餘絃定理求出夾角 <CAB \n                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))\n        return ret\n\n    # 取得三角形的三個邊長值\n    def getSSS(self):\n        temp = []\n        temp.append( self.getLenp1() )\n        temp.append( self.getLenp2() )\n        temp.append( self.getLenp3() )\n        return temp\n\n    # 取得三角形的三個角度值\n    def getAAA(self):\n        temp = []\n        temp.append( self.getAp1() )\n        temp.append( self.getAp2() )\n        temp.append( self.getAp3() )\n        return temp\n\n    # 取得三角形的三個角度與三個邊長\n    def getASASAS(self):\n        temp = []\n        temp.append(self.getAp1())\n        temp.append(self.getLenp1())\n        temp.append(self.getAp2())\n        temp.append(self.getLenp2())\n        temp.append(self.getAp3())\n        temp.append(self.getLenp3())\n        return temp\n    #2P 2L return mid P\n    def setPPSS(self, p1, p3, lenp1, lenp3):\n        temp = []\n        self.p1 = p1\n        self.p3 = p3\n        self.lenp1 = lenp1\n        self.lenp3 = lenp3\n\n        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output\n        line31 = Line(p3, p1)\n        self.lenp2 = line31.getR()\n        #self.lenp2 = self.p3.distance(self.p1)\n        #這裡是求角3\n        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))\n        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))\n        bp3 = line31.getT()\n        cp3 = bp3 - ap3\n        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x\n        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y\n        return temp\n\ndef tag(g, p):\n    None\n\nmidpt = Point(0, 0)\ntippt = Point(0, 0)\ncontour = []\n# 執行繪圖流程, 注意 x, y 為 global variables\ndef draw():\n    global theta, midpt, oldpt\n    context.clearRect(0, 0, canvas.width, canvas.height)\n    line1.drawMe(context)\n    line2.drawMe(context)\n    line3.drawMe(context)\n    #triangle1.drawMe(context)\n    #triangle2.drawMe(context)\n    theta += dx\n    p2.x = p1.x + line1.length*math.cos(theta*degree)\n    p2.y = p1.y - line1.length*math.sin(theta*degree)\n    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)\n    # 計算垂直單位向量\n    a = Coord(p3.x, p3.y)\n    b = Coord(p2.x, p2.y)\n    normal = perpendicular(normalize(a-b))\n    midpt.x = (p2.x + p3.x)/2\n    midpt.y = (p2.y + p3.y)/2\n    tippt.x = midpt.x + 150*normal.x\n    tippt.y = midpt.y + 150*normal.y\n    if theta < 360:\n        contour.append((tippt.x, tippt.y))\n    context.beginPath()\n    context.moveTo(midpt.x, midpt.y)\n    context.lineTo(tippt.x, tippt.y)\n    # 利用 fillRect 繪製一個長寬各 1 單位的正方形\n    for i in range(len(contour)):\n        context.fillRect(contour[i][0], contour[i][1], 1, 1)\n    context.stroke()\n    #p1.tag(context)\n\n\n# 以上為相關函式物件的定義區\n# 全域變數\n# 幾何位置輸入變數\nx=10\ny=10\nr=10\n\n# 畫布與繪圖內容\n# 其他輸入變數\ntheta = 0\ndegree = math.pi/180.0\ndx = 2\ndy = 4\n\n#set p1.p2.p3.p4 position\nlift = 10\np1 =  Point(150,100+lift)\np2 =  Point(150,200+lift)\np3 =  Point(300,300+lift)\np4 =  Point(350,100+lift)\n\n#accord position create link\nline1 =  Link(p1,p2)\nline2 =  Link(p2,p3)\nline3 =  Link(p3,p4)\nline4 =  Link(p1,p4)\nline5 =  Link(p2,p4)\n\nlink2_len = p2.distance(p3)\nlink3_len = p3.distance(p4)\n\n#link2_len = line1.getR()\n#link3_len = line3.getR()\n#alert(str(link2_len)+\',\'+str(link3_len))\n\ntriangle1 =  Triangle(p1,p2,p4)\ntriangle2 =  Triangle(p2,p3,p4)\n\n# 視窗載入時執行內容\n# 繪圖畫布設定\n\ncanvas = document["plotarea"]\ncontext = canvas.getContext("2d")\n\n# 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角\ncontext.translate(0,canvas.height)\ncontext.scale(1,-1)\n\n#以間隔 20 micro seconds 重複呼叫 draw()\ntimer.set_interval(draw,20)\n#timer.set_interval(draw,10)\n</script> \n 寫成 plt.py 模組: \n import math\n\nclass Coord(object):\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n\n    def __sub__(self,other):\n        # This allows you to substract vectors\n        return Coord(self.x-other.x,self.y-other.y)\n\n    def __repr__(self):\n        # Used to get human readable coordinates when printing\n        return "Coord(%f,%f)"%(self.x,self.y)\n\n    def length(self):\n        # Returns the length of the vector\n        return math.sqrt(self.x**2 + self.y**2)\n\n    def angle(self):\n        # Returns the vector\'s angle\n        return math.atan2(self.y,self.x)\n\ndef normalize(coord):\n    return Coord(\n        coord.x/coord.length(),\n        coord.y/coord.length()\n        )\n\ndef perpendicular(coord):\n    # Shifts the angle by pi/2 and calculate the coordinates\n    # using the original vector length\n    return Coord(\n        coord.length()*math.cos(coord.angle()+math.pi/2),\n        coord.length()*math.sin(coord.angle()+math.pi/2)\n        )\n\n# 點類別\nclass Point(object):\n    # 起始方法\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    # 繪製方法\n    def drawMe(self, g, r):\n        self.g = g\n        self.r = r\n        self.g.save()\n        self.g.moveTo(self.x,self.y)\n        self.g.beginPath()\n        # 根據 r 半徑繪製一個圓代表點的所在位置\n        self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True)\n        self.g.moveTo(self.x,self.y)\n        self.g.lineTo(self.x+self.r, self.y)\n        self.g.moveTo(self.x, self.y)\n        self.g.lineTo(self.x-self.r, self.y)\n        self.g.moveTo(self.x, self.y)\n        self.g.lineTo(self.x, self.y+self.r)\n        self.g.moveTo(self.x, self.y)\n        self.g.lineTo(self.x, self.y-self.r)\n        self.g.restore()\n        self.g.stroke()\n\n    # 加入 Eq 方法\n    def Eq(self, pt):\n        self.x = pt.x\n        self.y = pt.y\n\n    # 加入 setPoint 方法\n    def setPoint(self, px, py):\n        self.x = px\n        self.y = py\n\n    # 加上 distance(pt) 方法, 計算點到 pt 的距離\n    def distance(self, pt):\n        self.pt = pt\n        x = self.x - self.pt.x\n        y = self.y - self.pt.y\n        return math.sqrt(x * x + y * y)\n\n    # 利用文字標示點的座標位置\n    def tag(self, g):\n        self.g = g\n        self.g.beginPath()\n        self.g.fillText("%d, %d"%(self.x, self.y),self.x, self.y)\n        self.g.stroke()\n\n\n# Line 類別物件\nclass Line(object):\n\n    # 起始方法\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        # 直線的第一點, 設為線尾\n        self.Tail = self.p1\n        # 直線組成的第二點, 設為線頭\n        self.Head = self.p2\n        # 直線的長度屬性\n        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))\n\n    # setPP 以指定頭尾座標點來定義直線\n    def setPP(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        self.Tail = self.p1\n        self.Head = self.p2\n        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))\n\n    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考\n    def setRT(self, r, t):\n        self.r = r\n        self.t = t\n        x = self.r * math.cos(self.t)\n        y = self.r * math.sin(self.t)\n        self.Tail.Eq(self.p1)\n        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)\n\n    # getR 方法 for Line\n    def getR(self):\n        # x 分量與 y 分量\n        x = self.p1.x - self.p2.x\n        y = self.p1.y - self.p2.y\n        return math.sqrt(x * x + y * y)\n\n    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間\n    def getT(self):\n        x = self.p2.x - self.p1.x\n        y = self.p2.y - self.p1.y\n        if (math.fabs(x) < math.pow(10,-100)):\n            if(y < 0.0):\n                return (-math.pi/2)\n            else:\n                return (math.pi/2)\n        else:\n            return math.atan2(y, x)\n\n    # setTail 方法 for Line\n    def setTail(self, pt):\n        self.pt = pt\n        self.Tail.Eq(pt)\n        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)\n\n    # getHead 方法 for Line\n    def getHead(self):\n        return self.Head\n\n    def getTail(self):\n        return self.Tail\n\n    def drawMe(self, g):\n        self.g = g\n        self.g.beginPath()\n        self.g.moveTo(self.p1.x,self.p1.y)\n        self.g.lineTo(self.p2.x,self.p2.y)\n        self.g.stroke()\n\n    def test(self):\n        return ("this is pure test to Inherit")\n\n\nclass Link(Line):\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))\n\n    #g context\n    def drawMe(self, g):\n        self.g = g\n        hole = 5\n        radius = 10\n        length = self.getR()\n        # alert(length)\n        # 儲存先前的繪圖狀態\n        self.g.save()\n        self.g.translate(self.p1.x,self.p1.y)\n        #alert(str(self.p1.x)+","+str(self.p1.y))\n        #self.g.rotate(-((math.pi/2)-self.getT()))\n        self.g.rotate(-math.pi*0.5 + self.getT())\n        #alert(str(self.getT()))\n        #self.g.rotate(10*math.pi/180)\n        #this.g.rotate(-(Math.PI/2-this.getT()));\n        # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...\n        self.g.beginPath()\n        self.g.moveTo(0,0)\n        self.g.arc(0, 0, hole, 0, 2*math.pi, True)\n        self.g.stroke()\n        self.g.moveTo(0,length)\n        self.g.beginPath()\n        self.g.arc(0,length, hole, 0, 2*math.pi, True)\n        self.g.stroke()\n        self.g.moveTo(0,0)\n        self.g.beginPath()\n        self.g.arc(0,0, radius, 0, math.pi, True)\n        self.g.moveTo(0+radius,0)\n        self.g.lineTo(0+radius,0+length)\n        self.g.stroke()\n        self.g.moveTo(0,0+length)\n        self.g.beginPath()\n        self.g.arc(0, 0+length, radius, math.pi, 0, True)\n        self.g.moveTo(0-radius,0+length)\n        self.g.lineTo(0-radius,0)\n        self.g.stroke()\n        self.g.restore()\n        \'\'\'\n        self.g.beginPath()\n        self.g.fillStyle = "red"\n        self.g.font = "bold 18px sans-serif"\n        self.g.fillText("%d, %d"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y)\n        self.g.stroke()\n        \'\'\'\n\n\nclass Triangle(object):\n    def __init__(self, p1, p2, p3):\n        self.p1 = p1\n        self.p2 = p2\n        self.p3 = p3\n\n    def getLenp3(self):\n        p1 = self.p1\n        ret = p1.distance(self.p2)\n        return ret\n\n    def getLenp1(self):\n        p2 = self.p2\n        ret = p2.distance(self.p3)\n        return ret\n\n    def getLenp2(self):\n        p1 = self.p1\n        ret = p1.distance(self.p3)\n        return ret\n\n    # 角度\n    def getAp1(self):\n        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))\n        return ret\n\n    #\n    def getAp2(self):\n        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))\n        return ret\n\n    def getAp3(self):\n        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))\n        return ret\n\n    def drawMe(self, g):\n        self.g = g\n        r = 5\n        # 繪出三個頂點\n        self.p1.drawMe(self.g,r)\n        self.p2.drawMe(self.g,r)\n        self.p3.drawMe(self.g,r)\n        line1 = Line(self.p1,self.p2)\n        line2 = Line(self.p1,self.p3)\n        line3 = Line(self.p2,self.p3)\n        # 繪出三邊線\n        line1.drawMe(self.g)\n        line2.drawMe(self.g)\n        line3.drawMe(self.g)\n\n    # ends Triangle def\n    # 透過三個邊長定義三角形\n    def setSSS(self, lenp3, lenp1, lenp2):\n        self.lenp3 = lenp3\n        self.lenp1 = lenp1\n        self.lenp2 = lenp2\n        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))\n        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))\n        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))\n\n    # 透過兩個邊長與夾角定義三角形\n    def setSAS(self, lenp3, ap2, lenp1):\n        self.lenp3 = lenp3\n        self.ap2 = ap2\n        self.lenp1 = lenp1\n        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))\n        #等於 SSS(AB, BC, CA)\n\n    def setSaSS(self, lenp2, lenp3, lenp1):\n        self.lenp2 = lenp2\n        self.lenp3 = lenp3\n        self.lenp1 = lenp1\n        if(self.lenp1 > (self.lenp2 + self.lenp3)):\n        #<CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間\n            ret = math.pi\n        else :\n            # <CAB 夾角為 0, 三點共線且 A 不在 BC 之間\n            if((self.lenp1 < (self.lenp2 - self.lenp3)) or (self.lenp1 < (self.lenp3 - self.lenp2))):\n                ret = 0.0\n            else :\n            # 透過餘絃定理求出夾角 <CAB \n                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))\n        return ret\n\n    # 取得三角形的三個邊長值\n    def getSSS(self):\n        temp = []\n        temp.append( self.getLenp1() )\n        temp.append( self.getLenp2() )\n        temp.append( self.getLenp3() )\n        return temp\n\n    # 取得三角形的三個角度值\n    def getAAA(self):\n        temp = []\n        temp.append( self.getAp1() )\n        temp.append( self.getAp2() )\n        temp.append( self.getAp3() )\n        return temp\n\n    # 取得三角形的三個角度與三個邊長\n    def getASASAS(self):\n        temp = []\n        temp.append(self.getAp1())\n        temp.append(self.getLenp1())\n        temp.append(self.getAp2())\n        temp.append(self.getLenp2())\n        temp.append(self.getAp3())\n        temp.append(self.getLenp3())\n        return temp\n    #2P 2L return mid P\n    def setPPSS(self, p1, p3, lenp1, lenp3):\n        temp = []\n        self.p1 = p1\n        self.p3 = p3\n        self.lenp1 = lenp1\n        self.lenp3 = lenp3\n\n        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output\n        line31 = Line(p3, p1)\n        self.lenp2 = line31.getR()\n        #self.lenp2 = self.p3.distance(self.p1)\n        #這裡是求角3\n        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))\n        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))\n        bp3 = line31.getT()\n        cp3 = bp3 - ap3\n        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x\n        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y\n        return temp \n 導入上述 plt.py 後執行平面四連桿運動模擬: \n <p>將四連桿模擬程式庫存在 ./../data/py 子目錄, 然後以 import 導入方式執行運算:</p>\n<canvas id="plotarea2" width="600" height="450"></canvas>\n\n<script type="text/python3">\n# import point-line-triangle module\nimport plt\nimport math\nfrom browser import document\nfrom browser import timer\n\nmidpt = plt.Point(0, 0)\ntippt = plt.Point(0, 0)\ncontour = []\n# 執行繪圖流程, 注意 x, y 為 global variables\ndef draw():\n    global theta, midpt, oldpt\n    context.clearRect(0, 0, canvas.width, canvas.height)\n    line1.drawMe(context)\n    line2.drawMe(context)\n    line3.drawMe(context)\n    line4.drawMe(context)\n    #triangle1.drawMe(context)\n    #triangle2.drawMe(context)\n    theta += dx\n    #PLAP\n    p2.x = p1.x + line1.length*math.cos(theta*degree)\n    p2.y = p1.y - line1.length*math.sin(theta*degree)\n    #PLLP\n    p3.x, p3.y = triangle2.setPPSS(p2,p4,line2.length,line3.length)\n    # 計算垂直單位向量\n    a = plt.Coord(p3.x, p3.y)\n    b = plt.Coord(p2.x, p2.y)\n    normal = plt.perpendicular(plt.normalize(a-b))\n    midpt.x = (p2.x + p3.x)/2\n    midpt.y = (p2.y + p3.y)/2\n    tippt.x = midpt.x + 150*normal.x\n    tippt.y = midpt.y + 150*normal.y\n    if theta < 360:\n        contour.append((tippt.x, tippt.y))\n    context.beginPath()\n    context.moveTo(midpt.x, midpt.y)\n    context.lineTo(tippt.x, tippt.y)\n    # 利用 fillRect 繪製一個長寬各 1 單位的正方形\n    for i in range(len(contour)):\n        context.fillRect(contour[i][0], contour[i][1], 1, 1)\n    context.stroke()\n    #p1.tag(context)\n\n\n# 以上為相關函式物件的定義區\n# 全域變數\n# 幾何位置輸入變數\nx=10\ny=10\nr=10\n\n# 畫布與繪圖內容\n# 其他輸入變數\ntheta = 0\ndegree = math.pi/180.0\ndx = 2\ndy = 4\n\n#set p1.p2.p3.p4 position\nlift = 10\n# 各起始座標點必須精確\np1 =  plt.Point(150,100+lift)\np2 =  plt.Point(150,200+lift)\np3 =  plt.Point(300,300+lift)\np4 =  plt.Point(350,100+lift)\n#共有五條線\nline1 =  plt.Link(p1,p2)\nline2 =  plt.Link(p2,p3)\nline3 =  plt.Link(p3,p4)\nline4 =  plt.Link(p1,p4)\nline5 =  plt.Link(p2,p4)\n\n#link2_len = p2.distance(p3)\n#link3_len = p3.distance(p4)\n\n#link2_len = line1.getR()\n#link3_len = line3.getR()\n#alert(str(link2_len)+\',\'+str(link3_len))\n\ntriangle1 =  plt.Triangle(p1,p2,p4)\ntriangle2 =  plt.Triangle(p2,p3,p4)\n\n# 視窗載入時執行內容\n# 繪圖畫布設定\n\ncanvas = document["plotarea2"]\ncontext = canvas.getContext("2d")\n\n# 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角\ncontext.translate(0,canvas.height)\ncontext.scale(1,-1)\n\n#以間隔 20 micro seconds 重複呼叫 draw()\ntimer.set_interval(draw,20)\n</script> \n', 'tags': '', 'url': '網際平面連桿模擬.html'}, {'title': '可攜系統', 'text': '初階  p37.7z  約 240MB, 解開後容量約 1GB, 可以執行基本 Python3, ANSI C, 與 Lua 程式, 並且內含 git, Fossil SCM 與 gnuplot. \n p37_adv.7z \xa0- p37 進階版本 \n 完整  Qt 可攜系統 .7z  約 8GB, 送到 disk1 AT gk 約需 30 分鐘, 製解壓縮需要 2.5 小時, 解開後容量約 21 GB. \n 或從  http://wcmg3.kmol.info./../downloads/Qt_20180714.7z  下載. \n 自行安裝模組: \n python -m pip install sympy \n python -m pip install kivy Pillow \n python -m pip install pygame kivy.deps.sdl2 kivy.deps.glew \n python -m pip install comtypes \n python -m pip install kivy.deps.gstreamer (not needed for pse) \n \n p37 額外安裝模組: \n python -m pip install flake8  可攜 Vivaldi 瀏覽器.7z  (under mdecourse At Gmail)', 'tags': '', 'url': '可攜系統.html'}, {'title': '帳號整合', 'text': '目前用於 oauth2 開發用的 https://localhost:6443 以  2016springwcm 郵件帳號登記憑證 \n coggle 心智圖則以 scrum1 AT mde 登記 \n 上課 github 則以 mdecourse 登記 \n 部分網誌文章與倉儲則又以 kmolab At github 登錄 \n p37 下載使用的 drive 則以 disk1 At goodkym 登錄 \n Qt 下載則又以 mdecourse 登錄 \n 以上相關帳號與附屬資源, 必須統一整合 \n', 'tags': '', 'url': '帳號整合.html'}, {'title': '代理主機', 'text': '在 Windows 64 位元操作系統, 以 Virtualbox , 使用 Ubuntu 18.04 Server 版建立 Squid 代理主機,  然後透過  http://vboxvmservice.sourceforge.net/  讓虛擬代理主機隨 Windows 開機啟動. \n 執行步驟 : \n \n 下載 Ubuntu 18.04 Server 版 iso \n 在 Windows 64 位元操作系統中安裝 Virtubox \n 利用 Virtualbox 安裝 Ubuntu 18.04 Server \n 在 Ubuntu Server 中安裝 Squid \n 設定 Squid 令其雙支援 IPv4 與 IPv6 協定 \n 設定 Squid 在 Ubuntu 開機時啟動 \n 設定 Virtualbox 中的 Ubuntu 在 Windows 開機時啟動 \n 若要轉移已經設定完成的 Virtualbox 主機, 以 File->Export Appliance 進行 \n 若要轉進已經設定完成的 Virtualbox 主機, 以 File->Import Applicance 進行 \n 轉進虛擬主機後, 必須針對實際環境加以修改相關設定 \n \n squid.conf 設定檔案: \n acl cad_lab src 140.130.17.0/24\nacl cad_lab src 2001:288:6004:17::/64\n \nacl SSL_ports port 443\nacl Safe_ports port 80 # http\nacl Safe_ports port 88\n \n#acl Safe_ports port 21 # ftp\nacl SSL_ports port 8443\nacl Safe_ports port 8443\n \nacl SSL_ports port 9443\nacl Safe_ports port 9443\n \nacl SSL_ports port 22\nacl Safe_ports port 22\n \nacl Safe_ports port 443 # https\nacl Safe_ports port 1025-65535 # unregistered ports\nacl Safe_ports port 280 # http-mgmt\nacl Safe_ports port 488 # gss-http\nacl Safe_ports port 591 # filemaker\nacl Safe_ports port 777 # multiling http\nacl CONNECT method CONNECT\n \n# Deny requests to certain unsafe ports\nhttp_access deny !Safe_ports\n \n# Deny CONNECT to other than secure SSL ports\nhttp_access deny CONNECT !SSL_ports\n \nhttp_access allow cad_lab\nhttp_access deny all\n# Only allow cachemgr access from localhost\nhttp_access allow localhost manager\nhttp_access deny manager\n \n#http_access allow localnet\nhttp_access allow localhost\n \n# And finally deny all other access to this proxy\nhttp_access deny all\n \n# Squid normally listens to port 3128\nhttp_port 3128\n \n#cache_dir ufs /var/spool/squid 100 16 256\nicp_port 3130\nicp_access allow all\n \ncache_dir ufs /var/spool/squid 2000 16 256\ncache_peer 140.130.17.17 sibling 3128 3130\ncache_peer 140.130.17.4 sibling 3128 3130\ncache_peer 140.130.17.9 sibling 3128 3130\ncache_peer 140.130.17.53 sibling 3128 3130\ncache_peer 140.130.17.42 sibling 3128 3130\n \n#\n# Add any of your own refresh_pattern entries above these.\n#\nrefresh_pattern ^ftp: 1440 20% 10080\nrefresh_pattern ^gopher: 1440 0% 1440\nrefresh_pattern -i (/cgi-bin/|\\?) 0 0% 0\nrefresh_pattern (Release|Packages(.gz)*)$ 0 20% 2880\nrefresh_pattern . 0 20% 4320 \n 安裝 squid \n sudo apt install squid \n sudo gedit /etc/squid/squid.conf \n sudo service squid restart \n netplan YAML 設定範例: \n network:\n    ethernets:\n        enp0s3:\n            addresses: \n                - 2001:288:6004:17:0811::cccc/64\n            gateway6: 2001:288:6004:17::254\n            nameservers:\n                addresses:\n                    - 2001:b000:168::1\n \n    version: 2 \n Ubuntu 操作指令: \n 刪除 history:  \n cat /dev/null > ~/.bash_history && history -c && exit \n', 'tags': '', 'url': '代理主機.html'}]};
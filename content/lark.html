<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>計算機程式教材</title> <link rel="stylesheet" type="text/css" href="./../static/cmsimply.css">
<link rel="icon" href="./../static/favicon.ico" type="image/x-icon" />

<script type="text/javascript" src="./../static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCSharp.js"></script>
<link type="text/css" rel="stylesheet" href="./../static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- for LaTeX equations 暫時不用
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>
-->
<!-- 暫時不用
<script src="./../static/fengari-web.js"></script>
<script type="text/javascript" src="./../static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->
<style>
img {
    border: 3px solid red;
}
</style>

<script src="./../static/jquery.js"></script>
<script type="text/javascript">
$(function(){
    $("ul.topmenu> li:has(ul) > a").append('<div class="arrow-right"></div>');
    $("ul.topmenu > li ul li:has(ul) > a").append('<div class="arrow-right"></div>');
});
</script>

</head><header><h1>2018 計算機程式教材</h1> <confmenu>
<ul>
<li><a href="index.html">Home</a></li>
<li><a href="sitemap.html">Site Map</a></li>
<li><a href="./../reveal/index.html">reveal</a></li>
<li><a href="./../blog/index.html">blog</a></li>

</ul>
</confmenu></header>
<div class='container'><nav><ul id='css3menu1' class='topmenu'><li><a href='簡介.html'>簡介</a><ul><li><a href='課程規劃.html'>課程規劃</a><li><a href='機械設計.html'>機械設計</a><li><a href='ANSI C.html'>ANSI C</a><li><a href='指標教材.html'>指標教材</a><ul><li><a href='ch1何謂指標.html'>ch1何謂指標</a><li><a href='ch2指標型別與陣列.html'>ch2指標型別與陣列</a><li><a href='ch3指標與字串.html'>ch3指標與字串</a><li><a href='ch4更多關於字串的用法.html'>ch4更多關於字串的用法</a><li><a href='ch5指標與結構.html'>ch5指標與結構</a><li><a href='ch6字串與字串陣列.html'>ch6字串與字串陣列</a><li><a href='ch7多維陣列.html'>ch7多維陣列</a><li><a href='ch8指向陣列的指標.html'>ch8指向陣列的指標</a><li><a href='ch9指標與動態記憶體配置.html'>ch9指標與動態記憶體配置</a><li><a href='ch10指向函式的指標.html'>ch10指向函式的指標</a><li><a href='ch11結語.html'>ch11結語</a></li></ul><li><a href='C++.html'>C++</a><li><a href='Python.html'>Python</a><ul><li><a href='Python 教材.html'>Python 教材</a><li><a href='what is new.html'>what is new</a><li><a href='style guide.html'>style guide</a><li><a href='typing.html'>typing</a><li><a href='dunder.html'>dunder</a><li><a href='Flake8.html'>Flake8</a><li><a href='unittest.html'>unittest</a><li><a href='lark.html'>lark</a></li></ul><li><a href='Kotlin.html'>Kotlin</a><li><a href='Red Lang.html'>Red Lang</a></li></ul><li><a href='工具.html'>工具</a><ul><li><a href='Git.html'>Git</a><li><a href='Fossil SCM.html'>Fossil SCM</a><li><a href='Leo Editor.html'>Leo Editor</a><li><a href='SCiTE.html'>SCiTE</a><li><a href='TinyCC.html'>TinyCC</a><li><a href='Qt.html'>Qt</a><li><a href='Kivy.html'>Kivy</a><li><a href='Eirc IDE.html'>Eirc IDE</a><li><a href='CMSimfly.html'>CMSimfly</a></li></ul><li><a href='實習操作.html'>實習操作</a><ul><li><a href='2018Fall.html'>2018Fall</a><li><a href='hello.c 與 Github.html'>hello.c 與 Github</a><li><a href='hello.c 與 Fossil.html'>hello.c 與 Fossil</a><li><a href='CMSimfly 操作.html'>CMSimfly 操作</a><li><a href='Pygrouf 操作.html'>Pygrouf 操作</a><li><a href='Pelican 操作.html'>Pelican 操作</a><li><a href='Reveal.js 操作.html'>Reveal.js 操作</a><li><a href='數值分析.html'>數值分析</a><li><a href='Qt C++ 計算器程式.html'>Qt C++ 計算器程式</a><ul><li><a href='Qt5 Tutorial.html'>Qt5 Tutorial</a></li></ul><li><a href='PyQt 計算器程式.html'>PyQt 計算器程式</a><ul><li><a href='PyQt5 實際操作.html'>PyQt5 實際操作</a></li></ul><li><a href='Flask 網際程式.html'>Flask 網際程式</a></li></ul><li><a href='應用範例.html'>應用範例</a><ul><li><a href='計算器.html'>計算器</a><li><a href='Tinkercad.html'>Tinkercad</a><li><a href='讀寫網頁內容.html'>讀寫網頁內容</a><li><a href='查英文單字.html'>查英文單字</a><li><a href='docx 轉 pdf.html'>docx 轉 pdf</a><li><a href='網際繪圖.html'>網際繪圖</a><li><a href='GUI 繪圖.html'>GUI 繪圖</a><ul><li><a href='QPainter.html'>QPainter</a><li><a href='靜態繪圖.html'>靜態繪圖</a><li><a href='Moveblocks.html'>Moveblocks</a><li><a href='PyQt5 範例.html'>PyQt5 範例</a><li><a href='STetris.html'>STetris</a><li><a href='Tetrix.html'>Tetrix</a></li></ul><li><a href='V-rep.html'>V-rep</a><ul><li><a href='Lua 學習.html'>Lua 學習</a></li></ul><li><a href='車輛工程.html'>車輛工程</a><ul><li><a href='維修管理.html'>維修管理</a></li></ul><li><a href='ERPNext.html'>ERPNext</a><li><a href='人臉辨識.html'>人臉辨識</a><li><a href='輔助設計套件.html'>輔助設計套件</a><ul><li><a href='NURB-Python.html'>NURB-Python</a><li><a href='libfive.html'>libfive</a><li><a href='robovision.html'>robovision</a><li><a href='jsketcher.html'>jsketcher</a><li><a href='kmolcad.html'>kmolcad</a></li></li></ul></ul><li><a href='分組專題.html'>分組專題</a><ul><li><a href='分組題目.html'>分組題目</a><li><a href='符號式推導.html'>符號式推導</a><li><a href='CMSimfly 解析.html'>CMSimfly 解析</a><ul><li><a href='CMSimfly 開發.html'>CMSimfly 開發</a></li></ul><li><a href='Pygrouf 解析.html'>Pygrouf 解析</a><li><a href='Pyslvs 解析.html'>Pyslvs 解析</a><ul><li><a href='Pyslvs 範例.html'>Pyslvs 範例</a><li><a href='機構設計參考.html'>機構設計參考</a></li></ul><li><a href='Pyquino 解析.html'>Pyquino 解析</a><li><a href='Solvespace 解析.html'>Solvespace 解析</a><li><a href='V-rep 解析.html'>V-rep 解析</a><li><a href='FreeCAD 解析.html'>FreeCAD 解析</a><li><a href='RigitBody library.html'>RigitBody library</a><li><a href='FiniteElement library.html'>FiniteElement library</a><li><a href='網際平面連桿模擬.html'>網際平面連桿模擬</a></li></ul><li><a href='可攜系統.html'>可攜系統</a><ul><li><a href='帳號整合.html'>帳號整合</a><li><a href='代理主機.html'>代理主機</a></li></ul></nav><section>unittest << <a href='unittest.html'>Previous</a> <a href='Kotlin.html'>Next</a> >> Kotlin<br /><h1>lark</h1>
<p><a href="https://github.com/lark-parser/lark">https://github.com/lark-parser/lark</a> </p>
<p><a href="http://blog.erezsh.com/how-to-write-a-dsl-in-python-with-lark/">http://blog.erezsh.com/how-to-write-a-dsl-in-python-with-lark/</a> </p>
<p>如何利用 python lark 模組寫 DSL (Domain Specific Language)</p>
<p>Matlab 與 Mathematica 就是 DSL 的典型範例.</p>
<p>首次使用 Logo 時, 感覺跟變魔術沒兩樣. 只要輸入簡短的指令組合, 就能在螢幕畫出非常複雜的圖形.</p>
<p>下面這一段教學, 將要展示如何利用 70 行程式, 透過解讀與解譯過程完成類似 Logo 的程式語言. 延續此一應用, 您將可自行打造自己的語言. 為了完成此一任務, 我們將使用 Lark 解讀程式庫與 turtle 繪圖模組. 讓我們開始!</p>
<p>What is a DSL and why should you care</p>
<p>When writing a software project, you might encounter information that your language of choice isn't very good at expressing or representing. It could be data, configuration, a list of commands, etc. Some abstraction might be missing, the language might prove too verbose, or writing the code might be too error-prone because there's no appropriate validation. When that happens, you might benefit from creating your own language, that describes the information in a clean and concise manner. That's called a "Domain-Specific Language", or DSL.</p>
<p>DSLs tend to be small and concise. And like most things, they have both pros and cons.</p>
<p>DSL Pros:</p>
<ul>
<li>Complete freedom of expression (within computational bounds)</li>
<li>Clean and concise code that's easier to read, write, and debug.</li>
<li>Validation by design</li>
<li>Dynamic - it can be evaluated in run-time</li>
<li>Reuse: DSLs can be shared between different languages and platforms (for example: Regular expressions)</li>
</ul>
<p>DSL Cons:</p>
<ul>
<li>Now there's another language to learn (but that's a lazy excuse)</li>
<li>You won't have direct access to Python's features (or whatever is your host language)</li>
<li>It's detached from your IDE</li>
<li>It might be difficult to design and to code(For a more detailed overview of DSLs pros and cons, visit here)</li>
</ul>
<p>Overall, there are many great reasons to use DSLs, but many programmers choose to avoid it, rightfully fearing the DSL will add complexity and take a long time to write. But, it doesn't have to be this way...</p>
<p>I'm going to take you step-by-step as we write our own DSL, starting with a naive solution, until we reach a working program with a parser and an interpreter. Hopefully, by the end of it I will convince you that DSLs can be a viable and cost-effective choice for your projects.</p>
<p>Designing a language</p>
<p>In this tutorial, we're going to write a DSL for Python's Turtle module! For those who don't know it, it's a Logo-inspired module for drawing vector graphics using simple commands. The first step when designing a language is to learn about the problem we're trying to solve (the domain). So if you never used the Turtle module, it might be prudent to look at some code, browse the docs, or play around with it a little bit.</p>
<p>To summarize, the Turtle module is used via a series of instructions. We can move the "turtle" on the canvas with spatial instructions (left, right, forward, etc.), we can change the size &amp; color of the turtle's pen, instruct it to move with or without drawing, or otherwise alter the state of the turtle and/or window.</p>
<p>The next step is to choose what your language is going to do: Which features or concepts it's going to support, and what you will leave out. To keep this tutorial short, we're going to support only a small subset of instructions:</p>
<ol>
<li>Left, right, forward and backward</li>
<li>Color</li>
<li>Repeat - since we can't use Python's "for" directly</li>
<li>Fill - activates filling mode. Chosen to demonstate structure</li>
</ol>
<p>Now that we know the contents of the language, we can move on to the third step: Choosing a syntax. This step is part common-sense, part art, and part subjective opinion. However, I do believe there are some guidelines that are innately true.</p>
<p>Guidelines to choosing syntax for a language:</p>
<ol>
<li>Use popular idioms, based on your target audience. By using structures, keywords and symbols everyone already knows, you cut the time it takes to learn your language.</li>
<li>Brevity of expression should correlate to the size of the language. For small languages, it's okay to use a lot of shorthands (see: regexps), but when the language gets bigger, opt for clarity instead (aka don't be Perl).</li>
<li>Design for innate correctness. Try to design the language so it will promote good practices, and discourage abuse.</li>
</ol>
<p>For example, Python was aimed at C programmers (among others), so it borrowed C syntax like += for in-place addition , and keywords like break and continue.</p>
<p>For our Turtle DSL, I will borrow my idioms and syntax from Logo, but with a modern twist. We'll use {curly-braces} for code blocks. And since we'll be designing a very small, interpreted language, we can make our basic commands one-lettered.</p>
<p>Here's how a program looks in my imaginary Turtle Language:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">c green blue    # fg &amp; bg colors
fill { repeat 36 {
  f200 l170     # forward &amp; left
}}
</pre>
<p>But it's not going to be imaginary for long! Let's move on to the practical side of things.</p>
<p>Writing the grammar</p>
<p>Step 1) EBNF</p>
<p>Now that we know what our language looks like, we can to write a formal grammar for it. Later, we will feed our grammar to the parser, so it will know how to parse free-form text written in our language into a structured parse-tree that's easy to work with programmatically.</p>
<p>The standard way to write grammars is in EBNF form, and that's what we'll do in this tutorial. EBNF grammars are basically a hierarchy of rules and strings of the form:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">name: production</pre>
<p>Where production is a list of names and values.</p>
<p>Or informally:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">rule: rule1, "keyword", rule2, rule3, ..</pre>
<p>Rules can be recursive, but it's better to describe loops with repetition-operators. For example, this is how I would define Python's dictionary syntax in EBNF:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">dict: "{" dict_item* "}"
dict_item: name ":" value
...</pre>
<p>This is enough to allow us to describe an instruction in Turtle Language:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">instruction: "f" number
           | "b" number
           | "l" number
           | "r" number
           | "c" color [color] // bgcolor is optional
           | "fill" code_block
           | "repeat" number code_block
 
code_block: "{" instruction+ "}"  // one or more instructions
</pre>
<p>This is an accurate and fairly succinct description of our syntax. We could however make it a little shorter, by avoiding repetition.</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">instruction: ("f"|"b"|"l"|"r") number
           | "c" color [color]
           | "fill" code_block
           | "repeat" number code_block
 
code_block: "{" instruction+ "}"
</pre>
<p>This variation is equivalent to the first one, just a little shorter.</p>
<p>You may have noticed our grammar contains a recursion between "code_block" and "instruction". That's totally fine, this is what parsers live for.</p>
<p>We still haven't defined "number" and "color". We'll do that next.</p>
<p>Step 2) Lark</p>
<p>So far, everything we did was fairly agnostic of a specific parsing library. But now is a good time to introduce Lark.</p>
<p>Lark is an open-source parsing library I spent the last month writing. I know, there are dozens of other parsing libraries. Why introduce yet another one? Here's why:</p>
<p>Lark uses the Earley parsing algorithm, a dynamic parsing algorithm that can handle all context-free grammars, including ambiguous grammars. It also supports a scannerless mode, which means terminals (tokens) are resolved by Earley at parse-time. The end result is that when you write your grammar with Lark, you don't have to worry about restrictions or state-machines. All grammar structures are allowed. If your grammar makes logical sense, Lark can parse it.</p>
<p>Lark is the only library that can make this claim. It also accepts grammars in a convenient EBNF form. It supplies a library of common terminals (i.e. regexps), to save its users from re-inventing the wheel in every grammar. And it can build a parse-tree automatically for every grammar.</p>
<p>Here ends the sales pitch, although I could go on. Let's look at how our grammar will look like in Lark, and I will follow with a thorough explanation:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">start: instruction+
 
instruction: ("f"|"b"|"l"|"r") NUMBER
           | "c" COLOR [COLOR]
           | "fill" code_block
           | "repeat" NUMBER code_block
 
code_block: "{" instruction+ "}"
 
COLOR: ("a".."z")+   
NUMBER: ("0".."9")+
WHITESPACE: (" " | "\n")+
%ignore WHITESPACE
</pre>
<p>(If you are following this by trying the the code, that's awesome! Don't forget to escape the '\n'.)</p>
<p>In the first line, we tell Lark that our program is basically a list of instructions.</p>
<p>The next part is literally a copy-paste of our EBNF definition from above, only we change "color" and "number" to their terminal form, and define them.</p>
<p>When names are written in uppercase in Lark, they are treated as terminals. Terminals are a little like rules: They also match input by combining smaller particles. But while rules match structure, terminals match strings. If we defined COLOR as a rule instead (lowercase color), the parser will create structure where it makes no sense (For example, Tree("r", "e", "d") instead of just the string "red").</p>
<p>Another thing about terminals is that they are greedy, which is just what we need in this case.</p>
<p>Then finally, the last line tells lark to ignore whitespace. (Extra information!)</p>
<p>Now it's time to see how we did. Let's run Lark on our sample language using our grammar, and see what we get:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">text = """
c red yellow
fill { repeat 36 {
    f200 l170
}}    
"""
 
from lark import Lark
parser = Lark(turtle_grammar)  # Scannerless Earley is the default
 
print(parser.parse(text))
</pre>
<p>We get this:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">Tree(start, [Tree(instruction, [Token(COLOR, u'red'), Token(COLOR, u'yellow')]), Tree(instruction, [Tree(code_block, [Tree(instruction, [Token(NUMBER, u'36'), Tree(code_block, [Tree(instruction, [Token(NUMBER, u'200')]), Tree(instruction, [Token(NUMBER, u'170')])])])])])])</pre>
<p>Let's make it more readable:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; print(parser.parse(text).pretty())
start
  instruction
    red
    yellow
  instruction
    code_block
      instruction
        36
        code_block
          instruction   200
          instruction   170
</pre>
<p>This is much better! We get a tree that correctly represents the structure of our program. However, it's a little hard to tell, because some of the strings are missing! This is by design: Lark automatically removes anonymous strings because it assumes they are just punctuation. This is a very convenient default, and there are several ways to keep the strings. One obvious way is to make them into named terminals. Then they are no longer anonymous, and they will appear in the tree. We're going to do this for movement (b/f/l/r). But we don't really need the strings themselves, we just want to know which instruction was specified. So for the rest, we'll use a more elegant approach: Rename the branches, by using aliases.</p>
<p>While we're at it, let's also simplify the grammar and import some of our terminals from our grammar library, instead of defining them.</p>
<p>Let's just rewrite the grammar, since the change is fairly straight-forward:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">start: instruction+
 
instruction: MOVEMENT NUMBER            -&gt; movement
           | "c" COLOR [COLOR]          -&gt; change_color
           | "fill" code_block          -&gt; fill
           | "repeat" NUMBER code_block -&gt; repeat
 
code_block: "{" instruction+ "}"
 
MOVEMENT: "f"|"b"|"l"|"r"
COLOR: LETTER+
 
%import common.LETTER
%import common.INT -&gt; NUMBER
%import common.WS
%ignore WS
</pre>
<p>Imported terminals are defined using regular EBNF, just like we defined COLOR and NUMBER. You can see their definition here (common.g).</p>
<p>And when we run the parser again, we get this:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">start
  change_color
    red
    yellow
  fill
    code_block
      repeat
        36
        code_block
          movement
            f
            200
          movement
            l
            170
</pre>
<p>This parse-tree expresses exactly what we want, and nothing more. That is a good ideal to aspire to: A minimal parse-tree is a happy parse-tree!</p>
<p>Now that we know how to turn free-form text in Turtle Language into a structural tree, it's time to write the actual interpreter!</p>
<p>Interpreting the parse-tree</p>
<p>The purpose of a language is to run free. Let's allow Turtle Language to start running.</p>
<p>It's common practice, when interpreting code, to compile the parse-tree into byte code that can run efficiently, and is more compact. We are not troubled by such earthly concerns; our toy DSL is small and doesn't do much. We are going to do something a little taboo: Run by directly reading from our pretty parse tree.</p>
<p>We will write a function called "run_instruction" that accepts branches of the tree, and executes them according to the branch name.</p>
<p>The Tree class in Lark has two attributes: data, which may contain any value (i.e any Python object), and children, which is a mixed list of Trees and values. So, a single tree structure is just a bunch of Tree instances nested inside each other as children. The Tree.pretty() method, that we saw earlier, just prints out these two attributes in an indented format according to their nesting-level. In the context of a parse-tree, these attributes represent specific concepts:</p>
<p>1. data -&gt; returns the name of the rule that was matched<br/>2. children -&gt; returns the subrules (trees) and tokens (strings) that were matched inside it. This is known as the production, or expansion.</p>
<p>With that knowledge, the function itself is simple:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import turtle
 
def run_instruction(t):
    if t.data == 'change_color':
        turtle.color(*t.children)   # We just pass the color names as-is
 
    elif t.data == 'movement':
        name, number = t.children
        {
            'f': turtle.fd,
            'b': turtle.bk,
            'l': turtle.lt,
            'r': turtle.rt,
        }[name](int(number))
 
    elif t.data == 'repeat':
        count, block = t.children
        for i in range(int(count)):
            run_instruction(block)
 
    elif t.data == 'fill':
        turtle.begin_fill()
        run_instruction(t.children[0])
        turtle.end_fill()
 
    elif t.data == 'code_block':
        for cmd in t.children:
            run_instruction(cmd)
 
    else:
        raise SyntaxError('Unknown instruction: %s' % t.data)  
</pre>
<p>This straight-forward Python code is really all we need to run the instructions.</p>
<p>And now, for the main-loop:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">parser = Lark(turtle_grammar)
 
def run_turtle(program):
    parse_tree = parser.parse(program)
 
    for inst in parse_tree.children:
        run_instruction(inst)
 
def main():
    while True:
        code = input('&gt; ')
        try:
            run_turtle(code)
        except Exception as e:
            print(e)
</pre>
<p>Run this under python, and you can now program interactively in the Turtle Language!</p>
<p>We can also call run_turtle directly:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">run_turtle("""
c green blue
fill { repeat 36 {
  f200 l170
}}
""")
</pre>
<p>To get this unblinking eye:</p>
<p><img alt="" height="227" src="./../images/turtle_dsl.png" width="258"/></p>
<p><a href="https://github.com/lark-parser/lark/blob/master/examples/turtle_dsl.py">https://github.com/lark-parser/lark/blob/master/examples/turtle_dsl.py</a> </p>
<p>Conclusion</p>
<p>In this tutorial, we implemented a parser and an interpreter in few lines of code, and without having to know many technical details.</p>
<p>We implemented a very small language, but it's easy to extend. Adding commands should be very simple, since the template for that already exists. Adding variables that can be used in expressions won't be much of a challenge either. You can see how Lark's calculator example does exactly that with relative ease. Combining these two grammars with a little bit of glue code, will result in something that feels like a real programming language, albeit simplistic.</p>
<p>I hope I inspired to go and write a DSL for your project. If you need any help in doing so, or if Lark is missing a feature you need dearly, drop me a line and I'll be happy to assist you. You can reach me at erezshin at gmail com.</p>
<br />unittest << <a href='unittest.html'>Previous</a> <a href='Kotlin.html'>Next</a> >> Kotlin</section></div></body></html>
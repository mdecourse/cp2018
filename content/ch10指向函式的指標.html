<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>計算機程式教材</title> <link rel="stylesheet" type="text/css" href="./../static/cmsimply.css">
<link rel="icon" href="./../static/favicon.ico" type="image/x-icon" />

<script type="text/javascript" src="./../static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCSharp.js"></script>
<link type="text/css" rel="stylesheet" href="./../static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- for LaTeX equations 暫時不用
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>
-->
<!-- 暫時不用
<script src="./../static/fengari-web.js"></script>
<script type="text/javascript" src="./../static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->
<style>
img {
    border: 3px solid red;
}
</style>

<script src="./../static/jquery.js"></script>
<script type="text/javascript">
$(function(){
    $("ul.topmenu> li:has(ul) > a").append('<div class="arrow-right"></div>');
    $("ul.topmenu > li ul li:has(ul) > a").append('<div class="arrow-right"></div>');
});
</script>

</head><header><h1>2018 計算機程式教材</h1> <confmenu>
<ul>
<li><a href="index.html">Home</a></li>
<li><a href="sitemap.html">Site Map</a></li>
<li><a href="./../reveal/index.html">reveal</a></li>
<li><a href="./../blog/index.html">blog</a></li>

</ul>
</confmenu></header>
<div class='container'><nav><ul id='css3menu1' class='topmenu'><li><a href='簡介.html'>簡介</a><ul><li><a href='課程規劃.html'>課程規劃</a><li><a href='機械設計.html'>機械設計</a><li><a href='ANSI C.html'>ANSI C</a><li><a href='指標教材.html'>指標教材</a><ul><li><a href='ch1何謂指標.html'>ch1何謂指標</a><li><a href='ch2指標型別與陣列.html'>ch2指標型別與陣列</a><li><a href='ch3指標與字串.html'>ch3指標與字串</a><li><a href='ch4更多關於字串的用法.html'>ch4更多關於字串的用法</a><li><a href='ch5指標與結構.html'>ch5指標與結構</a><li><a href='ch6字串與字串陣列.html'>ch6字串與字串陣列</a><li><a href='ch7多維陣列.html'>ch7多維陣列</a><li><a href='ch8指向陣列的指標.html'>ch8指向陣列的指標</a><li><a href='ch9指標與動態記憶體配置.html'>ch9指標與動態記憶體配置</a><li><a href='ch10指向函式的指標.html'>ch10指向函式的指標</a><li><a href='ch11結語.html'>ch11結語</a></li></ul><li><a href='C++.html'>C++</a><li><a href='Python.html'>Python</a><ul><li><a href='Python 教材.html'>Python 教材</a><li><a href='what is new.html'>what is new</a><li><a href='style guide.html'>style guide</a><li><a href='typing.html'>typing</a><li><a href='dunder.html'>dunder</a><li><a href='Flake8.html'>Flake8</a><li><a href='unittest.html'>unittest</a><li><a href='lark.html'>lark</a></li></ul><li><a href='Kotlin.html'>Kotlin</a><li><a href='Red Lang.html'>Red Lang</a></li></ul><li><a href='工具.html'>工具</a><ul><li><a href='Git.html'>Git</a><li><a href='Fossil SCM.html'>Fossil SCM</a><li><a href='Leo Editor.html'>Leo Editor</a><li><a href='SCiTE.html'>SCiTE</a><li><a href='TinyCC.html'>TinyCC</a><li><a href='Qt.html'>Qt</a><li><a href='Kivy.html'>Kivy</a><li><a href='Eirc IDE.html'>Eirc IDE</a><li><a href='CMSimfly.html'>CMSimfly</a><li><a href='Kmol-editor.html'>Kmol-editor</a></li></ul><li><a href='實習操作.html'>實習操作</a><ul><li><a href='2018Fall.html'>2018Fall</a><li><a href='hello.c 與 Github.html'>hello.c 與 Github</a><li><a href='hello.c 與 Fossil.html'>hello.c 與 Fossil</a><li><a href='CMSimfly 操作.html'>CMSimfly 操作</a><li><a href='Pygrouf 操作.html'>Pygrouf 操作</a><li><a href='Pelican 操作.html'>Pelican 操作</a><li><a href='Reveal.js 操作.html'>Reveal.js 操作</a><li><a href='數值分析.html'>數值分析</a><li><a href='Qt C++ 計算器程式.html'>Qt C++ 計算器程式</a><ul><li><a href='Qt5 Tutorial.html'>Qt5 Tutorial</a></li></ul><li><a href='PyQt 計算器程式.html'>PyQt 計算器程式</a><ul><li><a href='PyQt5 實際操作.html'>PyQt5 實際操作</a></li></ul><li><a href='Flask 網際程式.html'>Flask 網際程式</a></li></ul><li><a href='應用範例.html'>應用範例</a><ul><li><a href='計算器.html'>計算器</a><li><a href='Tinkercad.html'>Tinkercad</a><li><a href='讀寫網頁內容.html'>讀寫網頁內容</a><li><a href='查英文單字.html'>查英文單字</a><li><a href='docx 轉 pdf.html'>docx 轉 pdf</a><li><a href='網際繪圖.html'>網際繪圖</a><li><a href='GUI 繪圖.html'>GUI 繪圖</a><ul><li><a href='QPainter.html'>QPainter</a><li><a href='靜態繪圖.html'>靜態繪圖</a><li><a href='Moveblocks.html'>Moveblocks</a><li><a href='PyQt5 範例.html'>PyQt5 範例</a><li><a href='STetris.html'>STetris</a><li><a href='Tetrix.html'>Tetrix</a></li></ul><li><a href='V-rep.html'>V-rep</a><ul><li><a href='Lua 學習.html'>Lua 學習</a></li></ul><li><a href='車輛工程.html'>車輛工程</a><ul><li><a href='維修管理.html'>維修管理</a></li></ul><li><a href='ERPNext.html'>ERPNext</a><li><a href='人臉辨識.html'>人臉辨識</a><li><a href='輔助設計套件.html'>輔助設計套件</a><ul><li><a href='NURB-Python.html'>NURB-Python</a><li><a href='libfive.html'>libfive</a><li><a href='robovision.html'>robovision</a><li><a href='jsketcher.html'>jsketcher</a><li><a href='kmolcad.html'>kmolcad</a></li></li></ul></ul><li><a href='分組專題.html'>分組專題</a><ul><li><a href='分組題目.html'>分組題目</a><li><a href='符號式推導.html'>符號式推導</a><li><a href='CMSimfly 解析.html'>CMSimfly 解析</a><ul><li><a href='CMSimfly 開發.html'>CMSimfly 開發</a></li></ul><li><a href='Pygrouf 解析.html'>Pygrouf 解析</a><li><a href='Pyslvs 解析.html'>Pyslvs 解析</a><ul><li><a href='Pyslvs 範例.html'>Pyslvs 範例</a><li><a href='機構設計參考.html'>機構設計參考</a></li></ul><li><a href='Pyquino 解析.html'>Pyquino 解析</a><li><a href='Solvespace 解析.html'>Solvespace 解析</a><li><a href='V-rep 解析.html'>V-rep 解析</a><li><a href='FreeCAD 解析.html'>FreeCAD 解析</a><li><a href='RigitBody library.html'>RigitBody library</a><li><a href='FiniteElement library.html'>FiniteElement library</a><li><a href='網際平面連桿模擬.html'>網際平面連桿模擬</a></li></ul><li><a href='可攜系統.html'>可攜系統</a><ul><li><a href='帳號整合.html'>帳號整合</a><li><a href='代理主機.html'>代理主機</a></li></ul></nav><section>ch9指標與動態記憶體配置 << <a href='ch9指標與動態記憶體配置.html'>Previous</a> <a href='ch11結語.html'>Next</a> >> ch11結語<br /><h1>ch10指向函式的指標</h1>
<p>Up to this point we have been discussing pointers to data objects. C also permits the declaration of pointers to functions. Pointers to functions have a variety of uses and some of them will be discussed here.</p>
<p>Consider the following real problem. You want to write a function that is capable of sorting virtually any collection of data that can be stored in an array. This might be an array of strings, or integers, or floats, or even structures. The sorting algorithm can be the same for all. For example, it could be a simple bubble sort algorithm, or the more complex shell or quick sort algorithm. We'll use a simple bubble sort for demonstration purposes.</p>
<p>Sedgewick [1] has described the bubble sort using C code by setting up a function which when passed a pointer to the array would sort it. If we call that function bubble(), a sort program is described by bubble_1.c, which follows:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/*-------------------- bubble_1.c --------------------*/
 
/* Program bubble_1.c from PTRTUT10.HTM   6/13/97 */
 
#include &lt;stdio.h&gt;
 
int arr[10] = { 3,6,1,2,3,8,4,1,7,2};
 
void bubble(int a[], int N);
 
int main(void)
{
    int i;
    putchar('\n');
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr,10);
    putchar('\n');
 
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}
 
void bubble(int a[], int N)
{
    int i, j, t;
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (a[j-1] &gt; a[j])
            {
                t = a[j-1];
                a[j-1] = a[j];
                a[j] = t;
            }
        }
    }
}</pre>
<p>---------------------- end bubble_1.c -----------------------</p>
<p><a href="http://codepad.org/lnLshCvk">執行 bubble_1.c</a></p>
<p>The bubble sort is one of the simpler sorts. The algorithm scans the array from the second to the last element comparing each element with the one which precedes it. If the one that precedes it is larger than the current element, the two are swapped so the larger one is closer to the end of the array.</p>
<p>On the first pass, this results in the largest element ending up at the end of the array. The array is now limited to all elements except the last and the process repeated. This puts the next largest element at a point preceding the largest element. The process is repeated for a number of times equal to the number of elements minus 1. The end result is a sorted array.</p>
<p>Here our function is designed to sort an array of integers. Thus in line 1 we are comparing integers and in lines 2 through 4 we are using temporary integer storage to store integers. What we want to do now is see if we can convert this code so we can use any data type, i.e. not be restricted to integers.</p>
<p>At the same time we don't want to have to analyze our algorithm and the code associated with it each time we use it. We start by removing the comparison from within the function bubble() so as to make it relatively easy to modify the comparison function without having to re-write portions related to the actual algorithm. This results in bubble_2.c:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/*---------------------- bubble_2.c -------------------------*/
 
/* Program bubble_2.c from PTRTUT10.HTM   6/13/97 */
 
   /* Separating the comparison function */
 
#include &lt;stdio.h&gt;
 
int arr[10] = { 3,6,1,2,3,8,4,1,7,2};
 
void bubble(int a[], int N);
int compare(int m, int n);
 
int main(void)
{
    int i;
    putchar('\n');
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr,10);
    putchar('\n');
 
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}
 
void bubble(int a[], int N)
 
{
    int i, j, t;
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (compare(a[j-1], a[j]))
            {
                t = a[j-1];
                a[j-1] = a[j];
                a[j] = t;
            }
        }
    }
}
 
int compare(int m, int n)
{
    return (m &gt; n);
}
/*--------------------- end of bubble_2.c -----------------------*/</pre>
<p><a href="http://codepad.org/nJZesDqg">執行 bubble_2.c</a></p>
<p>If our goal is to make our sort routine data type independent, one way of doing this is to use pointers to type void to point to the data instead of using the integer data type. As a start in that direction let's modify a few things in the above so that pointers can be used. To begin with, we'll stick with pointers to type integer.</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/*----------------------- bubble_3.c -------------------------*/
 
/* Program bubble_3.c from PTRTUT10.HTM    6/13/97 */
 
#include &lt;stdio.h&gt;
 
int arr[10] = { 3,6,1,2,3,8,4,1,7,2};
 
void bubble(int *p, int N);
int compare(int *m, int *n);
 
int main(void)
{
    int i;
    putchar('\n');
 
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr,10);
    putchar('\n');
 
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}
 
void bubble(int *p, int N)
{
    int i, j, t;
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (compare(&amp;p[j-1], &amp;p[j]))
            {
                t = p[j-1];
                p[j-1] = p[j];
                p[j] = t;
            }
        }
    }
}
 
int compare(int *m, int *n)
{
    return (*m &gt; *n);
}
 
/*------------------ end of bubble3.c -------------------------*/</pre>
<p><a href="http://codepad.org/YGRii7il">執行 Program bubble3.c</a></p>
<p>Note the changes. We are now passing a pointer to an integer (or array of integers) to bubble(). And from within bubble we are passing pointers to the elements of the array that we want to compare to our comparison function. And, of course we are dereferencing these pointer in our compare() function in order to make the actual comparison. Our next step will be to convert the pointers in bubble() to pointers to type void so that that function will become more type insensitive. This is shown in bubble_4.</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/*------------------ bubble_4.c ----------------------------*/
 
/* Program bubble_4.c from PTRTUT10,HTM   6/13/97 */
 
#include &lt;stdio.h&gt;
 
int arr[10] = { 3,6,1,2,3,8,4,1,7,2};
 
void bubble(int *p, int N);
int compare(void *m, void *n);
 
int main(void)
{
    int i;
    putchar('\n');
 
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr,10);
    putchar('\n');
 
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}
 
void bubble(int *p, int N)
{
    int i, j, t;
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (compare((void *)&amp;p[j-1], (void *)&amp;p[j]))
            {
                t = p[j-1];
                p[j-1] = p[j];
                p[j] = t;
            }
        }
    }
}
 
int compare(void *m, void *n)
{
    int *m1, *n1;
    m1 = (int *)m;
    n1 = (int *)n;
    return (*m1 &gt; *n1);
}
 
/*------------------ end of bubble_4.c ---------------------*/</pre>
<p><a href="http://codepad.org/qLL8r2Dr">執行 bubble_4.c</a></p>
<p>Note that, in doing this, in compare() we had to introduce the casting of the void pointer types passed to the actual type being sorted. But, as we'll see later that's okay. And since what is being passed to bubble() is still a pointer to an array of integers, we had to cast these pointers to void pointers when we passed them as parameters in our call to compare().</p>
<p>We now address the problem of what we pass to bubble(). We want to make the first parameter of that function a void pointer also. But, that means that within bubble() we need to do something about the variable t, which is currently an integer. Also, where we use t = p[j-1]; the type of p[j-1] needs to be known in order to know how many bytes to copy to the variable t (or whatever we replace t with).</p>
<p>Currently, in bubble_4.c, knowledge within bubble() as to the type of the data being sorted (and hence the size of each individual element) is obtained from the fact that the first parameter is a pointer to type integer. If we are going to be able to use bubble() to sort any type of data, we need to make that pointer a pointer to type void.</p>
<p>But, in doing so we are going to lose information concerning the size of individual elements within the array. So, in bubble_5.c we will add a separate parameter to handle this size information.</p>
<p>These changes, from bubble4.c to bubble5.c are, perhaps, a bit more extensive than those we have made in the past. So, compare the two modules carefully for differences.</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/*---------------------- bubble5.c ---------------------------*/
 
/* Program bubble_5.c from PTRTUT10.HTM    6/13/97 */
 
 
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
long arr[10] = { 3,6,1,2,3,8,4,1,7,2};
 
void bubble(void *p, size_t width, int N);
int compare(void *m, void *n);
 
int main(void)
{
    int i;
    putchar('\n');
 
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr, sizeof(long), 10);
    putchar('\n');
 
    for (i = 0; i &lt; 10; i++)
    {
        printf("%ld ", arr[i]);
    }
 
    return 0;
}
 
void bubble(void *p, size_t width, int N)
{
    int i, j;
    unsigned char buf[4];
    unsigned char *bp = p;
 
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (compare((void *)(bp + width*(j-1)),
                        (void *)(bp + j*width)))  /* 1 */
            {
/*              t = p[j-1];   */
                memcpy(buf, bp + width*(j-1), width);
/*              p[j-1] = p[j];   */
                memcpy(bp + width*(j-1), bp + j*width , width);
/*              p[j] = t;   */
                memcpy(bp + j*width, buf, width);
            }
        }
    }
}
 
int compare(void *m, void *n)
{
    long *m1, *n1;
    m1 = (long *)m;
    n1 = (long *)n;
    return (*m1 &gt; *n1);
}
 
/*--------------------- end of bubble5.c ---------------------*/</pre>
<p><a href="http://codepad.org/UoaGbBcR">執行 bubble5.c</a></p>
<p>Note that I have changed the data type of the array from int to long to illustrate the changes needed in the compare() function. Within bubble() I've done away with the variable t (which we would have had to change from type int to type long). I have added a buffer of size 4 unsigned characters, which is the size needed to hold a long (this will change again in future modifications to this code). The unsigned character pointer *bp is used to point to the base of the array to be sorted, i.e. to the first element of that array.</p>
<p>We also had to modify what we passed to compare(), and how we do the swapping of elements that the comparison indicates need swapping. Use of memcpy() and pointer notation instead of array notation work towards this reduction in type sensitivity.</p>
<p>Again, making a careful comparison of bubble5.c with bubble4.c can result in improved understanding of what is happening and why.</p>
<p>We move now to bubble6.c where we use the same function bubble() that we used in bubble5.c to sort strings instead of long integers. Of course we have to change the comparison function since the means by which strings are compared is different from that by which long integers are compared. And,in bubble6.c we have deleted the lines within bubble() that were commented out in bubble5.c.</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/*--------------------- bubble6.c ---------------------*/
/* Program bubble_6.c from PTRTUT10.HTM   6/13/97 */
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
#define MAX_BUF 256
 
char arr2[5][20] = {  "Mickey Mouse",
 
                      "Donald Duck",
 
                      "Minnie Mouse",
 
                      "Goofy",
 
                      "Ted Jensen" };
 
void bubble(void *p, int width, int N);
int compare(void *m, void *n);
 
int main(void)
{
    int i;
    putchar('\n');
 
    for (i = 0; i &lt; 5; i++)
    {
        printf("%s\n", arr2[i]);
    }
    bubble(arr2, 20, 5);
    putchar('\n\n');
 
    for (i = 0; i &lt; 5; i++)
    {
        printf("%s\n", arr2[i]);
    }
    return 0;
}
 
void bubble(void *p, int width, int N)
{
    int i, j, k;
    unsigned char buf[MAX_BUF];
    unsigned char *bp = p;
 
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
          k = compare((void *)(bp + width*(j-1)), (void *)(bp + j*width));
          if (k &gt; 0)
            {
             memcpy(buf, bp + width*(j-1), width);
             memcpy(bp + width*(j-1), bp + j*width , width);
             memcpy(bp + j*width, buf, width);
            }
        }
    }
}
 
int compare(void *m, void *n)
{
    char *m1 = m;
    char *n1 = n;
    return (strcmp(m1,n1));
}
 
/*------------------- end of bubble6.c ---------------------*/</pre>
<p><a href="http://codepad.org/Z066Lj9s">執行 bubble6.c</a></p>
<p>But, the fact that bubble() was unchanged from that used in bubble5.c indicates that that function is capable of sorting a wide variety of data types. What is left to do is to pass to bubble() the name of the comparison function we want to use so that it can be truly universal. Just as the name of an array is the address of the first element of the array in the data segment, the name of a function decays into the address of that function in the code segment. Thus we need to use a pointer to a function. In this case the comparison function.</p>
<p>Pointers to functions must match the functions pointed to in the number and types of the parameters and the type of the return value. In our case, we declare our function pointer as:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int *fptr(const void *p1, const void *p2);</pre>
<p><span>Note that were we to write:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int *fptr(const void *p1, const void *p2);</pre>
<p>we would have a function prototype for a function which returned a pointer to type int. That is because in C the parenthesis () operator have a higher precedence than the pointer * operator. By putting the parenthesis around the string (*fptr) we indicate that we are declaring a function pointer.</p>
<p>We now modify our declaration of bubble() by adding, as its 4th parameter, a function pointer of the proper type. It's function prototype becomes:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">void bubble(void *p, int width, int N,

int(*fptr)(const void *, const void *));</pre>
<p><span>When we call the bubble(), we insert the name of the comparison function that we want to use. bubble7.c illustrate how this approach permits the use of the same bubble() function for sorting different types of data.</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/*------------------- bubble7.c ------------------*/
 
/* Program bubble_7.c from PTRTUT10.HTM  6/10/97 */
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
#define MAX_BUF 256
 
long arr[10] = { 3,6,1,2,3,8,4,1,7,2};
char arr2[5][20] = {  "Mickey Mouse",
                      "Donald Duck",
                      "Minnie Mouse",
                      "Goofy",
                      "Ted Jensen" };
 
void bubble(void *p, int width, int N,
            int(*fptr)(const void *, const void *));
int compare_string(const void *m, const void *n);
int compare_long(const void *m, const void *n);
 
int main(void)
{
    int i;
    puts("\nBefore Sorting:\n");
 
    for (i = 0; i &lt; 10; i++)               /* show the long ints */
    {
        printf("%ld ",arr[i]);
    }
    puts("\n");
 
    for (i = 0; i &lt; 5; i++)                  /* show the strings */
    {
        printf("%s\n", arr2[i]);
    }
    bubble(arr, 4, 10, compare_long);          /* sort the longs */
    bubble(arr2, 20, 5, compare_string);     /* sort the strings */
    puts("\n\nAfter Sorting:\n");
 
    for (i = 0; i &lt; 10; i++)             /* show the sorted longs */
    {
        printf("%d ",arr[i]);
    }
    puts("\n");
 
    for (i = 0; i &lt; 5; i++)            /* show the sorted strings */
    {
        printf("%s\n", arr2[i]);
    }
    return 0;
}
 
void bubble(void *p, int width, int N,
            int(*fptr)(const void *, const void *))
{
    int i, j, k;
    unsigned char buf[MAX_BUF];
    unsigned char *bp = p;
 
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            k = fptr((void *)(bp + width*(j-1)), (void *)(bp + j*width));
            if (k &gt; 0)
            {
                memcpy(buf, bp + width*(j-1), width);
                memcpy(bp + width*(j-1), bp + j*width , width);
                memcpy(bp + j*width, buf, width);
            }
        }
    }
}
 
int compare_string(const void *m, const void *n)
{
    char *m1 = (char *)m;
    char *n1 = (char *)n;
    return (strcmp(m1,n1));
}
 
int compare_long(const void *m, const void *n)
{
    long *m1, *n1;
    m1 = (long *)m;
    n1 = (long *)n;
    return (*m1 &gt; *n1);
}
 
/*----------------- end of bubble7.c -----------------*/</pre>
<p><a href="http://codepad.org/Z1E8guTH">執行 bubble7.c</a></p>
<p>References for Chapter 10:</p>
<p>"Algorithms in C" Robert Sedgewick Addison-Wesley ISBN 0-201-51425-7</p>
<br />ch9指標與動態記憶體配置 << <a href='ch9指標與動態記憶體配置.html'>Previous</a> <a href='ch11結語.html'>Next</a> >> ch11結語</section></div></body></html>
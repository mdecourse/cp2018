<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>計算機程式教材</title> <link rel="stylesheet" type="text/css" href="./../static/cmsimply.css">
<link rel="icon" href="./../static/favicon.ico" type="image/x-icon" />

<script type="text/javascript" src="./../static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCSharp.js"></script>
<link type="text/css" rel="stylesheet" href="./../static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- for LaTeX equations 暫時不用
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>
-->
<!-- 暫時不用
<script src="./../static/fengari-web.js"></script>
<script type="text/javascript" src="./../static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->
<style>
img {
    border: 3px solid red;
}
</style>

<script src="./../static/jquery.js"></script>
<script type="text/javascript">
$(function(){
    $("ul.topmenu> li:has(ul) > a").append('<div class="arrow-right"></div>');
    $("ul.topmenu > li ul li:has(ul) > a").append('<div class="arrow-right"></div>');
});
</script>

</head><header><h1>2018 計算機程式教材</h1> <confmenu>
<ul>
<li><a href="index.html">Home</a></li>
<li><a href="sitemap.html">Site Map</a></li>
<li><a href="./../reveal/index.html">reveal</a></li>
<li><a href="./../blog/index.html">blog</a></li>

</ul>
</confmenu></header>
<div class='container'><nav><ul id='css3menu1' class='topmenu'><li><a href='簡介.html'>簡介</a><ul><li><a href='課程規劃.html'>課程規劃</a><li><a href='機械設計.html'>機械設計</a><li><a href='ANSI C.html'>ANSI C</a><li><a href='指標教材.html'>指標教材</a><ul><li><a href='ch1何謂指標.html'>ch1何謂指標</a><li><a href='ch2指標型別與陣列.html'>ch2指標型別與陣列</a><li><a href='ch3指標與字串.html'>ch3指標與字串</a><li><a href='ch4更多關於字串的用法.html'>ch4更多關於字串的用法</a><li><a href='ch5指標與結構.html'>ch5指標與結構</a><li><a href='ch6字串與字串陣列.html'>ch6字串與字串陣列</a><li><a href='ch7多維陣列.html'>ch7多維陣列</a><li><a href='ch8指向陣列的指標.html'>ch8指向陣列的指標</a><li><a href='ch9指標與動態記憶體配置.html'>ch9指標與動態記憶體配置</a><li><a href='ch10指向函式的指標.html'>ch10指向函式的指標</a><li><a href='ch11結語.html'>ch11結語</a></li></ul><li><a href='C++.html'>C++</a><li><a href='Python.html'>Python</a><ul><li><a href='Python 教材.html'>Python 教材</a><li><a href='what is new.html'>what is new</a><li><a href='style guide.html'>style guide</a><li><a href='typing.html'>typing</a><li><a href='dunder.html'>dunder</a><li><a href='Flake8.html'>Flake8</a><li><a href='unittest.html'>unittest</a><li><a href='lark.html'>lark</a></li></ul><li><a href='Kotlin.html'>Kotlin</a><li><a href='Red Lang.html'>Red Lang</a></li></ul><li><a href='工具.html'>工具</a><ul><li><a href='Git.html'>Git</a><li><a href='Fossil SCM.html'>Fossil SCM</a><li><a href='Leo Editor.html'>Leo Editor</a><li><a href='SCiTE.html'>SCiTE</a><li><a href='TinyCC.html'>TinyCC</a><li><a href='Qt.html'>Qt</a><li><a href='Kivy.html'>Kivy</a><li><a href='Eirc IDE.html'>Eirc IDE</a><li><a href='CMSimfly.html'>CMSimfly</a></li></ul><li><a href='實習操作.html'>實習操作</a><ul><li><a href='2018Fall.html'>2018Fall</a><li><a href='hello.c 與 Github.html'>hello.c 與 Github</a><li><a href='hello.c 與 Fossil.html'>hello.c 與 Fossil</a><li><a href='CMSimfly 操作.html'>CMSimfly 操作</a><li><a href='Pygrouf 操作.html'>Pygrouf 操作</a><li><a href='Pelican 操作.html'>Pelican 操作</a><li><a href='Reveal.js 操作.html'>Reveal.js 操作</a><li><a href='數值分析.html'>數值分析</a><li><a href='Qt C++ 計算器程式.html'>Qt C++ 計算器程式</a><ul><li><a href='Qt5 Tutorial.html'>Qt5 Tutorial</a></li></ul><li><a href='PyQt 計算器程式.html'>PyQt 計算器程式</a><ul><li><a href='PyQt5 實際操作.html'>PyQt5 實際操作</a></li></ul><li><a href='Flask 網際程式.html'>Flask 網際程式</a></li></ul><li><a href='應用範例.html'>應用範例</a><ul><li><a href='計算器.html'>計算器</a><li><a href='Tinkercad.html'>Tinkercad</a><li><a href='讀寫網頁內容.html'>讀寫網頁內容</a><li><a href='查英文單字.html'>查英文單字</a><li><a href='docx 轉 pdf.html'>docx 轉 pdf</a><li><a href='網際繪圖.html'>網際繪圖</a><li><a href='GUI 繪圖.html'>GUI 繪圖</a><ul><li><a href='QPainter.html'>QPainter</a><li><a href='靜態繪圖.html'>靜態繪圖</a><li><a href='Moveblocks.html'>Moveblocks</a><li><a href='PyQt5 範例.html'>PyQt5 範例</a><li><a href='STetris.html'>STetris</a><li><a href='Tetrix.html'>Tetrix</a></li></ul><li><a href='V-rep.html'>V-rep</a><ul><li><a href='Lua 學習.html'>Lua 學習</a></li></ul><li><a href='車輛工程.html'>車輛工程</a><ul><li><a href='維修管理.html'>維修管理</a></li></ul><li><a href='ERPNext.html'>ERPNext</a><li><a href='人臉辨識.html'>人臉辨識</a><li><a href='輔助設計套件.html'>輔助設計套件</a><ul><li><a href='NURB-Python.html'>NURB-Python</a><li><a href='libfive.html'>libfive</a><li><a href='robovision.html'>robovision</a><li><a href='jsketcher.html'>jsketcher</a><li><a href='kmolcad.html'>kmolcad</a></li></li></ul></ul><li><a href='分組專題.html'>分組專題</a><ul><li><a href='分組題目.html'>分組題目</a><li><a href='符號式推導.html'>符號式推導</a><li><a href='CMSimfly 解析.html'>CMSimfly 解析</a><ul><li><a href='CMSimfly 開發.html'>CMSimfly 開發</a></li></ul><li><a href='Pygrouf 解析.html'>Pygrouf 解析</a><li><a href='Pyslvs 解析.html'>Pyslvs 解析</a><ul><li><a href='Pyslvs 範例.html'>Pyslvs 範例</a><li><a href='機構設計參考.html'>機構設計參考</a></li></ul><li><a href='Pyquino 解析.html'>Pyquino 解析</a><li><a href='Solvespace 解析.html'>Solvespace 解析</a><li><a href='V-rep 解析.html'>V-rep 解析</a><li><a href='FreeCAD 解析.html'>FreeCAD 解析</a><li><a href='RigitBody library.html'>RigitBody library</a><li><a href='FiniteElement library.html'>FiniteElement library</a><li><a href='網際平面連桿模擬.html'>網際平面連桿模擬</a></li></ul><li><a href='可攜系統.html'>可攜系統</a><ul><li><a href='帳號整合.html'>帳號整合</a><li><a href='代理主機.html'>代理主機</a></li></ul></nav><section>GUI 繪圖 << <a href='GUI 繪圖.html'>Previous</a> <a href='靜態繪圖.html'>Next</a> >> 靜態繪圖<br /><h1>QPainter</h1>
<p>PyQt5 共有三種不同的繪圖 API, 即透過 QPaintDevice 子類別 QWidget 繪圖, QGraphicsScene Canvas 繪圖以及 QtQuick 繪圖.</p>
<p>QWidget 用來繪製典型的 GUI 方形元件, 例如: 按鈕, 查核表單, 下拉式表單等. 因為 QWidget 部件為 QObject 衍生物件, 因此可以直接使用 signals/slots 進行配置.</p>
<p>QGraphicsScene 則為繪圖場景, 提供場景的上下左右捲動, 縮放與旋轉功能. 而視圖為獨立物件, 因為 QGraphicsItem 並非從 QObject 所衍生, 因此無法直接透過 signals/slots 進行配置, 而必須透過 QGraphicsObject 間接配置.</p>
<p>QGraphicsScene 繪圖除了使用內建的 lines, rectangles 等外, 若需要執行客製化繪圖, 可利用 QGraphicsItem 物件中的 paint 方法, 以 QPainter 繪圖.</p>
<p>QtQuick 則是最新加入的繪圖 API, 自 Qt5 版本才納入, 採用 Javascript 技術, 繪圖效率比前兩項更高.採用 QML 而非 C++, 因此可以簡單快速完成所需繪圖內容. QtQuick 除了使用 QML 場景繪圖外, 也可以採 QPainter 繪圖.</p>
<h4><a href="http://doc.qt.io/qt-5/qwidget.html#details">QWidget</a></h4>
<p>Since QWidget is a subclass of QPaintDevice, subclasses can be used to display custom content that is composed using a series of painting operations with an instance of the QPainter class. This approach contrasts with the canvas-style approach used by the Graphics View Framework where items are added to a scene by the application and are rendered by the framework itself.</p>
<p>Each widget performs all painting operations from within its paintEvent() function. This is called whenever the widget needs to be redrawn, either as a result of some external change or when requested by the application.</p>
<p>The QPainter class performs low-level painting on widgets and other paint devices.</p>
<p>QPainter provides highly optimized functions to do most of the drawing GUI programs require. It can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a "natural" coordinate system, but it can also do view and world transformation. QPainter can operate on any object that inherits the QPaintDevice class.</p>
<p>The common use of QPainter is inside a widget's paint event: Construct and customize (e.g. set the pen or the brush) the painter. Then draw. Remember to destroy the QPainter object after drawing.</p>
<p>Every widget in QT5 has a method called paintEvent(…) that is called when the widget needs to be drawn (for instance, when its drawn for the first time or when the size of the widget has changed). The only parameter passed to this method is an event object that can be used to get the current dimensions of the content area that we can draw on by calling its rect() method. That means when we want to use a widget for drawing something on it, we derive a new class from the respective widget class and overwrite the paintEvent(…) method with our own implementation that takes care of the drawing. To do the actual drawing, we need to create an object of the class QPainter and then use the drawing methods it provides. Here is a simple example; the details will be explained below:</p>
<p>Let’s look at the coarse structure first: We are defining a new class derived from QWidget and only overwrite the<span> </span><em>paintEvent(…)</em><span> </span>method, meaning in all other aspects this widget will behave like an instance of QWidget. In the main code, we simply create an instance of our new widget class and make it show up on the screen. Now, let’s look at the body of method<span> </span><em>paintEvent(…)</em>: The first thing to note here is that all drawing needs to be preceded by the creation of the QPainter object (line 31) and the call of its<span> </span><em>begin(…)</em>method using “self” as the parameter standing for the widget object itself because that is what we want to draw on (line 32). To conclude the drawing, we need to call the<span> </span><em>end()</em><span> </span>method of the QPainter object (line 40).</p>
<p>Next, let us look at the methods of the QPainter object we are invoking that all start with “draw…”. These are the methods provided by QPainter to draw different kinds of entities like text, circles or ellipses, rectangles, images, etc. We here use the method<span> </span><em>drawText(…)</em><span> </span>twice to produce the two different lines of text (lines 34 and 35). The difference between the two calls is that in the first one we use absolute coordinates, so the text will be drawn at pixel coordinates 20, 20 counting from the top left corner of the widget’s content area. The second call takes a rectangle (class QRectF) as the first parameter and then draws the text within this rectangle based on the additional text options given as the second parameter which here ask for the text to be centered within the rectangle. This is an example where a class provides several methods with the same name but different parameters, something that is called<span> </span><em>overloading</em>. If you check out the<span> </span><a class="ext" href="http://pyqt.sourceforge.net/Docs/PyQt4/qpainter.html" rel="noopener noreferrer" target="_blank">documentation of QPainter<span aria-label="(link is external)" class="ext"></span></a>, you will see that most methods come in different versions. Now go ahead and resize the window a bit and see how the text produced by the first call always remains at the same absolute position, while that from the second call always stays centered within the available area.</p>
<p>In line 37, we use the method<span> </span><em>drawEllipse(…)</em><span> </span>to produce the circle. There is no special circle drawing method, so we use this one and then provide the same number for the two radii. To draw the rectangle, we use the method<span> </span><em>drawRect(…)</em><span> </span>in the version that takes the coordinates of the corner plus width and height values as parameters.</p>
<p>The remaining calls of methods of the QPainter object are there to affect the way the objects are drawn, e.g. their color. Colors inPyQt5 are represented by instances of the class QColor. In line 33, we create a new QColor object by providing values between 0 and 255 for the color’s red, green, and blue values. Since the red value is 200 and both green and blue are zero, the overall color will be the kind of red that the text appears in. QT5 also has a number of predefined colors that we are using in lines 36 (Qt.darkGreen) and 38 (Qt.blue).</p>
<p>QPainter uses objects of class<span> </span><a class="ext" href="http://pyqt.sourceforge.net/Docs/PyQt4/qpen.html" rel="noopener noreferrer" target="_blank">QPen<span aria-label="(link is external)" class="ext"></span></a><span> </span>and<span> </span><a class="ext" href="http://pyqt.sourceforge.net/Docs/PyQt4/qbrush.html" rel="noopener noreferrer" target="_blank">QBrush<span aria-label="(link is external)" class="ext"></span></a><span> </span>to draw the boundary and inside of a shape. In line 33, it is stated that a pen with red color should be used for the following drawing operations. As a result, both text lines appear in red. In line 36, we create a new QPen object to be used by the QPainter and specify that the color should be dark green, and the line width should be 4. This is used for drawing the circle. In line 38, we do the same with color blue and line width 2, and, in addition, we say that sharp corners should be used for the connection between to adjacent line segments of the shape’s border. This is used for drawing the rectangle. We won’t go further into the details of the different pen and brush properties here but the documentation of the QPen and QBrush classes provide some more examples and explanation. In addition, you will see more use cases in the walkthrough in the next section.</p>
<p>直接繪圖:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5.QtWidgets import (QGraphicsView,
    QGraphicsScene,QApplication)
from PyQt5.QtCore import (QLineF)
    
if __name__ == '__main__':
    import sys
    # 建立應用程式
    app = QApplication(sys.argv)
    # 建立場景
    scene = QGraphicsScene()
    # 在場景中加入字串
    scene.addText("場景中的字串!")
    scene.addLine(QLineF(0, 0, 100, 100))
    scene.addLine(QLineF(100, 0, 0, 100))
    # 將場景放入視圖案例中
    view = QGraphicsView(scene)
    #顯示視圖
    view.show()
    # 執行應用程式
    sys.exit(app.exec())</pre>
<p>在 QWidget 中以 QPainter 繪圖 (必須採 paintEvent 方法)</p>
<p>比較採用 Canvas based 的 QGraphicsScene 放入 QGraphicsView 繪圖差異.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5.QtWidgets import (QGraphicsView,
    QGraphicsScene,QApplication, QWidget)
from PyQt5.QtCore import (Qt, QLineF, QPoint)
from PyQt5.QtGui import (QPainter, QPen, QColor)
     
if __name__ == '__main__':
    import sys
    # 建立應用程式
    app = QApplication(sys.argv)
    # 以 canvas 繪圖模式建立場景
    scene = QGraphicsScene()
    # 在場景中加入字串
    scene.addText("場景中的字串!")
    scene.addLine(QLineF(0, 0, 100, 100))
    scene.addLine(QLineF(100, 0, 0, 100))
    # 將場景放入視圖案例中-方法一
    # view = QGraphicsView(scene)
    # 將場景放入視圖案例中-方法二, 先建 view 後, 
    # 以 setScene() 將 scene 置入
    view = QGraphicsView()
    view.setScene(scene)
    
    # 因 QWidget 為 QPaintDevice subclass, 
    # 可以直接在 QWidget 上以 QPainter 繪圖
    # 建立 QWidget 物件, 以 paintEvent 繪圖
    class window(QWidget):
        def __init__(self):
            super().__init__()

        def paintEvent(self, event): 
            qp = QPainter() 
            qp.begin(self) 
            qp.setPen(QColor(200,0,0)) 
            qp.drawText(20,20, "在固定座標繪字串") 
            qp.drawText(event.rect(), Qt.AlignCenter, "在繪圖區正中央繪字串") 
            qp.setPen(QPen(Qt.darkGreen, 4)) 
            qp.drawEllipse(QPoint(50,60),30,30) 
            qp.setPen(QPen(Qt.blue, 2, join = Qt.MiterJoin)) 
            qp.drawRect(20,60,50,80) 
            qp.end() 
    # 以 window 類別案例建立 win 物件
    win = window()
    # 顯示 win 物件內容
    win.show()
    # 以 QGraphicsView 作為視窗, 將視圖內容於視窗中央顯示
    #view.show()
    # 執行應用程式
    sys.exit(app.exec())</pre>
<p>以 QPainter 繪圖</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sys
from PyQt5.QtWidgets import QWidget, QApplication
from PyQt5.QtGui import QPainter, QColor, QFont
from PyQt5.QtCore import Qt

class Example(QWidget):
    
    def __init__(self):
        super().__init__()
        
        self.initUI()
        
        
    def initUI(self):      
        
        self.text = "Author"

        self.setGeometry(300, 300, 280, 170)
        self.setWindowTitle('Drawing text')
        self.show()
        

    def paintEvent(self, event):

        qp = QPainter()
        qp.begin(self)
        self.drawText(event, qp)
        qp.end()
        
        
    def drawText(self, event, qp):
      
        qp.setPen(QColor(168, 34, 3))
        qp.setFont(QFont('Decorative', 10))
        qp.drawText(event.rect(), Qt.AlignCenter, self.text)        
                
        
if __name__ == '__main__':
    
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec())</pre>
<p>Draw points:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5.QtWidgets import QWidget, QApplication
from PyQt5.QtGui import QPainter
from PyQt5.QtCore import Qt
import sys, random

class Example(QWidget):
    
    def __init__(self):
        super().__init__()
        
        self.initUI()
        
        
    def initUI(self):      

        self.setGeometry(300, 300, 300, 190)
        self.setWindowTitle('Points')
        self.show()
        

    def paintEvent(self, e):

        qp = QPainter()
        qp.begin(self)
        self.drawPoints(qp)
        qp.end()
        
        
    def drawPoints(self, qp):
      
        qp.setPen(Qt.red)
        size = self.size()
        
        for i in range(1000):
            x = random.randint(1, size.width()-1)
            y = random.randint(1, size.height()-1)
            qp.drawPoint(x, y)     
                
        
if __name__ == '__main__':
    
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec())</pre>
<p>Colors:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5.QtWidgets import QWidget, QApplication
from PyQt5.QtGui import QPainter, QColor, QBrush
import sys

class Example(QWidget):
    
    def __init__(self):
        super().__init__()
        
        self.initUI()
        
        
    def initUI(self):      

        self.setGeometry(300, 300, 350, 100)
        self.setWindowTitle('Colours')
        self.show()


    def paintEvent(self, e):

        qp = QPainter()
        qp.begin(self)
        self.drawRectangles(qp)
        qp.end()

        
    def drawRectangles(self, qp):
      
        col = QColor(0, 0, 0)
        col.setNamedColor('#d4d4d4')
        qp.setPen(col)

        qp.setBrush(QColor(200, 0, 0))
        qp.drawRect(10, 15, 90, 60)

        qp.setBrush(QColor(255, 80, 0, 160))
        qp.drawRect(130, 15, 90, 60)

        qp.setBrush(QColor(25, 0, 90, 200))
        qp.drawRect(250, 15, 90, 60)
              
        
if __name__ == '__main__':
    
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec())</pre>
<p>QPen:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5.QtWidgets import QWidget, QApplication
from PyQt5.QtGui import QPainter, QPen
from PyQt5.QtCore import Qt
import sys

class Example(QWidget):
    
    def __init__(self):
        super().__init__()
        
        self.initUI()
        
        
    def initUI(self):      

        self.setGeometry(300, 300, 280, 270)
        self.setWindowTitle('Pen styles')
        self.show()
        

    def paintEvent(self, e):

        qp = QPainter()
        qp.begin(self)
        self.drawLines(qp)
        qp.end()
        
        
    def drawLines(self, qp):
      
        pen = QPen(Qt.black, 2, Qt.SolidLine)

        qp.setPen(pen)
        qp.drawLine(20, 40, 250, 40)

        pen.setStyle(Qt.DashLine)
        qp.setPen(pen)
        qp.drawLine(20, 80, 250, 80)

        pen.setStyle(Qt.DashDotLine)
        qp.setPen(pen)
        qp.drawLine(20, 120, 250, 120)

        pen.setStyle(Qt.DotLine)
        qp.setPen(pen)
        qp.drawLine(20, 160, 250, 160)

        pen.setStyle(Qt.DashDotDotLine)
        qp.setPen(pen)
        qp.drawLine(20, 200, 250, 200)

        pen.setStyle(Qt.CustomDashLine)
        pen.setDashPattern([1, 4, 5, 4])
        qp.setPen(pen)
        qp.drawLine(20, 240, 250, 240)
              
        
if __name__ == '__main__':
    
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec())</pre>
<p>Brush:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5.QtWidgets import QWidget, QApplication
from PyQt5.QtGui import QPainter, QBrush
from PyQt5.QtCore import Qt
import sys

class Example(QWidget):
    
    def __init__(self):
        super().__init__()
        
        self.initUI()
        
        
    def initUI(self):      

        self.setGeometry(300, 300, 355, 280)
        self.setWindowTitle('Brushes')
        self.show()
        

    def paintEvent(self, e):

        qp = QPainter()
        qp.begin(self)
        self.drawBrushes(qp)
        qp.end()
        
        
    def drawBrushes(self, qp):
      
        brush = QBrush(Qt.SolidPattern)
        qp.setBrush(brush)
        qp.drawRect(10, 15, 90, 60)

        brush.setStyle(Qt.Dense1Pattern)
        qp.setBrush(brush)
        qp.drawRect(130, 15, 90, 60)

        brush.setStyle(Qt.Dense2Pattern)
        qp.setBrush(brush)
        qp.drawRect(250, 15, 90, 60)

        brush.setStyle(Qt.DiagCrossPattern)
        qp.setBrush(brush)
        qp.drawRect(10, 105, 90, 60)

        brush.setStyle(Qt.Dense5Pattern)
        qp.setBrush(brush)
        qp.drawRect(130, 105, 90, 60)

        brush.setStyle(Qt.Dense6Pattern)
        qp.setBrush(brush)
        qp.drawRect(250, 105, 90, 60)

        brush.setStyle(Qt.HorPattern)
        qp.setBrush(brush)
        qp.drawRect(10, 195, 90, 60)

        brush.setStyle(Qt.VerPattern)
        qp.setBrush(brush)
        qp.drawRect(130, 195, 90, 60)

        brush.setStyle(Qt.BDiagPattern)
        qp.setBrush(brush)
        qp.drawRect(250, 195, 90, 60)
              
        
if __name__ == '__main__':
    
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec())</pre>
<p>Bezier curve:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from PyQt5.QtWidgets import QWidget, QApplication
from PyQt5.QtGui import QPainter, QPainterPath
from PyQt5.QtCore import Qt
import sys

class Example(QWidget):
    
    def __init__(self):
        super().__init__()
        
        self.initUI()
        
        
    def initUI(self):      

        self.setGeometry(300, 300, 380, 250)
        self.setWindowTitle('Bézier curve')
        self.show()
        

    def paintEvent(self, e):

        qp = QPainter()
        qp.begin(self)
        qp.setRenderHint(QPainter.Antialiasing)
        self.drawBezierCurve(qp)
        qp.end()
        
        
    def drawBezierCurve(self, qp):
      
        path = QPainterPath()
        path.moveTo(30, 30)
        path.cubicTo(30, 30, 200, 350, 350, 30)
        
        qp.drawPath(path)
              
        
if __name__ == '__main__':
    
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec())</pre>
<p>QPainter:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sys
from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QLabel
from PyQt5.QtGui import QPainter, QColor, QPen
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import Qt
import random
 
class App(QMainWindow):
 
    def __init__(self):
        super().__init__()
        self.title = 'PyQt paint example'
        self.left = 10
        self.top = 10
        self.width = 440
        self.height = 280
        self.initUI()
 
    def initUI(self):
        self.setWindowTitle(self.title)
        self.setGeometry(self.left, self.top, self.width, self.height)
 
        # Set window background color
        self.setAutoFillBackground(True)
        p = self.palette()
        p.setColor(self.backgroundRole(), Qt.white)
        self.setPalette(p)
 
        # Add paint widget and paint
        self.m = PaintWidget(self)
        self.m.move(0,0)
        self.m.resize(self.width,self.height)
 
        self.show()
 
 
class PaintWidget(QWidget):
   def paintEvent(self, event):
      qp = QPainter(self)
 
      qp.setPen(Qt.black)
      size = self.size()
 
      for i in range(1024):
          x = random.randint(1, size.width()-1)
          y = random.randint(1, size.height()-1)
          qp.drawPoint(x, y)
 
 
if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = App()
    sys.exit(app.exec())</pre>
<p>Screen Shot:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">"""Screenshot and that kind of stuff."""
import io
from PyQt5.QtCore import QUrl, QIODevice, QBuffer, QByteArray
from PyQt5.QtWidgets import QApplication
from PyQt5.QtGui import QImage, QPainter
from PyQt5.QtWebEngineWidgets import QWebEngineView

class Screenshot(QWebEngineView):
    def __init__(self):
        self.app = QApplication([])
        QWebEngineView.__init__(self)
        self._loaded = False
        self.loadFinished.connect(self._load_finished)
        print('--finish init')

    def capture(self, url):
        print('--load')
        self.load(QUrl(url))
        self.wait_load()
        self.show()
        size = self.page().contentsSize()
        self.page().view().resize(*[int(s) for s in [size.width(), size.height()]])
        print('--take image')
        image = QImage(800, 800, QImage.Format_ARGB32)
        painter = QPainter(image)
        print('--render')
        self.page().view().render(painter)
        painter.end()
        print('Saving QImage')
        img_bytes = QByteArray()
        bio = QBuffer(img_bytes)
        bio.open(QIODevice.WriteOnly)
        image.save(bio, 'PNG')
        return img_bytes

    def wait_load(self):
        while not self._loaded:
            self.app.processEvents()
        self._loaded = False

    def _load_finished(self, result):
        self._loaded = True</pre>
<p>Reference:</p>
<p><a href="https://github.com/pyqt/examples">https://github.com/pyqt/examples</a> </p>
<p><a href="https://github.com/mfitzp/15-minute-apps">https://github.com/mfitzp/15-minute-apps</a> </p>
<br />GUI 繪圖 << <a href='GUI 繪圖.html'>Previous</a> <a href='靜態繪圖.html'>Next</a> >> 靜態繪圖</section></div></body></html>